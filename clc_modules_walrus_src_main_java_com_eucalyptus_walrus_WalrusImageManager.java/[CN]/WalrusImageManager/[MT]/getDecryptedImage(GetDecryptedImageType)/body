{
  GetDecryptedImageResponseType reply=(GetDecryptedImageResponseType)request.getReply();
  String bucketName=request.getBucket();
  String objectKey=request.getKey();
  Context ctx=Contexts.lookup();
  final String correlationId=ctx.getCorrelationId();
  Account account=ctx.getAccount();
  final String accountNumber=account.getAccountNumber();
  logWithContext("Processing GetDecryptedImage request for " + bucketName + "/"+ objectKey,Level.INFO,correlationId,accountNumber);
  EntityWrapper<BucketInfo> db=EntityWrapper.get(BucketInfo.class);
  try {
    BucketInfo bucketInfo=new BucketInfo(bucketName);
    List<BucketInfo> bucketList=db.queryEscape(bucketInfo);
    if (bucketList.size() > 0) {
      EntityWrapper<ObjectInfo> dbObject=db.recast(ObjectInfo.class);
      ObjectInfo searchObjectInfo=new ObjectInfo(bucketName,objectKey);
      List<ObjectInfo> objectInfos=dbObject.queryEscape(searchObjectInfo);
      if (objectInfos.size() > 0) {
        ObjectInfo objectInfo=objectInfos.get(0);
        logWithContext("Found object for caching: " + objectInfo.getBucketName() + "/"+ objectInfo.getObjectKey()+ " version: "+ (objectInfo.getVersionId() == null ? "null" : objectInfo.getVersionId()),null,correlationId,accountNumber);
        if (ctx.hasAdministrativePrivileges() || (objectInfo.canRead(account.getAccountNumber()) && Lookups.checkPrivilege(PolicySpec.S3_GETOBJECT,PolicySpec.VENDOR_S3,PolicySpec.S3_RESOURCE_OBJECT,PolicySpec.objectFullName(bucketName,objectKey),objectInfo.getOwnerId()))) {
          db.commit();
          EucaSemaphore semaphore=EucaSemaphoreDirectory.getSemaphore(bucketName + "/" + objectKey);
          try {
            try {
              semaphore.acquire();
            }
 catch (            InterruptedException ex) {
              throw new WalrusException("semaphore could not be acquired");
            }
            EntityWrapper<ImageCacheInfo> db2=EntityWrapper.get(ImageCacheInfo.class);
            try {
              ImageCacheInfo searchImageCacheInfo=new ImageCacheInfo(bucketName,objectKey);
              List<ImageCacheInfo> foundImageCacheInfos=db2.queryEscape(searchImageCacheInfo);
              if (foundImageCacheInfos.size() > 0) {
                ImageCacheInfo imageCacheInfo=foundImageCacheInfos.get(0);
                if (imageCacheInfo.getInCache() && (!storageManager.objectExists(bucketName,imageCacheInfo.getImageName()))) {
                  this.deleteAllArtifacts(bucketName,imageCacheInfo.getImageName());
                  db2.delete(imageCacheInfo);
                  db2.commit();
                  logWithContext("Deleted cache entry: " + bucketName + "/"+ objectKey,null,correlationId,accountNumber);
                  db2=EntityWrapper.get(ImageCacheInfo.class);
                  foundImageCacheInfos=db2.queryEscape(searchImageCacheInfo);
                }
              }
              if ((foundImageCacheInfos.size() == 0) || (!imageCachers.containsKey(bucketName + objectKey))) {
                db2.commit();
                logWithContext("No existing cache entries found or in-progress tasks, initiating caching of image " + bucketName + "/"+ objectKey+ ".",null,correlationId,accountNumber);
                cacheImage(bucketName,objectKey,account,ctx.hasAdministrativePrivileges(),correlationId);
                db2=EntityWrapper.get(ImageCacheInfo.class);
                foundImageCacheInfos=db2.queryEscape(searchImageCacheInfo);
              }
              ImageCacheInfo foundImageCacheInfo=null;
              if (foundImageCacheInfos.size() > 0) {
                foundImageCacheInfo=foundImageCacheInfos.get(0);
              }
              db2.commit();
              if ((foundImageCacheInfo == null) || (!foundImageCacheInfo.getInCache())) {
                boolean cached=false;
                String taskId=null;
                WalrusMonitor monitor=imageMessenger.getMonitor(bucketName + "/" + objectKey);
synchronized (monitor) {
                  try {
                    long lastCheckBytesCached=0;
                    int number_of_tries=0;
                    long totalBytesCached=0;
                    while (!(cached=isCached(bucketName,objectKey)) && cachingInProgress(bucketName,objectKey) && number_of_tries <= WalrusProperties.IMAGE_CACHE_WAIT_RETRY_LIMIT) {
                      totalBytesCached=checkCachingProgress(bucketName,objectKey);
                      if (totalBytesCached <= lastCheckBytesCached) {
                        number_of_tries++;
                      }
                      lastCheckBytesCached=Math.max(totalBytesCached,lastCheckBytesCached);
                      taskId=getTaskId(bucketName,objectKey);
                      logWithContext("Caching in progress. Bytes cached so far for image " + bucketName + "/"+ objectKey+ " :"+ String.valueOf(lastCheckBytesCached)+ " caching task ID: "+ taskId,Level.DEBUG,correlationId,accountNumber);
                      logWithContext("Caching in progress for " + bucketName + "/"+ objectKey+ " with caching task ID:"+ taskId+ " Waiting "+ WalrusProperties.CACHE_PROGRESS_TIMEOUT+ "ms for image to cache ("+ number_of_tries+ " out of "+ WalrusProperties.IMAGE_CACHE_WAIT_RETRY_LIMIT+ ")",Level.DEBUG,correlationId,accountNumber);
                      monitor.wait(WalrusProperties.CACHE_PROGRESS_TIMEOUT);
                    }
                  }
 catch (                  Exception ex) {
                    logWithContext("Failed on exception while waiting for image cache progress for image: " + bucketName + "/"+ objectKey+ ". Exception: "+ ex.getMessage(),Level.ERROR,correlationId,accountNumber);
                    LOG.error("Failed waiting for caching",ex);
                    semaphore.release();
                    semaphore=null;
                    imageMessenger.removeMonitor(bucketName + "/" + objectKey);
                    throw new WalrusException("monitor failure");
                  }
                }
                if (!cached) {
                  logWithContext("Finished waiting to cache image: " + bucketName + "/"+ objectKey+ ". Caching not complete",Level.ERROR,correlationId,accountNumber);
                  imageMessenger.removeMonitor(bucketName + "/" + objectKey);
                  semaphore.release();
                  semaphore=null;
                  if (!imageCachers.containsKey(bucketName + objectKey)) {
                    logWithContext("No caching task in progress, so deleting Image Cache Info: " + bucketName + "/"+ objectKey,null,correlationId,accountNumber);
                    db2=EntityWrapper.get(ImageCacheInfo.class);
                    try {
                      foundImageCacheInfos=db2.queryEscape(searchImageCacheInfo);
                      if (foundImageCacheInfos.size() > 0) {
                        db2.delete(foundImageCacheInfos.get(0));
                      }
                      db2.commit();
                    }
 catch (                    Exception e) {
                      logWithContext("Failed to commit delete of cache record. May already be removed: " + e.getMessage(),Level.ERROR,correlationId,accountNumber);
                    }
 finally {
                      db2.rollback();
                    }
                  }
 else {
                    logWithContext("Caching task still in progress: " + bucketName + "/"+ objectKey+ " . Try run instances request again in a while...",null,correlationId,accountNumber);
                  }
                  throw new NoSuchEntityException("Caching failure: " + bucketName + "/"+ objectKey);
                }
 else {
                  logWithContext("Finished waiting to cache image: " + bucketName + "/"+ objectKey+ ". Caching completed",null,correlationId,accountNumber);
                }
                db2=EntityWrapper.get(ImageCacheInfo.class);
                try {
                  foundImageCacheInfos=db2.queryEscape(searchImageCacheInfo);
                  if (foundImageCacheInfos.size() > 0) {
                    foundImageCacheInfo=foundImageCacheInfos.get(0);
                    foundImageCacheInfo.setUseCount(foundImageCacheInfo.getUseCount() + 1);
                    if (!foundImageCacheInfo.getInCache()) {
                      logWithContext("Image: " + bucketName + "/"+ objectKey+ " metadata indicates not in cache. This is unexpected. Returning an error to the client",Level.ERROR,correlationId,accountNumber);
                      throw new NoSuchEntityException(objectKey);
                    }
 else {
                      logWithContext("Cache check ok for image: " + bucketName + "/"+ objectKey+ ". Preparing response to client",null,correlationId,accountNumber);
                    }
                  }
 else {
                    semaphore.release();
                    semaphore=null;
                    logWithContext("Image metadata not found. Unexpected error. Image: " + bucketName + "/"+ objectKey+ ". Returning failure to client",Level.ERROR,correlationId,accountNumber);
                    throw new NoSuchEntityException(objectKey);
                  }
                  db2.commit();
                }
  finally {
                  db2.rollback();
                }
              }
              Long unencryptedSize=foundImageCacheInfo.getSize();
              String imageKey=foundImageCacheInfo.getImageName();
              reply.setSize(unencryptedSize);
              reply.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(),DateUtils.ISO8601_DATETIME_PATTERN) + ".000Z");
              reply.setEtag("");
              logWithContext("GetDecryptedImage successful for image: " + bucketName + "/"+ objectKey+ ". Sending image to client",null,correlationId,accountNumber);
              DefaultHttpResponse httpResponse=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.OK);
              storageManager.sendObject(request,httpResponse,bucketName,imageKey,unencryptedSize,null,DateUtils.format(objectInfo.getLastModified().getTime(),DateUtils.ISO8601_DATETIME_PATTERN + ".000Z"),objectInfo.getContentType(),objectInfo.getContentDisposition(),request.getIsCompressed(),null,null);
              semaphore.release();
              semaphore=null;
              imageMessenger.removeMonitor(bucketName + "/" + objectKey);
            }
  finally {
              db2.rollback();
            }
            return reply;
          }
  finally {
            if (semaphore != null) {
              semaphore.release();
            }
          }
        }
 else {
          logWithContext("GetDecryptedImage failed for image: " + bucketName + "/"+ objectKey+ ". Access is denied.",null,correlationId,accountNumber);
          throw new AccessDeniedException("Key",objectKey);
        }
      }
 else {
        logWithContext("GetDecryptedImage failed for image: " + bucketName + "/"+ objectKey+ ". No such object found.",null,correlationId,accountNumber);
        throw new NoSuchEntityException(objectKey);
      }
    }
 else {
      logWithContext("GetDecryptedImage failed for image: " + bucketName + "/"+ objectKey+ ". No such bucket found.",null,correlationId,accountNumber);
      throw new NoSuchBucketException(bucketName);
    }
  }
  finally {
    db.rollback();
  }
}
