{
  GetDecryptedImageResponseType reply=(GetDecryptedImageResponseType)request.getReply();
  String bucketName=request.getBucket();
  String objectKey=request.getKey();
  String userId=request.getUserId();
  EntityWrapper<BucketInfo> db=new EntityWrapper<BucketInfo>();
  BucketInfo bucketInfo=new BucketInfo(bucketName);
  List<BucketInfo> bucketList=db.query(bucketInfo);
  if (bucketList.size() > 0) {
    BucketInfo bucket=bucketList.get(0);
    for (    ObjectInfo objectInfo : bucket.getObjects()) {
      if (objectInfo.getObjectKey().equals(objectKey)) {
        if (objectInfo.canRead(userId) || request.isAdministrator()) {
          WalrusSemaphore semaphore=imageMessenger.getSemaphore(bucketName + "/" + objectKey);
          try {
            semaphore.acquire();
          }
 catch (          InterruptedException ex) {
            throw new EucalyptusCloudException("semaphore could not be acquired");
          }
          EntityWrapper<ImageCacheInfo> db2=new EntityWrapper<ImageCacheInfo>();
          ImageCacheInfo searchImageCacheInfo=new ImageCacheInfo(bucketName,objectKey);
          List<ImageCacheInfo> foundImageCacheInfos=db2.query(searchImageCacheInfo);
          if ((foundImageCacheInfos.size() == 0) || (!imageCachers.containsKey(bucketName + objectKey))) {
            db2.commit();
            cacheImage(bucketName,objectKey,userId,request.isAdministrator());
            db2=new EntityWrapper<ImageCacheInfo>();
            foundImageCacheInfos=db2.query(searchImageCacheInfo);
          }
          ImageCacheInfo foundImageCacheInfo=null;
          if ((foundImageCacheInfos.size() == 0) || (!foundImageCacheInfos.get(0).getInCache())) {
            boolean cached=false;
            WalrusMonitor monitor=imageMessenger.getMonitor(bucketName + "/" + objectKey);
synchronized (monitor) {
              try {
                long bytesCached=0;
                int number_of_tries=0;
                do {
                  monitor.wait(CACHE_PROGRESS_TIMEOUT);
                  if (isCached(bucketName,objectKey)) {
                    cached=true;
                    break;
                  }
                  long newBytesCached=checkCachingProgress(bucketName,objectKey,bytesCached);
                  boolean is_caching=(newBytesCached - bytesCached) > 0 ? true : false;
                  if (!is_caching && (number_of_tries++ >= CACHE_RETRY_LIMIT))                   break;
                  bytesCached=newBytesCached;
                  if (is_caching) {
                    LOG.info("Bytes cached so far for image " + bucketName + "/"+ objectKey+ " :"+ String.valueOf(bytesCached));
                  }
                }
 while (true);
              }
 catch (              Exception ex) {
                LOG.error(ex);
                db2.rollback();
                db.rollback();
                throw new EucalyptusCloudException("monitor failure");
              }
            }
            if (!cached) {
              LOG.error("Tired of waiting to cache image: " + bucketName + "/"+ objectKey+ " giving up");
              db2.rollback();
              db.rollback();
              throw new EucalyptusCloudException("caching failure");
            }
            db2.commit();
            db2=new EntityWrapper<ImageCacheInfo>();
            foundImageCacheInfos=db2.query(searchImageCacheInfo);
            if (foundImageCacheInfos.size() > 0) {
              foundImageCacheInfo=foundImageCacheInfos.get(0);
              foundImageCacheInfo.setUseCount(foundImageCacheInfo.getUseCount() + 1);
              assert(foundImageCacheInfo.getInCache());
            }
 else {
              db.rollback();
              db2.rollback();
              throw new NoSuchEntityException(objectKey);
            }
          }
          Long unencryptedSize=foundImageCacheInfo.getSize();
          String imageKey=foundImageCacheInfo.getImageName();
          String queueKey=bucketName + "." + objectKey;
          String randomKey=queueKey + "." + Hashes.getRandom(10);
          request.setRandomKey(randomKey);
          LinkedBlockingQueue<WalrusDataMessage> getQueue=WalrusQueryDispatcher.getReadMessenger().getQueue(queueKey,randomKey);
          reply.setSize(unencryptedSize);
          reply.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(),DateUtils.ISO8601_DATETIME_PATTERN));
          reply.setEtag("");
          Reader reader=new Reader(bucketName,imageKey,unencryptedSize,getQueue,false,semaphore);
          reader.start();
          db.commit();
          db2.commit();
          return reply;
        }
 else {
          db.rollback();
          throw new AccessDeniedException(objectKey);
        }
      }
    }
    db.rollback();
    throw new NoSuchEntityException(objectKey);
  }
 else {
    db.rollback();
    throw new NoSuchBucketException(bucketName);
  }
}
