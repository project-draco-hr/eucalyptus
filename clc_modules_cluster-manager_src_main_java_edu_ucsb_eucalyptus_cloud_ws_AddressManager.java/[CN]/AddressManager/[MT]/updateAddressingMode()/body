{
  int allocatedCount=0;
  List<Address> activeList=Addresses.getInstance().listValues();
  for (  Address allocatedAddr : activeList) {
    if (Component.eucalyptus.name().equals(allocatedAddr.getUserId())) {
      allocatedCount++;
      try {
        if (EucalyptusProperties.getSystemConfiguration().isDoDynamicPublicAddresses() && !allocatedAddr.isAssigned() && !allocatedAddr.isPending()) {
          LOG.debug("Deallocating unassigned public address in dynamic public addressing mode: " + allocatedAddr.getName());
          EntityWrapper<Address> db=new EntityWrapper<Address>();
          try {
            Address dbAddr=db.getUnique(allocatedAddr);
            db.delete(dbAddr);
            db.commit();
          }
 catch (          EucalyptusCloudException e) {
            db.rollback();
          }
          allocatedAddr.release();
          Addresses.getInstance().disable(allocatedAddr.getName());
        }
      }
 catch (      EucalyptusCloudException e) {
      }
    }
  }
  LOG.debug("Found " + allocatedCount + " addresses allocated to eucalyptus");
  try {
    if (!EucalyptusProperties.getSystemConfiguration().isDoDynamicPublicAddresses()) {
      int allocCount=EucalyptusProperties.getSystemConfiguration().getSystemReservedPublicAddresses() - allocatedCount;
      LOG.debug("Allocating additional " + allocCount + " addresses in static public addresing mode");
      ConcurrentNavigableMap<String,Address> unusedAddresses=Addresses.getInstance().getDisabledMap();
      allocCount=unusedAddresses.size() < allocCount ? unusedAddresses.size() : allocCount;
      if (allocCount > 0) {
        List<Map.Entry<String,Address>> addressList=Lists.newArrayList();
        for (int i=0; i < allocCount; i++) {
          Map.Entry<String,Address> addressEntry=unusedAddresses.pollFirstEntry();
          if (addressEntry != null) {
            addressList.add(addressEntry);
          }
 else {
            break;
          }
        }
        NavigableSet<String> ipList=Sets.newTreeSet();
        for (        Map.Entry<String,Address> addressEntry : addressList) {
          LOG.debug("Allocating address for static public addressing: " + addressEntry.getValue().getName());
          Address address=addressEntry.getValue();
          address.allocate(Component.eucalyptus.name());
          EntityWrapper<Address> db=new EntityWrapper<Address>();
          try {
            Address addr=db.getUnique(new Address(address.getName()));
            addr.allocate(Component.eucalyptus.name());
          }
 catch (          EucalyptusCloudException e) {
            db.merge(address);
          }
          db.commit();
          ipList.add(address.getName());
          try {
            Addresses.getInstance().register(address);
          }
 catch (          Exception e) {
          }
        }
      }
 else {
        for (        String ipAddr : Addresses.getInstance().getActiveMap().descendingKeySet()) {
          Address addr=Addresses.getInstance().getActiveMap().get(ipAddr);
          if (Component.eucalyptus.name().equals(addr.getUserId()) && !addr.isAssigned() && !addr.isPending()) {
            if (allocCount++ >= 0)             break;
            EntityWrapper<Address> db=new EntityWrapper<Address>();
            try {
              Address dbAddr=db.getUnique(new Address(addr.getName()));
              db.delete(dbAddr);
              db.commit();
            }
 catch (            EucalyptusCloudException e) {
              db.rollback();
            }
            addr.release();
            Addresses.getInstance().disable(addr.getName());
          }
        }
      }
    }
  }
 catch (  EucalyptusCloudException e) {
  }
}
