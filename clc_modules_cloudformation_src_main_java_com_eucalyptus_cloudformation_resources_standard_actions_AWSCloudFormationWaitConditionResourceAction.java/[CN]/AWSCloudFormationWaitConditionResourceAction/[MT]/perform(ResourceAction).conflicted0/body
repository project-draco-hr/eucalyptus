{
  LOG.trace("Creating wait condition");
  AWSCloudFormationWaitConditionResourceAction action=(AWSCloudFormationWaitConditionResourceAction)resourceAction;
  int numSignals=action.properties.getCount() != null && action.properties.getCount() > 0 ? action.properties.getCount() : 1;
  LOG.trace("num signals = " + numSignals);
  if (action.properties.getTimeout() > 43200) {
    throw new ValidationErrorException("timeout can not be more than 43200");
  }
  LOG.trace("Timeout = " + action.properties.getTimeout());
  LOG.trace("Looking for handle : " + action.properties.getHandle());
  List<StackResourceEntity> stackResourceEntityList=StackResourceEntityManager.getStackResources(action.getStackEntity().getStackId(),action.info.getAccountId(),action.getStackEntity().getUpdateVersion());
  StackResourceEntity handleEntity=null;
  for (  StackResourceEntity stackResourceEntity : stackResourceEntityList) {
    if (stackResourceEntity.getPhysicalResourceId() != null && stackResourceEntity.getPhysicalResourceId().equals(action.properties.getHandle())) {
      LOG.trace("found something with the same physical id, type:" + stackResourceEntity.getResourceType());
      if (stackResourceEntity.getResourceType().equals("AWS::CloudFormation::WaitConditionHandle")) {
        handleEntity=stackResourceEntity;
        break;
      }
    }
  }
  if (handleEntity == null) {
    throw new Exception("Handle URL:" + action.properties.getHandle() + " does not match a WaitConditionHandle from this stack");
  }
  AWSCloudFormationWaitConditionHandleResourceInfo handleResourceInfo=(AWSCloudFormationWaitConditionHandleResourceInfo)StackResourceEntityManager.getResourceInfo(handleEntity);
  ObjectNode objectNode=(ObjectNode)JsonHelper.getJsonNodeFromString(handleResourceInfo.getEucaParts());
  if (!"1.0".equals(objectNode.get("version").asText()))   throw new Exception("Invalid version for eucaParts");
  String bucketName=objectNode.get("bucket").asText();
  LOG.trace("bucketName=" + bucketName);
  String keyName=objectNode.get("key").asText();
  LOG.trace("keyName=" + bucketName);
  boolean foundFailure=false;
  final Map<String,String> dataMap=Maps.newHashMap();
  try (final EucaS3Client s3c=EucaS3ClientFactory.getEucaS3Client(new CloudFormationAWSCredentialsProvider())){
    LOG.trace("Handle:" + action.properties.getHandle());
    VersionListing versionListing=s3c.listVersions(bucketName,"");
    LOG.trace("Found " + versionListing.getVersionSummaries() + " versions to check");
    for (    S3VersionSummary versionSummary : versionListing.getVersionSummaries()) {
      LOG.trace("Key:" + versionSummary.getKey());
      if (!versionSummary.getKey().equals(keyName)) {
        continue;
      }
      LOG.trace("Getting version: " + versionSummary.getVersionId());
      try {
        GetObjectRequest getObjectRequest=new GetObjectRequest(bucketName,keyName,versionSummary.getVersionId());
        S3Object s3Object=s3c.getObject(getObjectRequest);
        JsonNode jsonNode=null;
        try (S3ObjectInputStream s3ObjectInputStream=s3Object.getObjectContent()){
          jsonNode=new ObjectMapper().readTree(s3ObjectInputStream);
        }
         if (!jsonNode.isObject()) {
          LOG.trace("Read object, json but not object..skipping file");
          continue;
        }
        ObjectNode localObjectNode=(ObjectNode)jsonNode;
        String status=localObjectNode.get("Status").asText();
        if (status == null) {
          LOG.trace("Null status, skipping");
          continue;
        }
        String data=localObjectNode.get("Data").asText();
        if (data == null) {
          LOG.trace("Null data, skipping");
          continue;
        }
        String uniqueId=localObjectNode.get("UniqueId").asText();
        if (data == null) {
          LOG.trace("Null uniqueId, skipping");
          continue;
        }
        if ("FAILURE".equals(status)) {
          foundFailure=true;
          LOG.trace("found failure, gonna die");
          break;
        }
 else         if (!"SUCCESS".equals(status)) {
          LOG.trace("weird status...skipping");
          continue;
        }
 else {
          LOG.trace("found success, uniqueId=" + uniqueId);
          dataMap.put(uniqueId,data);
        }
      }
 catch (      Exception ex) {
        LOG.error(ex,ex);
        LOG.trace("Exception while going through the objects, will skip this one.");
      }
    }
  }
   if (foundFailure) {
    throw new ResourceFailureException("Found failure signal");
  }
  LOG.trace("Have " + dataMap.size() + " success signals, need "+ numSignals);
  if (dataMap.size() >= numSignals) {
    LOG.trace("Success");
    ObjectNode dataNode=new ObjectMapper().createObjectNode();
    for (    String uniqueId : dataMap.keySet()) {
      dataNode.put(uniqueId,dataMap.get(uniqueId));
    }
    action.info.setData(JsonHelper.getStringFromJsonNode(dataNode));
    action.info.setPhysicalResourceId(keyName);
    action.info.setReferenceValueJson(JsonHelper.getStringFromJsonNode(new TextNode(action.info.getPhysicalResourceId())));
    return action;
  }
 else {
    throw new RetryAfterConditionCheckFailedException("Not enough success signals yet");
  }
}
