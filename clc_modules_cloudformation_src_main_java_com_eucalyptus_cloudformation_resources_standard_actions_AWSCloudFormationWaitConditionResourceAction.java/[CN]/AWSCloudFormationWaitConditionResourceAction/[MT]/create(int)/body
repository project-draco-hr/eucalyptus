{
  LOG.trace("Creating wait condition");
switch (stepNum) {
case 0:
    int numSignals=properties.getCount() != null && properties.getCount() > 0 ? properties.getCount() : 1;
  LOG.trace("num signals = " + numSignals);
if (properties.getTimeout() > 43200) {
  throw new Exception("timeout can not be more than 43200");
}
LOG.trace("Timeout = " + properties.getTimeout());
try {
LOG.trace("Looking for handle : " + properties.getHandle());
List<StackResourceEntity> stackResourceEntityList=StackResourceEntityManager.getStackResources(getStackEntity().getStackId(),info.getAccountId());
StackResourceEntity handleEntity=null;
for (StackResourceEntity stackResourceEntity : stackResourceEntityList) {
if (stackResourceEntity.getPhysicalResourceId() != null && stackResourceEntity.getPhysicalResourceId().equals(properties.getHandle())) {
  LOG.trace("found something with the same physical id, type:" + stackResourceEntity.getResourceType());
  if (stackResourceEntity.getResourceType().equals("AWS::CloudFormation::WaitConditionHandle")) {
    handleEntity=stackResourceEntity;
    break;
  }
}
}
if (handleEntity == null) {
throw new Exception("Handle URL:" + properties.getHandle() + " does not match a WaitConditionHandle from this stack");
}
AWSCloudFormationWaitConditionHandleResourceInfo handleResourceInfo=(AWSCloudFormationWaitConditionHandleResourceInfo)StackResourceEntityManager.getResourceInfo(handleEntity);
ObjectNode objectNode=(ObjectNode)JsonHelper.getJsonNodeFromString(handleResourceInfo.getEucaParts());
if (!"1.0".equals(objectNode.get("version").textValue())) throw new Exception("Invalid version for eucaParts");
String bucketName=objectNode.get("bucket").textValue();
LOG.trace("bucketName=" + bucketName);
String keyName=objectNode.get("key").textValue();
LOG.trace("keyName=" + bucketName);
LOG.trace("Starting to poll");
URI serviceURI=ServiceUris.remotePublicify(ObjectStorage.class);
User user=Accounts.lookupUserById(getResourceInfo().getEffectiveUserId());
final EucaS3Client s3c=EucaS3ClientFactory.getEucaS3Client(user);
long startTime=System.currentTimeMillis();
long currentTime=System.currentTimeMillis();
do {
boolean foundFailure=false;
LOG.trace("Handle:" + properties.getHandle());
VersionListing versionListing=s3c.listVersions(bucketName,keyName);
LOG.trace("Found " + versionListing.getVersionSummaries() + " versions to check");
Map<String,String> dataMap=Maps.newHashMap();
for (S3VersionSummary versionSummary : versionListing.getVersionSummaries()) {
  LOG.trace("Key:" + versionSummary.getKey());
  if (!versionSummary.getKey().equals(keyName)) {
    LOG.trace("Wrong key (probably key is a prefix).  Skipping");
    return;
  }
  LOG.trace("Getting version: " + versionSummary.getVersionId());
  try {
    GetObjectRequest getObjectRequest=new GetObjectRequest(bucketName,keyName,versionSummary.getVersionId());
    S3Object s3Object=s3c.getObject(getObjectRequest);
    JsonNode jsonNode=null;
    try (S3ObjectInputStream s3ObjectInputStream=s3Object.getObjectContent()){
      jsonNode=new ObjectMapper().readTree(s3ObjectInputStream);
    }
     if (!jsonNode.isObject()) {
      LOG.trace("Read object, json but not object..skipping file");
      continue;
    }
    ObjectNode localObjectNode=(ObjectNode)jsonNode;
    String status=localObjectNode.get("Status").textValue();
    if (status == null) {
      LOG.trace("Null status, skipping");
      continue;
    }
    String data=localObjectNode.get("Data").textValue();
    if (data == null) {
      LOG.trace("Null data, skipping");
      continue;
    }
    String uniqueId=localObjectNode.get("UniqueId").textValue();
    if (data == null) {
      LOG.trace("Null uniqueId, skipping");
      continue;
    }
    if ("FAILURE".equals(status)) {
      foundFailure=true;
      LOG.trace("found failure, gonna die");
      break;
    }
 else     if (!"SUCCESS".equals(status)) {
      LOG.trace("weird status...skipping");
      continue;
    }
 else {
      LOG.trace("found success, uniqueId=" + uniqueId);
      dataMap.put(uniqueId,data);
    }
  }
 catch (  Exception ex) {
    LOG.error(ex,ex);
    LOG.trace("Exception while going through the objects, will skip this one.");
  }
}
if (foundFailure) {
  throw new Exception("Found failure signal");
}
LOG.trace("Have " + dataMap.size() + " success signals, need "+ numSignals);
if (dataMap.size() >= numSignals) {
  LOG.trace("Success");
  ObjectNode dataNode=new ObjectMapper().createObjectNode();
  for (  String uniqueId : dataMap.keySet()) {
    dataNode.put(uniqueId,dataMap.get(uniqueId));
  }
  info.setData(JsonHelper.getStringFromJsonNode(dataNode));
  info.setPhysicalResourceId(keyName);
  info.setReferenceValueJson(JsonHelper.getStringFromJsonNode(new TextNode(info.getPhysicalResourceId())));
  return;
}
 else {
  LOG.trace("Will sleep and try again");
  Thread.sleep(5000L);
}
LOG.trace("Time to wait: " + (properties.getTimeout() * 1000L));
currentTime=System.currentTimeMillis();
LOG.trace("Time elapsed: " + (currentTime - startTime));
}
 while ((currentTime - startTime) <= 1000L * properties.getTimeout());
throw new Exception("Timeout while waiting for signals");
}
 catch (Exception ex) {
LOG.error(ex,ex);
throw ex;
}
default :
throw new IllegalStateException("Invalid step " + stepNum);
}
}
