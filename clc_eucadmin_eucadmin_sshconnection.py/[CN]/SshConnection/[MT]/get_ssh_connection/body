def get_ssh_connection(self, hostname, username='root', password=None, keypath=None, proxy=None, proxy_username=None, proxy_password=None, proxy_keypath=None, use_pub_keys=None, enable_ipv6_dns=None, port=22, timeout=60, retry=1, verbose=False):
    "\n        Create a paramiko ssh session to hostname. Will attempt to authenticate first with a keypath if provided,\n        if the sshkey file path is not provided.  username and password will be used to authenticate. This leaves out\n        the case where a password is passed as the password needed to unlock the key file. This 3rd case may need to be\n        added but may mask failures in tests for key insertion when using tests who's images have baked in passwords for\n        login access(tbd).\n        Upon success returns a paramiko sshclient with an established connection.\n\n        :param hostname: - mandatory - hostname or ip to establish ssh connection with\n        :param username: - optional - username used to authenticate ssh session\n        :param password: - optional - password used to authenticate ssh session\n        :param keypath: - optional - full path to sshkey file used to authenticate ssh session\n        :param proxy: - optional - host to proxy ssh connection through\n        :param proxy_username:  - optional ssh username of proxy host for authentication\n        :param proxy_password: - optional ssh password of proxy host for authentication\n        :param proxy_keypath: - optional path to ssh key to use for proxy authentication\n        :param timeout: - optional - tcp timeout\n        :param enable_ipv6_dns: - optional - boolean to avoid ipv6 dns 'AAAA' lookups\n        :param retry: - optional - Number of attempts to establish ssh connection for errors outside of authentication\n        :param port: - optional - port to connect to, default 22\n        :param verbose: - optional - enable verbose debug output\n        "
    connected = False
    iplist = []
    ip = None
    if (use_pub_keys is None):
        use_pub_keys = self.use_pub_keys
    proxy_ip = None
    if ((not use_pub_keys) and (password is None) and (keypath is None)):
        raise Exception('ssh_connect: both password and keypath were set to None')
    if (enable_ipv6_dns is None):
        enable_ipv6_dns = self.enable_ipv6_dns
    proxy = (proxy or self.proxy)
    self.debug(((((((((((((((((('ssh_connect args:\nhostname:' + hostname) + '\nusername:') + username) + '\npassword:') + str(password)) + '\nkeypath:') + str(keypath)) + '\nproxy_username:') + str(proxy_username)) + '\nproxy_password') + str(proxy_password)) + '\nproxy_keypath') + str(proxy_keypath)) + '\ntimeout:') + str(timeout)) + '\nretry:') + str(retry)), verbose=verbose)
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    hostname = str(hostname.strip())
    if (not enable_ipv6_dns):
        self.debug('IPV6 DNS lookup disabled, do IPV4 resolution and pass IP to connect()', verbose=verbose)
        iplist = self.get_ipv4_lookup(hostname, verbose=verbose)
    if (not iplist):
        iplist = [hostname]
    attempt = 0
    retry += 1
    while ((attempt < retry) and (not connected)):
        attempt += 1
        proxy_transport = None
        for ip in iplist:
            if self.proxy:
                if (not enable_ipv6_dns):
                    proxy_ip = self.get_ipv4_lookup(self.proxy, verbose=verbose)[0]
                    proxy_transport = self.get_proxy_transport(proxy_host=proxy, dest_host=ip, port=port, proxy_username=proxy_username, proxy_password=proxy_password, proxy_keypath=proxy_keypath)
            if proxy_transport:
                ssh._transport = proxy_transport
            else:
                ssh._transport = paramiko.Transport(ip)
            ssh._transport.start_client()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            try:
                self.debug((((((((((((('SSH connection attempt(' + str(attempt)) + ' of ') + str(retry)) + "), host:'") + username) + '@') + hostname) + "', using ipv4:") + str(ip)) + ", thru proxy:'") + str(proxy_ip)) + "'"))
                if ((keypath is None) and password):
                    self.debug(((('Using username:' + username) + ' and password:') + str(self.mask_password(password))), verbose=verbose)
                    ssh._transport.auth_password(username, password)
                    connected = True
                    break
                elif keypath:
                    self.debug(('Using Keypath:' + keypath), verbose=verbose)
                    priv_key = paramiko.RSAKey.from_private_key_file(keypath)
                    ssh._transport.auth_publickey(username, priv_key)
                    connected = True
                    break
                else:
                    priv_key_files = []
                    if (self.priv_key_file and os.path.isfile(self.priv_key_file)):
                        priv_key_files.append(self.priv_key_file)
                    self.debug(('Using local keys, no keypath/password provided, trying:' + str((self.priv_key_file or ''))), verbose=verbose)
                    ssh._auth(username, password, None, priv_key_files, True, True)
                    connected = True
            except paramiko.ssh_exception.SSHException as se:
                self.debug(((('Failed to connect to ' + hostname) + ', retry in 10 seconds. Err:') + str(se)))
                time.sleep(10)
                pass
        if connected:
            via_string = ''
            if proxy_transport:
                (proxy_host, port) = ssh._transport.getpeername()
                via_string = (((' via proxy host:' + str(proxy_host)) + ':') + str(port))
            self.debug((('SSH - Connected to ' + str(ip)) + str(via_string)))
            break
    if (not connected):
        raise Exception(((((('Failed to connect to "' + str(hostname)) + '", attempts:') + str(attempt)) + '. IPs tried:') + ','.join(iplist)))
    return ssh
