{
  if (Bootstrap.isFinished() && Topology.isEnabledLocally(LoadBalancingBackend.class) && Topology.isEnabled(AutoScaling.class)&& Topology.isEnabled(Eucalyptus.class)) {
    List<LoadBalancerAutoScalingGroup> groups=Lists.newArrayList();
    Map<String,LoadBalancerAutoScalingGroup> allGroupMap=new ConcurrentHashMap<>();
    try (final TransactionResource db=Entities.transactionFor(LoadBalancerAutoScalingGroup.class)){
      groups=Entities.query(LoadBalancerAutoScalingGroup.named(),true);
      db.commit();
      for (      LoadBalancerAutoScalingGroup g : groups) {
        allGroupMap.put(g.getName(),g);
      }
    }
 catch (    Exception ex) {
    }
    Map<String,LoadBalancerAutoScalingGroup> groupToQuery=new ConcurrentHashMap<>();
    final Date current=new Date(System.currentTimeMillis());
    for (    final LoadBalancerAutoScalingGroup group : groups) {
      final Date lastUpdate=group.getLastUpdateTimestamp();
      int elapsedSec=(int)((current.getTime() - lastUpdate.getTime()) / 1000.0);
      if (elapsedSec > AUTOSCALE_GROUP_CHECK_INTERVAL_SEC) {
        try (final TransactionResource db=Entities.transactionFor(LoadBalancerAutoScalingGroup.class)){
          LoadBalancerAutoScalingGroup update=Entities.uniqueResult(group);
          update.setLastUpdateTimestamp(current);
          Entities.persist(update);
          db.commit();
        }
 catch (        Exception ex) {
        }
        groupToQuery.put(group.getName(),group);
      }
    }
    if (groupToQuery.size() <= 0)     return;
    List<AutoScalingGroupType> queriedGroups;
    try {
      DescribeAutoScalingGroupsResponseType response=EucalyptusActivityTasks.getInstance().describeAutoScalingGroups(Lists.newArrayList(groupToQuery.keySet()));
      DescribeAutoScalingGroupsResult result=response.getDescribeAutoScalingGroupsResult();
      AutoScalingGroupsType asgroups=result.getAutoScalingGroups();
      queriedGroups=asgroups.getMember();
    }
 catch (    Exception ex) {
      LOG.error("Failed to describe autoscaling groups",ex);
      return;
    }
    Map<String,LoadBalancerServoInstance> servoMap=new ConcurrentHashMap<>();
    try (final TransactionResource db=Entities.transactionFor(LoadBalancerServoInstance.class)){
      final List<LoadBalancerServoInstance> result=Entities.query(LoadBalancerServoInstance.named(),true);
      db.commit();
      for (      LoadBalancerServoInstance inst : result) {
        servoMap.put(inst.getInstanceId(),inst);
      }
    }
 catch (    Exception ex) {
    }
    final List<LoadBalancerServoInstance> newServos=Lists.newArrayList();
    final Map<String,Instance> foundInstances=new ConcurrentHashMap<>();
    for (    final AutoScalingGroupType asg : queriedGroups) {
      Instances instances=asg.getInstances();
      if (instances != null && instances.getMember() != null && instances.getMember().size() > 0) {
        for (        final Instance instance : instances.getMember()) {
          String instanceId=instance.getInstanceId();
          foundInstances.put(instanceId,instance);
          if (!servoMap.containsKey(instanceId)) {
            try {
              final LoadBalancerAutoScalingGroup group=allGroupMap.get(asg.getAutoScalingGroupName());
              if (group == null)               throw new IllegalArgumentException("The group with name " + asg.getAutoScalingGroupName() + " not found in the database");
              final LoadBalancerCoreView lbView=group.getLoadBalancer();
              LoadBalancer lb;
              try {
                lb=LoadBalancerEntityTransform.INSTANCE.apply(lbView);
              }
 catch (              final Exception ex) {
                LOG.error("unable to transfrom loadbalancer from the viewer",ex);
                throw ex;
              }
              LoadBalancerZoneCoreView zoneView=null;
              for (              final LoadBalancerZoneCoreView z : lb.getZones()) {
                if (z.getName().equals(instance.getAvailabilityZone())) {
                  zoneView=z;
                  break;
                }
              }
              if (zoneView == null)               throw new Exception("No availability zone with name=" + instance.getAvailabilityZone() + " found for loadbalancer "+ lb.getDisplayName());
              final LoadBalancerSecurityGroupCoreView sgroupView=lb.getGroup();
              if (sgroupView == null && lb.getVpcId() == null)               throw new Exception("No security group is found for loadbalancer " + lb.getDisplayName());
              final LoadBalancerDnsRecordCoreView dnsView=lb.getDns();
              LoadBalancerZone zone;
              LoadBalancerSecurityGroup sgroup;
              LoadBalancerDnsRecord dns;
              try {
                zone=LoadBalancerZoneEntityTransform.INSTANCE.apply(zoneView);
                sgroup=sgroupView == null ? null : LoadBalancerSecurityGroupEntityTransform.INSTANCE.apply(sgroupView);
                dns=LoadBalancerDnsRecordEntityTransform.INSTANCE.apply(dnsView);
              }
 catch (              final Exception ex) {
                LOG.error("unable to transform entity",ex);
                throw ex;
              }
              final LoadBalancerServoInstance newInstance=LoadBalancerServoInstance.newInstance(zone,sgroup,dns,group,instanceId);
              newServos.add(newInstance);
            }
 catch (            Exception ex) {
              LOG.error("Failed to construct new servo instance",ex);
            }
          }
        }
      }
    }
    if (newServos.size() > 0) {
      try (final TransactionResource db=Entities.transactionFor(LoadBalancerServoInstance.class)){
        for (        LoadBalancerServoInstance instance : newServos) {
          Entities.persist(instance);
        }
        db.commit();
      }
 catch (      Exception ex) {
        LOG.error("Failed to persist the servo instance record",ex);
      }
    }
    List<LoadBalancerServoInstanceCoreView> servoRecords=Lists.newArrayList();
    for (    String groupName : groupToQuery.keySet()) {
      final LoadBalancerAutoScalingGroup group=groupToQuery.get(groupName);
      servoRecords.addAll(group.getServos());
    }
    for (    LoadBalancerServoInstanceCoreView instanceView : servoRecords) {
      if (!foundInstances.containsKey(instanceView.getInstanceId()) && !instanceView.getState().equals(LoadBalancerServoInstance.STATE.Retired)) {
        LoadBalancerServoInstance instance;
        try {
          instance=LoadBalancerServoInstanceEntityTransform.INSTANCE.apply(instanceView);
        }
 catch (        final Exception ex) {
          LOG.error("unable to transform servo instance from the view",ex);
          continue;
        }
        try (final TransactionResource db=Entities.transactionFor(LoadBalancerServoInstance.class)){
          final LoadBalancerServoInstance update=Entities.uniqueResult(instance);
          update.setState(LoadBalancerServoInstance.STATE.Error);
          Entities.persist(update);
          db.commit();
        }
 catch (        Exception ex) {
        }
      }
 else {
        Instance instanceCurrent=foundInstances.get(instanceView.getInstanceId());
        final String healthState=instanceCurrent.getHealthStatus();
        final String lifecycleState=instanceCurrent.getLifecycleState();
        LoadBalancerServoInstance.STATE curState=instanceView.getState();
        LoadBalancerServoInstance.STATE newState=curState;
        if (healthState != null && !healthState.equals("Healthy")) {
          newState=LoadBalancerServoInstance.STATE.Error;
        }
 else         if (lifecycleState != null) {
switch (lifecycleState) {
case "Pending":
            newState=LoadBalancerServoInstance.STATE.Pending;
          break;
case "Quarantined":
        newState=LoadBalancerServoInstance.STATE.Error;
      break;
case "InService":
    newState=LoadBalancerServoInstance.STATE.InService;
  break;
case "Terminating":
case "Terminated":
newState=LoadBalancerServoInstance.STATE.OutOfService;
break;
}
}
if (!curState.equals(LoadBalancerServoInstance.STATE.Retired) && !curState.equals(newState)) {
LoadBalancerServoInstance instance;
try {
instance=LoadBalancerServoInstanceEntityTransform.INSTANCE.apply(instanceView);
}
 catch (final Exception ex) {
LOG.error("unable to transform servo instance from the view",ex);
continue;
}
try (final TransactionResource db=Entities.transactionFor(LoadBalancerServoInstance.class)){
final LoadBalancerServoInstance update=Entities.uniqueResult(instance);
update.setState(newState);
Entities.persist(update);
db.commit();
}
 catch (Exception ex) {
}
}
}
}
}
}
