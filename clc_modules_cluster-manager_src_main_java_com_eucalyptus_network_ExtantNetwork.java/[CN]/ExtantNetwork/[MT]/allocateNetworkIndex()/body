{
  if (!Entities.isPersistent(this)) {
    throw new TransientEntityException(this.toString());
  }
 else {
    try (final TransactionResource db=Entities.transactionFor(PrivateNetworkIndex.class)){
      final List<Long> networkIndexHolder=Lists.newArrayList();
      Entities.registerSynchronization(ExtantNetwork.class,new Synchronization(){
        @Override public void beforeCompletion(){
        }
        @Override public void afterCompletion(        final int status){
          clearInFlight(networkIndexHolder);
        }
      }
);
      for (      final Long i : Numbers.shuffled(NetworkGroups.networkIndexInterval())) {
        try {
          Entities.uniqueResult(PrivateNetworkIndex.named(this,i));
        }
 catch (        final NoSuchElementException ex) {
          if (ifNotInFlight(i))           try {
            networkIndexHolder.add(i);
            PrivateNetworkIndex netIdx=Entities.persist(PrivateNetworkIndex.create(this,i));
            PrivateNetworkIndex ref=netIdx.allocate();
            db.commit();
            return ref;
          }
 catch (          final Exception ex1) {
            Logs.exhaust().debug(ex1);
          }
        }
      }
      throw new NoSuchElementException();
    }
 catch (    Exception ex) {
      Logs.exhaust().error(ex,ex);
      throw new TransactionExecutionException("Too many instances running in security group '" + this.displayName + "', unable to allocate a private network "+ "index. Please either reduce the number of instances in the security group or use another security group.",ex);
    }
  }
}
