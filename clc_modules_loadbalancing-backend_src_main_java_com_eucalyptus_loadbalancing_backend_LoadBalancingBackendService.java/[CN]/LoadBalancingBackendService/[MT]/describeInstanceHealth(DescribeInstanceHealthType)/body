{
  final DescribeInstanceHealthResponseType reply=request.getReply();
  final Context ctx=Contexts.lookup();
  final String lbName=request.getLoadBalancerName();
  final Instances instances=request.getInstances();
  LoadBalancer lb;
  try {
    lb=lookupAuthorizedByNameOrDnsName(ctx.getAccountNumber(),lbName);
  }
 catch (  final LoadBalancingException e) {
    throw e;
  }
catch (  Exception ex) {
    throw new InternalFailureException("Failed to find the loadbalancer");
  }
  List<LoadBalancerBackendInstanceCoreView> lbInstances=Lists.newArrayList(lb.getBackendInstances());
  List<LoadBalancerBackendInstanceCoreView> instancesFound;
  List<LoadBalancerBackendInstanceCoreView> stateOutdated=Lists.newArrayList();
  int healthyTimeoutSec=lb.getHealthCheckInterval() * lb.getHealthyThreshold();
  final int UPDATE_INTERVAL=Integer.parseInt(LoadBalancingServoCache.BACKEND_INSTANCE_UPDATE_INTERVAL);
  healthyTimeoutSec=Math.max(3 * healthyTimeoutSec,3 * UPDATE_INTERVAL);
  long currentTime=System.currentTimeMillis();
  if (instances != null && instances.getMember() != null && instances.getMember().size() > 0) {
    instancesFound=Lists.newArrayList();
    for (    Instance inst : instances.getMember()) {
      String instId=inst.getInstanceId();
      for (      final LoadBalancerBackendInstanceCoreView lbInstance : lbInstances) {
        if (instId.equals(lbInstance.getInstanceId())) {
          instancesFound.add(lbInstance);
          break;
        }
      }
    }
  }
 else {
    instancesFound=Lists.newArrayList(lb.getBackendInstances());
  }
  final ArrayList<InstanceState> stateList=Lists.newArrayList();
  for (  final LoadBalancerBackendInstanceCoreView instance : instancesFound) {
    boolean outdated=false;
    Date lastUpdated;
    if ((lastUpdated=instance.instanceStateLastUpdated()) != null) {
      final int diffSec=(int)((currentTime - lastUpdated.getTime()) / 1000.0);
      if (LoadBalancerBackendInstance.STATE.InService.equals(instance.getState()) && diffSec > healthyTimeoutSec) {
        stateOutdated.add(instance);
        outdated=true;
      }
    }
    InstanceState state=new InstanceState();
    state.setInstanceId(instance.getDisplayName());
    if (outdated) {
      state.setState(LoadBalancerBackendInstance.STATE.OutOfService.toString());
      state.setReasonCode("ELB");
      state.setDescription("Internal error: instance health not updated for extended period of time");
    }
 else {
      state.setState(instance.getState().name());
      if (instance.getState().equals(LoadBalancerBackendInstance.STATE.OutOfService) && instance.getReasonCode() != null)       state.setReasonCode(instance.getReasonCode());
      if (instance.getDescription() != null)       state.setDescription(instance.getDescription());
    }
    stateList.add(state);
  }
  if (!stateOutdated.isEmpty()) {
    try (TransactionResource db=Entities.transactionFor(LoadBalancerBackendInstance.class)){
      for (      final LoadBalancerBackendInstanceCoreView instanceView : stateOutdated) {
        final LoadBalancerBackendInstance sample=LoadBalancerBackendInstanceEntityTransform.INSTANCE.apply(instanceView);
        final LoadBalancerBackendInstance update=Entities.uniqueResult(sample);
        update.setState(LoadBalancerBackendInstance.STATE.OutOfService);
        update.setReasonCode("ELB");
        update.setDescription("Internal error: instance health not updated for extended period of time");
        Entities.persist(update);
      }
      db.commit();
    }
 catch (    final Exception ex) {
    }
 finally {
      if (lb != null)       LoadBalancingServoCache.getInstance().invalidate(lb);
    }
  }
  final InstanceStates states=new InstanceStates();
  states.setMember(stateList);
  final DescribeInstanceHealthResult result=new DescribeInstanceHealthResult();
  result.setInstanceStates(states);
  reply.setDescribeInstanceHealthResult(result);
  return reply;
}
