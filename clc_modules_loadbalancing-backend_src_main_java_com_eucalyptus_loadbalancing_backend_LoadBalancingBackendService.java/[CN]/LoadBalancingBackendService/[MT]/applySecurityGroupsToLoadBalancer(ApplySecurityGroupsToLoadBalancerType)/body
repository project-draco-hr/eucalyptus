{
  final ApplySecurityGroupsToLoadBalancerResponseType reply=request.getReply();
  final Context ctx=Contexts.lookup();
  final String accountNumber=ctx.getAccountNumber();
  final Set<String> securityGroupIds=Sets.newHashSet(request.getSecurityGroups().getMember());
  final List<SecurityGroupItemType> groups=EucalyptusActivityTasks.getInstance().describeUserSecurityGroupsById(ctx.getAccount(),null,securityGroupIds);
  if (groups.size() != securityGroupIds.size()) {
    throw new LoadBalancingBackendClientException("InvalidSecurityGroup","Invalid security group(s)");
  }
  final Function<String,ApplySecurityGroupsEvent> updateSecurityGroups=new Function<String,ApplySecurityGroupsEvent>(){
    @Override public ApplySecurityGroupsEvent apply(    final String identifier){
      try {
        final LoadBalancer example=LoadBalancer.namedByAccountId(accountNumber,identifier);
        final LoadBalancer loadBalancer=Entities.uniqueResult(example);
        if (RestrictedTypes.filterPrivileged().apply(loadBalancer)) {
          if (loadBalancer.getVpcId() == null) {
            throw Exceptions.toUndeclared(new InvalidConfigurationRequestException("VPC only"));
          }
          for (          final SecurityGroupItemType group : groups) {
            if (!loadBalancer.getVpcId().equals(group.getVpcId()))             throw Exceptions.toUndeclared(new InvalidConfigurationRequestException(String.format("Security group \"%s\" does not belong to VPC \"%s\"",group.getGroupId(),loadBalancer.getVpcId())));
          }
          final List<SecurityGroupItemType> sortedGroups=Ordering.natural().onResultOf(SecurityGroupItemType.groupId()).sortedCopy(groups);
          loadBalancer.setSecurityGroupRefs(Lists.newArrayList(Iterables.transform(sortedGroups,TypeMappers.lookup(SecurityGroupItemType.class,LoadBalancerSecurityGroupRef.class))));
          final ApplySecurityGroupsEvent evt=new ApplySecurityGroupsEvent();
          evt.setContext(ctx);
          evt.setLoadBalancerAccountNumber(loadBalancer.getOwnerAccountNumber());
          evt.setLoadBalancer(loadBalancer.getDisplayName());
          evt.setSecurityGroupIdsToNames(CollectionUtils.putAll(sortedGroups,Maps.<String,String>newLinkedHashMap(),SecurityGroupItemType.groupId(),SecurityGroupItemType.groupName()));
          return evt;
        }
 else {
          throw new NoSuchElementException();
        }
      }
 catch (      NoSuchElementException e) {
        throw Exceptions.toUndeclared(new AccessPointNotFoundException());
      }
catch (      TransactionException e) {
        throw Exceptions.toUndeclared(e);
      }
    }
  }
;
  final ApplySecurityGroupsEvent event;
  try {
    event=Entities.asTransaction(LoadBalancer.class,updateSecurityGroups).apply(request.getLoadBalancerName());
  }
 catch (  Exception e) {
    throw handleException(e);
  }
  try {
    ActivityManager.getInstance().fire(event);
  }
 catch (  final EventFailedException e) {
    LOG.error("Failed to handle new apply security groups event",e);
    final String reason=Optional.fromNullable(e.getCause()).transform(Exceptions.message()).or("internal error");
    throw new InternalFailure400Exception(String.format("Failed to apply security groups to loadbalancer: %s",reason),e);
  }
  reply.getApplySecurityGroupsToLoadBalancerResult().setSecurityGroups(new SecurityGroups(Collections2.transform(groups,SecurityGroupItemType.groupId())));
  return reply;
}
