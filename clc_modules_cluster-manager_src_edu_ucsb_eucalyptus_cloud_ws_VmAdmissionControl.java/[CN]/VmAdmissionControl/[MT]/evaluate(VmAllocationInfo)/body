{
  SLAs sla=new SLAs();
  List<ResourceToken> allocTokeList=null;
  boolean failed=false;
  try {
    allocTokeList=sla.doVmAllocation(vmAllocInfo);
    int addrCount=0;
    for (    ResourceToken token : allocTokeList) {
      addrCount+=token.getAmount();
    }
    if ("public".equals(vmAllocInfo.getRequest().getAddressingType())) {
      NavigableSet<String> addresses=AddressManager.allocateAddresses(addrCount);
      for (      ResourceToken token : allocTokeList) {
        for (int i=0; i < token.getAmount(); i++) {
          token.getAddresses().add(addresses.pollFirst());
        }
      }
    }
    vmAllocInfo.getAllocationTokens().addAll(allocTokeList);
    sla.doNetworkAllocation(vmAllocInfo.getRequest().getUserId(),vmAllocInfo.getAllocationTokens(),vmAllocInfo.getNetworks());
  }
 catch (  FailScriptFailException e) {
    failed=true;
  }
catch (  NotEnoughResourcesAvailable notEnoughResourcesAvailable) {
    failed=true;
  }
  if (failed) {
    if (allocTokeList != null)     for (    ResourceToken token : allocTokeList)     Clusters.getInstance().lookup(token.getCluster()).getNodeState().releaseToken(token);
    throw new EucalyptusCloudException("Not enough resources available.");
  }
  return vmAllocInfo;
}
