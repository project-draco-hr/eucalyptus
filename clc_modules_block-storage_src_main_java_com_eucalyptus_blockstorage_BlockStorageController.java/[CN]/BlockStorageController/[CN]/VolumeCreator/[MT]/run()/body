{
  boolean success=true;
  if (snapshotId != null) {
    try (TransactionResource tran=Entities.transactionFor(SnapshotInfo.class)){
      SnapshotInfo snapshotInfo=new SnapshotInfo(snapshotId);
      List<SnapshotInfo> foundSnapshotInfos=Entities.query(snapshotInfo);
      if (foundSnapshotInfos.size() == 0) {
        tran.commit();
        EucaSemaphore semaphore=EucaSemaphoreDirectory.getSolitarySemaphore(snapshotId);
        try (TransactionResource tran2=Entities.transactionFor(SnapshotInfo.class)){
          semaphore.acquire();
          foundSnapshotInfos=Entities.query(snapshotInfo);
          if (foundSnapshotInfos.size() == 0) {
            SnapshotInfo firstSnap=null;
            snapshotInfo.setScName(null);
            Criteria snapCriteria=Entities.createCriteria(SnapshotInfo.class);
            snapCriteria.add(Example.create(snapshotInfo));
            snapCriteria.addOrder(Order.asc("creationTimestamp"));
            foundSnapshotInfos=(List<SnapshotInfo>)snapCriteria.list();
            tran2.commit();
            if (foundSnapshotInfos != null && foundSnapshotInfos.size() > 0) {
              firstSnap=foundSnapshotInfos.get(0);
            }
 else {
              throw new EucalyptusCloudException("No record of snapshot " + snapshotId + " on any SC");
            }
            if (firstSnap.getSizeGb() == null || firstSnap.getSizeGb() <= 0) {
              throw new EucalyptusCloudException("Snapshot size for " + snapshotId + " is unknown. Cannot prep snapshot holder on the storage backend");
            }
            if (!blockManager.getFromBackend(snapshotId,firstSnap.getSizeGb())) {
              String bucket=null;
              String key=null;
              if (StringUtils.isBlank(firstSnap.getSnapshotLocation())) {
                throw new EucalyptusCloudException("Snapshot location (bucket, key) for " + snapshotId + " is unknown. Cannot download snapshot from objectstorage.");
              }
              String[] names=SnapshotInfo.getSnapshotBucketKeyNames(firstSnap.getSnapshotLocation());
              bucket=names[0];
              key=names[1];
              if (StringUtils.isBlank(bucket) || StringUtils.isBlank(key)) {
                throw new EucalyptusCloudException("Failed to parse bucket and key information for downloading " + snapshotId + ". Cannot download snapshot from objectstorage.");
              }
              String tmpSnapshotFileName=null;
              try {
                tmpSnapshotFileName=getSnapshot(bucket,key);
                File snapFile=new File(tmpSnapshotFileName);
                if (!snapFile.exists()) {
                  throw new EucalyptusCloudException("Unable to find snapshot " + snapshotId + "on SC");
                }
                long actualSnapSizeInMB=(long)Math.ceil((double)snapFile.length() / StorageProperties.MB);
                try {
                  String snapDestination=blockManager.prepareSnapshot(snapshotId,firstSnap.getSizeGb(),actualSnapSizeInMB);
                  if (snapDestination != null) {
                    if (snapDestination.startsWith("/dev/")) {
                      CommandOutput output=SystemUtil.runWithRawOutput(new String[]{StorageProperties.EUCA_ROOT_WRAPPER,"dd","if=" + tmpSnapshotFileName,"of=" + snapDestination,"bs=" + StorageProperties.blockSize});
                      LOG.debug("Output of dd command: " + output.error);
                      if (output.returnValue != 0) {
                        throw new EucalyptusCloudException("Failed to copy the snapshot to the right location due to: " + output.error);
                      }
                      cleanupFile(tmpSnapshotFileName);
                    }
 else {
                      if (!snapFile.renameTo(new File(snapDestination))) {
                        throw new EucalyptusCloudException("Failed to rename the snapshot");
                      }
                    }
                    blockManager.finishVolume(snapshotId);
                  }
 else {
                    LOG.warn("Block Manager replied that " + snapshotId + " not on backend, but snapshot preparation indicated that the snapshot is already present");
                  }
                }
 catch (                Exception ex) {
                  LOG.error("Failed to prepare the snapshot " + snapshotId + " on SAN. Now cleaning up (snapshot on SAN)",ex);
                  cleanFailedSnapshot(snapshotId);
                  throw ex;
                }
              }
 catch (              Exception ex) {
                LOG.error("Failed to prepare the snapshot " + snapshotId + " on the storage backend. Now cleaning up (snapshot on SC)",ex);
                cleanupFile(tmpSnapshotFileName);
                throw ex;
              }
            }
 else {
            }
            try (TransactionResource tran3=Entities.transactionFor(SnapshotInfo.class)){
              snapshotInfo=copySnapshotInfo(firstSnap);
              snapshotInfo.setProgress("100");
              snapshotInfo.setStartTime(new Date());
              snapshotInfo.setStatus(StorageProperties.Status.available.toString());
              Entities.persist(snapshotInfo);
              tran3.commit();
            }
           }
 else {
            SnapshotInfo foundSnapshotInfo=foundSnapshotInfos.get(0);
            if (!StorageProperties.Status.available.toString().equals(foundSnapshotInfo.getStatus())) {
              success=false;
              tran.rollback();
              LOG.warn("snapshot " + foundSnapshotInfo.getSnapshotId() + " not available.");
            }
 else {
              tran.commit();
            }
          }
        }
 catch (        InterruptedException ex) {
          throw new EucalyptusCloudException("semaphore could not be acquired");
        }
 finally {
          try {
            semaphore.release();
          }
  finally {
            EucaSemaphoreDirectory.removeSemaphore(snapshotId);
          }
        }
        size=blockManager.createVolume(volumeId,snapshotId,size);
      }
 else {
        SnapshotInfo foundSnapshotInfo=foundSnapshotInfos.get(0);
        if (!StorageProperties.Status.available.toString().equals(foundSnapshotInfo.getStatus())) {
          success=false;
          tran.rollback();
          LOG.warn("snapshot " + foundSnapshotInfo.getSnapshotId() + " not available.");
        }
 else {
          tran.commit();
          size=blockManager.createVolume(volumeId,snapshotId,size);
        }
      }
    }
 catch (    Exception ex) {
      success=false;
      LOG.error(ex);
    }
  }
 else {
    try {
      if (parentVolumeId != null) {
        blockManager.cloneVolume(volumeId,parentVolumeId);
      }
 else {
        blockManager.createVolume(volumeId,size);
      }
    }
 catch (    Exception ex) {
      success=false;
      LOG.error(ex,ex);
    }
  }
  VolumeInfo volumeInfo=new VolumeInfo(volumeId);
  try (TransactionResource tran4=Entities.transactionFor(VolumeInfo.class)){
    VolumeInfo foundVolumeInfo=Entities.uniqueResult(volumeInfo);
    if (foundVolumeInfo != null) {
      if (success) {
        if (StorageProperties.shouldEnforceUsageLimits) {
          int totalVolumeSize=0;
          VolumeInfo volInfo=new VolumeInfo();
          volInfo.setStatus(StorageProperties.Status.available.toString());
          List<VolumeInfo> volInfos=Entities.query(volInfo);
          for (          VolumeInfo vInfo : volInfos) {
            totalVolumeSize+=vInfo.getSize();
          }
          if ((totalVolumeSize + size) > StorageInfo.getStorageInfo().getMaxTotalVolumeSizeInGb() || (size > StorageInfo.getStorageInfo().getMaxVolumeSizeInGB())) {
            LOG.error("Max Total Volume size limit exceeded creating " + volumeId + ". Removing volume and cancelling operation");
            tran4.commit();
            checker.cleanFailedVolume(volumeId);
            return;
          }
        }
        foundVolumeInfo.setStatus(StorageProperties.Status.available.toString());
      }
 else {
        foundVolumeInfo.setStatus(StorageProperties.Status.failed.toString());
      }
      if (snapshotId != null) {
        foundVolumeInfo.setSize(size);
      }
    }
 else {
      throw new EucalyptusCloudException();
    }
    tran4.commit();
  }
 catch (  NoSuchElementException ne) {
    LOG.error("VolumeInfo entity for volume id " + volumeId + " was not found in the database");
  }
catch (  TransactionException|EucalyptusCloudException ex) {
    LOG.error(ex);
  }
}
