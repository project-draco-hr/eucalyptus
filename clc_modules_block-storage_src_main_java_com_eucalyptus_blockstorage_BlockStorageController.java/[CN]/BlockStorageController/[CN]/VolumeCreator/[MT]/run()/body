{
  boolean success=true;
  if (snapshotId != null) {
    EntityWrapper<SnapshotInfo> db=StorageProperties.getEntityWrapper();
    try {
      SnapshotInfo snapshotInfo=new SnapshotInfo(snapshotId);
      List<SnapshotInfo> foundSnapshotInfos=db.query(snapshotInfo);
      if (foundSnapshotInfos.size() == 0) {
        db.commit();
        EucaSemaphore semaphore=EucaSemaphoreDirectory.getSolitarySemaphore(snapshotId);
        try {
          semaphore.acquire();
          db=StorageProperties.getEntityWrapper();
          foundSnapshotInfos=db.query(snapshotInfo);
          if (foundSnapshotInfos.size() == 0) {
            int snapSizeGb=0;
            String snapshotLocation=null;
            String bucket=null;
            String key=null;
            snapshotInfo.setScName(null);
            List<SnapshotInfo> otherSnapshotInfos=db.query(snapshotInfo);
            if (otherSnapshotInfos != null && otherSnapshotInfos.size() > 0) {
              for (              SnapshotInfo otherSnap : otherSnapshotInfos) {
                if (StringUtils.isBlank(snapshotLocation)) {
                  snapshotLocation=otherSnap.getSnapshotLocation();
                }
                if (otherSnap.getSizeGb() != null && otherSnap.getSizeGb() > 0) {
                  snapSizeGb=otherSnap.getSizeGb();
                }
                if (StringUtils.isNotBlank(snapshotLocation) && snapSizeGb > 0) {
                  break;
                }
 else {
                  continue;
                }
              }
            }
            db.commit();
            if (snapSizeGb <= 0) {
              if (StringUtils.isBlank(snapshotLocation)) {
                throw new EucalyptusCloudException("Cannot fetch the size of snapshot from objectstorage as the location (bucket and key) is unknown for " + snapshotId);
              }
              String[] names=SnapshotInfo.getSnapshotBucketKeyNames(snapshotLocation);
              bucket=names[0];
              key=names[1];
              snapSizeGb=getSnapshotSize(bucket,key);
              if (snapSizeGb <= 0) {
                throw new EucalyptusCloudException("Size of snapshot " + snapshotId + " fetched from objectstorage: "+ snapSizeGb+ ". Cannot prep snapshot holder on the storage backend");
              }
            }
            if (!blockManager.getFromBackend(snapshotId,snapSizeGb)) {
              if (StringUtils.isBlank(bucket) || StringUtils.isBlank(key)) {
                String[] names=SnapshotInfo.getSnapshotBucketKeyNames(snapshotLocation);
                bucket=names[0];
                key=names[1];
                if (StringUtils.isBlank(bucket) || StringUtils.isBlank(key)) {
                  throw new EucalyptusCloudException("Snapshot location (bucket and or key) is unknown for " + snapshotId + ". Cannot download snapshot");
                }
              }
              String tmpSnapshotFileName=null;
              try {
                tmpSnapshotFileName=getSnapshot(bucket,key);
                File snapFile=new File(tmpSnapshotFileName);
                if (!snapFile.exists()) {
                  throw new EucalyptusCloudException("Unable to find snapshot " + snapshotId + "on SC");
                }
                long actualSnapSizeInMB=(long)Math.ceil((double)snapFile.length() / StorageProperties.MB);
                try {
                  String snapDestination=blockManager.prepareSnapshot(snapshotId,snapSizeGb,actualSnapSizeInMB);
                  if (snapDestination != null) {
                    if (snapDestination.startsWith("/dev/")) {
                      CommandOutput output=SystemUtil.runWithRawOutput(new String[]{StorageProperties.EUCA_ROOT_WRAPPER,"dd","if=" + tmpSnapshotFileName,"of=" + snapDestination,"bs=" + StorageProperties.blockSize});
                      LOG.debug("Output of dd command: " + output.error);
                      if (output.returnValue != 0) {
                        throw new EucalyptusCloudException("Failed to copy the snapshot to the right location due to: " + output.error);
                      }
                      cleanupFile(tmpSnapshotFileName);
                    }
 else {
                      if (!snapFile.renameTo(new File(snapDestination))) {
                        throw new EucalyptusCloudException("Failed to rename the snapshot");
                      }
                    }
                    blockManager.finishVolume(snapshotId);
                  }
 else {
                    LOG.warn("Block Manager replied that " + snapshotId + " not on backend, but snapshot preparation indicated that the snapshot is already present");
                  }
                }
 catch (                Exception ex) {
                  LOG.error("Failed to prepare the snapshot " + snapshotId + " on SAN. Now cleaning up (snapshot on SAN)",ex);
                  cleanFailedSnapshot(snapshotId);
                  throw ex;
                }
              }
 catch (              Exception ex) {
                LOG.error("Failed to prepare the snapshot " + snapshotId + " on the storage backend. Now cleaning up (snapshot on SC)",ex);
                cleanupFile(tmpSnapshotFileName);
                throw ex;
              }
            }
 else {
            }
            db=StorageProperties.getEntityWrapper();
            snapshotInfo=new SnapshotInfo(snapshotId);
            snapshotInfo.setProgress("100");
            snapshotInfo.setStartTime(new Date());
            snapshotInfo.setSizeGb(snapSizeGb);
            snapshotInfo.setSnapshotLocation(snapshotLocation);
            snapshotInfo.setStatus(StorageProperties.Status.available.toString());
            db.add(snapshotInfo);
            db.commit();
          }
 else {
            SnapshotInfo foundSnapshotInfo=foundSnapshotInfos.get(0);
            if (!StorageProperties.Status.available.toString().equals(foundSnapshotInfo.getStatus())) {
              success=false;
              db.rollback();
              LOG.warn("snapshot " + foundSnapshotInfo.getSnapshotId() + " not available.");
            }
 else {
              db.commit();
            }
          }
        }
 catch (        InterruptedException ex) {
          throw new EucalyptusCloudException("semaphore could not be acquired");
        }
 finally {
          try {
            semaphore.release();
          }
  finally {
            EucaSemaphoreDirectory.removeSemaphore(snapshotId);
          }
        }
        size=blockManager.createVolume(volumeId,snapshotId,size);
      }
 else {
        SnapshotInfo foundSnapshotInfo=foundSnapshotInfos.get(0);
        if (!StorageProperties.Status.available.toString().equals(foundSnapshotInfo.getStatus())) {
          success=false;
          db.rollback();
          LOG.warn("snapshot " + foundSnapshotInfo.getSnapshotId() + " not available.");
        }
 else {
          db.commit();
          size=blockManager.createVolume(volumeId,snapshotId,size);
        }
      }
    }
 catch (    Exception ex) {
      success=false;
      LOG.error(ex);
    }
  }
 else {
    try {
      if (parentVolumeId != null) {
        blockManager.cloneVolume(volumeId,parentVolumeId);
      }
 else {
        blockManager.createVolume(volumeId,size);
      }
    }
 catch (    Exception ex) {
      success=false;
      LOG.error(ex,ex);
    }
  }
  EntityWrapper<VolumeInfo> db=StorageProperties.getEntityWrapper();
  VolumeInfo volumeInfo=new VolumeInfo(volumeId);
  try {
    VolumeInfo foundVolumeInfo=db.getUnique(volumeInfo);
    if (foundVolumeInfo != null) {
      if (success) {
        if (StorageProperties.shouldEnforceUsageLimits) {
          int totalVolumeSize=0;
          VolumeInfo volInfo=new VolumeInfo();
          volInfo.setStatus(StorageProperties.Status.available.toString());
          List<VolumeInfo> volInfos=db.query(volInfo);
          for (          VolumeInfo vInfo : volInfos) {
            totalVolumeSize+=vInfo.getSize();
          }
          if ((totalVolumeSize + size) > StorageInfo.getStorageInfo().getMaxTotalVolumeSizeInGb() || (size > StorageInfo.getStorageInfo().getMaxVolumeSizeInGB())) {
            LOG.error("Max Total Volume size limit exceeded creating " + volumeId + ". Removing volume and cancelling operation");
            db.commit();
            checker.cleanFailedVolume(volumeId);
            return;
          }
        }
        foundVolumeInfo.setStatus(StorageProperties.Status.available.toString());
      }
 else {
        foundVolumeInfo.setStatus(StorageProperties.Status.failed.toString());
      }
      if (snapshotId != null) {
        foundVolumeInfo.setSize(size);
      }
    }
 else {
      throw new EucalyptusCloudException();
    }
    db.commit();
  }
 catch (  EucalyptusCloudException ex) {
    db.rollback();
    LOG.error(ex);
  }
}
