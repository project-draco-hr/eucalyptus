{
  VmState vmLastState=vm.getLastState();
  VmState vmState=vm.getState();
  RuntimeException logEx=new RuntimeException("Cleaning up instance: " + vm.getInstanceId() + " "+ vmLastState+ " -> "+ vmState);
  LOG.debug(logEx.getMessage());
  Logs.extreme().info(logEx,logEx);
  try {
    if (NetworkGroups.networkingConfiguration().hasNetworking()) {
      try {
        Address address=Addresses.getInstance().lookup(vm.getPublicAddress());
        if ((address.isAssigned() && vm.getInstanceId().equals(address.getInstanceId())) || VmState.PENDING.equals(vmLastState)) {
          if (address.isSystemOwned()) {
            EventRecord.caller(VmInstances.class,EventType.VM_TERMINATING,"SYSTEM_ADDRESS",address.toString()).debug();
          }
 else {
            EventRecord.caller(VmInstances.class,EventType.VM_TERMINATING,"USER_ADDRESS",address.toString()).debug();
          }
          AsyncRequests.newRequest(address.unassign().getCallback()).dispatch(vm.getPartition());
        }
      }
 catch (      final NoSuchElementException e) {
        if (VmState.PENDING.equals(vmLastState)) {
          for (          Address addr : Addresses.getInstance().listValues()) {
            if (addr.getInstanceId().equals(vm.getInstanceId())) {
              AsyncRequests.newRequest(addr.unassign().getCallback()).dispatch(vm.getPartition());
              break;
            }
          }
        }
      }
catch (      final Exception e1) {
        LOG.debug(e1,e1);
      }
    }
  }
 catch (  final Exception e) {
    LOG.error(e);
    Logs.extreme().error(e,e);
  }
  try {
    VmInstances.cleanUpAttachedVolumes(vm);
  }
 catch (  Exception ex) {
    LOG.error(ex);
    Logs.extreme().error(ex,ex);
  }
  try {
    AsyncRequests.newRequest(new TerminateCallback(vm.getInstanceId())).dispatch(vm.getPartition());
  }
 catch (  Exception ex) {
    LOG.error(ex);
    Logs.extreme().error(ex,ex);
  }
}
