{
  boolean wasPending=address.isPending();
  if (wasPending)   try {
    address.clearPending();
  }
 catch (  IllegalStateException e) {
    wasPending=false;
  }
  RemoteCallback<?,?> callback=address.unassign().getCallback();
  Callback.Failure failureHander;
  if (rollbackNetworkingOnFailure && !wasPending && !VmState.TERMINATED.apply(vm)) {
    callback=DelegatingRemoteCallback.suppressException(callback);
    failureHander=new Callback.Failure<java.lang.Object>(){
      @Override public void fireException(      final Throwable t){
        LOG.info("Unable to assign address " + address.getName() + " for "+ vm.getInstanceId()+ ", will retry.");
        if (address.isPending()) {
          try {
            address.clearPending();
          }
 catch (          Exception ex) {
          }
        }
        try {
          if (!address.isAllocated()) {
            address.pendingAssignment();
          }
          address.assign(vm).clearPending();
        }
 catch (        Exception e) {
          LOG.error(e,e);
          LOG.warn("Address potentially in an inconsistent state: " + LogUtil.dumpObject(address));
        }
      }
    }
;
  }
 else {
    failureHander=Callbacks.noopFailure();
  }
  AddressingDispatcher.dispatch(AsyncRequests.newRequest(callback).then(failureHander),vm.getPartition());
}
