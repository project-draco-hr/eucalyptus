{
  try {
    final String instanceId=addr.getInstanceId();
    if (addr.isReallyAssigned()) {
      boolean unassign=false;
      final boolean wasSystem=addr.isSystemOwned();
      final String wasOwnerUserId=addr.getOwnerUserId();
      try {
        final VmInstance vm=VmInstances.lookup(instanceId);
        final String vmIp=Objects.firstNonNull(vm.getPublicAddress(),UNASSIGNED_INSTANCEADDR);
        if (VmStateSet.RUN.apply(vm)) {
          AddressingDispatcher.dispatch(AsyncRequests.newRequest(addr.unassign().getCallback()).then(new UnconditionalCallback(){
            @Override public void fire(){
              try {
                if (!wasSystem || vmIp.equals(addr.getName())) {
                  Addresses.system(vm);
                }
              }
  finally {
                if (addr.isAllocated() && !addr.isAssigned() && wasOwnerUserId.equals(addr.getOwnerUserId()))                 try {
                  addr.release();
                }
 catch (                Exception e) {
                  LOG.error("Error releasing address after unassign",e);
                }
              }
            }
          }
),vm.getPartition());
        }
 else {
          unassign=true;
        }
      }
 catch (      NoSuchElementException e) {
        Logs.extreme().debug(e,e);
        unassign=true;
      }
      if (unassign) {
        addr.unassign().clearPending();
        addr.release();
      }
    }
 else {
      addr.release();
    }
  }
 catch (  final Exception e) {
    LOG.debug(e,e);
  }
}
