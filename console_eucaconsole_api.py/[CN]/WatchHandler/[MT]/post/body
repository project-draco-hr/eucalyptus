@tornado.web.asynchronous
def post(self):
    if (not self.authorized()):
        raise tornado.web.HTTPError(401, 'not authorized')
    if (not self.user_session.cw):
        if self.should_use_mock():
            self.user_session.cw = MockWatchInterface()
        else:
            host = eucaconsole.config.get('server', 'clchost')
            if self.user_session.host_override:
                host = self.user_session.host_override
            self.user_session.cw = BotoWatchInterface(host, self.user_session.access_key, self.user_session.secret_key, self.user_session.session_token)
        self.user_session.cw = CachingWatchInterface(self.user_session.cw, eucaconsole.config)
    self.user_session.session_lifetime_requests += 1
    try:
        action = self.get_argument('Action')
        if (action.find('Describe') == (-1)):
            self.user_session.session_last_used = time.time()
            self.check_xsrf_cookie()
        if (action == 'GetMetricStatistics'):
            period = self.get_argument('Period')
            start_time = datetime.strptime(self.get_argument('StartTime'), self.ISO_FORMAT)
            end_time = datetime.strptime(self.get_argument('EndTime'), self.ISO_FORMAT)
            metric_name = self.get_argument('MetricName')
            namespace = self.get_argument('Namespace')
            statistics = self.get_argument_list('Statistics.member')
            dimensions = self.get_argument_list('Dimensions.member')
            unit = self.get_argument('Unit')
            self.user_session.cw.get_metric_statistics(period, start_time, end_time, metric_name, namespace, statistics, dimensions, unit, self.callback)
        elif (action == 'ListMetrics'):
            dimensions = self.get_argument_list('Dimensions.member')
            metric_name = self.get_argument('MetricName', None)
            namespace = self.get_argument('Namespace', None)
            next_token = self.get_argument('NextToken', None)
            self.user_session.cw.list_metrics(next_token, dimensions, metric_name, namespace, self.callback)
        elif (action == 'PutMetricData'):
            namespace = self.get_argument('Namespace')
            data = []
            metric_name = self.get_argument('MetricData.member.1.MetricName')
            idx = 1
            while metric_name:
                value = self.get_argument(('MetricData.member.%d.Value' % idx), None)
                timestamp = self.get_argument(('MetricData.member.%d.Timestamp' % idx), None)
                unit = self.get_argument(('MetricData.member.%d.Unit' % idx), None)
                dimensions = self.get_argument(('MetricData.member.%d.Dimensions' % idx), None)
                statistics = self.get_argument(('MetricData.member.%d.StatisticValues' % idx), None)
                data.append({'name': name, 'value': value, 'timestamp': timestamp, 'unit': unit, 'dimensions': dimensions, 'statistics': statistics, })
                idx += 1
                metric_name = self.get_argument(('MetricData.member.%d.MetricName' % idx), None)
            self.user_session.cw.put_metric_data(namespace, data, self.callback)
        elif (action == 'DescribeAlarms'):
            action_prefix = self.get_argument('ActionPrefix', None)
            alarm_name_prefix = self.get_argument('AlarmNamePrefix', None)
            alarm_names = self.get_argument_list('AlarmNames.member')
            max_records = self.get_argument('MaxRecords', None)
            state_value = self.get_argument('StateValue', None)
            next_token = self.get_argument('NextToken', None)
            self.user_session.cw.describe_alarms(action_prefix, alarm_name_prefix, alarm_names, max_records, state_value, next_token, self.callback)
        elif (action == 'DeleteAlarms'):
            alarm_names = self.get_argument_list('AlarmNames.member')
            self.user_session.cw.delete_alarms(alarm_names, self.callback)
        elif (action == 'EnableAlarmActions'):
            alarm_names = self.get_argument_list('AlarmNames.member')
            self.user_session.cw.enable_alarm_actions(alarm_names, self.callback)
        elif (action == 'DisableAlarmActions'):
            alarm_names = self.get_argument_list('AlarmNames.member')
            self.user_session.cw.disable_alarm_actions(alarm_names, self.callback)
        elif (action == 'PutMetricAlarm'):
            actions_enabled = self.get_argument('ActionsEnabled', None)
            alarm_actions = self.get_argument_list('AlarmActions.member')
            alarm_desc = self.get_argument('AlarmDescription', None)
            alarm_name = self.get_argument('AlarmName')
            comparison_op = self.get_argument('ComparisonOperator')
            dimensions = self.get_argument_list('Dimensions.member')
            eval_periods = self.get_argument('EvaluationPeriods')
            insufficient_data_actions = self.get_argument_list('InsufficientDataActions.member')
            metric_name = self.get_argument('MetricName')
            namespace = self.get_argument('Namespace')
            ok_actions = self.get_argument_list('OKActions.member')
            period = self.get_argument('Period')
            statistic = self.get_argument('Statistic')
            threshold = self.get_argument('Threshold')
            unit = self.get_argument('Unit', None)
            if (comparison_op == 'GreaterThanOrEqualToThreshold'):
                comparison_op = '>='
            elif (comparison_op == 'GreaterThanThreshold'):
                comparison_op = '>'
            elif (comparison_op == 'LessThanOrEqualToThreshold'):
                comparison_op = '<='
            elif (comparison_op == 'LessThanThreshold'):
                comparison_op = '<'
            alarm = MetricAlarm(name=alarm_name, metric=metric_name, namespace=namespace, statistic=statistic, comparison=comparison_op, threshold=threshold, period=period, evaluation_periods=eval_periods, unit=unit, description=alarm_desc, dimensions=dimensions, alarm_actions=alarm_actions, insufficient_data_actions=insufficient_data_actions, ok_actions=ok_actions)
            self.user_session.cw.put_metric_alarm(alarm, self.callback)
    except Exception as ex:
        logging.error('Could not fulfill request, exception to follow')
        logging.error('Since we got here, client likely not notified either!')
        logging.exception(ex)
