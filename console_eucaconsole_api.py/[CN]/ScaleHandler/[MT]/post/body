@tornado.web.asynchronous
def post(self):
    if (not self.authorized()):
        raise tornado.web.HTTPError(401, 'not authorized')
    if (not self.user_session.scaling):
        if self.should_use_mock():
            self.user_session.scaling = MockScaleInterface()
        else:
            host = eucaconsole.config.get('server', 'clchost')
            if self.user_session.host_override:
                host = self.user_session.host_override
            self.user_session.scaling = BotoScaleInterface(host, self.user_session.access_key, self.user_session.secret_key, self.user_session.session_token)
        self.user_session.scaling = CachingScaleInterface(self.user_session.scaling, eucaconsole.config, self.user_session)
    self.user_session.session_lifetime_requests += 1
    try:
        action = self.get_argument('Action')
        if (action.find('Describe') == (-1)):
            self.user_session.session_last_used = time.time()
            self.check_xsrf_cookie()
        if (action == 'CreateAutoScalingGroup'):
            name = self.get_argument('AutoScalingGroupName')
            launch_config = self.get_argument('LaunchConfigurationName')
            azones = self.get_argument_list('AvailabilityZones.member')
            balancers = self.get_argument_list('LoadBalancerNames.member')
            def_cooldown = self.get_argument('DefaultCooldown', None)
            hc_type = self.get_argument('HealthCheckType', None)
            hc_period = self.get_argument('HealthCheckGracePeriod', None)
            desired_capacity = self.get_argument('DesiredCapacity', None)
            min_size = self.get_argument('MinSize', 0)
            max_size = self.get_argument('MaxSize', 0)
            tags = self.get_argument_list('Tags.member')
            termination_policy = self.get_argument_list('TerminationPolicies.member')
            as_group = AutoScalingGroup(name=name, launch_config=launch_config, availability_zones=azones, load_balancers=balancers, default_cooldown=def_cooldown, health_check_type=hc_type, health_check_period=hc_period, desired_capacity=desired_capacity, min_size=min_size, max_size=max_size, tags=tags, termination_policy=termination_policy)
            self.user_session.scaling.create_auto_scaling_group(as_group, self.callback)
        elif (action == 'DeleteAutoScalingGroup'):
            name = self.get_argument('AutoScalingGroupName')
            force = (self.get_argument('ForceDelete', '') == 'true')
            self.user_session.scaling.delete_auto_scaling_group(name, force, self.callback)
        elif (action == 'DescribeAutoScalingGroups'):
            names = self.get_argument_list('AutoScalingGroupNames.member')
            max_records = self.get_argument('MaxRecords', None)
            next_token = self.get_argument('NextToken', None)
            self.user_session.scaling.get_all_groups(names, max_records, next_token, self.callback)
        elif (action == 'DescribeAutoScalingInstances'):
            instance_ids = self.get_argument_list('InstanceIds.member')
            max_records = self.get_argument('MaxRecords', None)
            next_token = self.get_argument('NextToken', None)
            self.user_session.scaling.get_all_autoscaling_instances(instance_ids, max_records, next_token, self.callback)
        elif (action == 'SetDesiredCapacity'):
            name = self.get_argument('AutoScalingGroupName')
            desired_capacity = self.get_argument('DesiredCapacity')
            honor_cooldown = (self.get_argument('HonorCooldown', '') == 'true')
            self.user_session.scaling.set_desired_capacity(name, desired_capacity, honor_cooldown, self.callback)
        elif (action == 'SetInstanceHealth'):
            instance_id = self.get_argument('InstanceId')
            health_status = self.get_argument('HealthStatus')
            respect_grace_period = (self.get_argument('ShouldRespectGracePeriod', '') == 'true')
            self.user_session.scaling.set_instance_health(instance_id, health_status, respect_grace_period, self.callback)
        elif (action == 'TerminateInstanceInAutoScalingGroup'):
            instance_id = self.get_argument('InstanceId')
            decrement_capacity = (self.get_argument('ShouldDecrementDesiredCapacity', '') == 'true')
            self.user_session.scaling.terminate_instance(instance_id, decrement_capacity, self.callback)
        elif (action == 'UpdateAutoScalingGroup'):
            name = self.get_argument('AutoScalingGroupName')
            azones = self.get_argument_list('AvailabilityZones.member', None)
            def_cooldown = self.get_argument('DefaultCooldown', None)
            desired_capacity = self.get_argument('DesiredCapacity', None)
            hc_period = self.get_argument('HealthCheckGracePeriod', None)
            hc_type = self.get_argument('HealthCheckType', None)
            launch_config = self.get_argument('LaunchConfigurationName', None)
            min_size = self.get_argument('MinSize', None)
            max_size = self.get_argument('MaxSize', None)
            termination_policy = self.get_argument_list('TerminationPolicies.member')
            group = AutoScalingGroup(name=name, launch_config=launch_config, availability_zones=azones, default_cooldown=def_cooldown, health_check_type=hc_type, health_check_period=hc_period, desired_capacity=desired_capacity, min_size=min_size, max_size=max_size, termination_policies=termination_policy)
            self.user_session.scaling.update_autoscaling_group(group, self.callback)
        elif (action == 'CreateLaunchConfiguration'):
            image_id = self.get_argument('ImageId')
            name = self.get_argument('LaunchConfigurationName')
            instance_type = self.get_argument('InstanceType', 'm1.small')
            key_name = self.get_argument('KeyName', None)
            user_data = self.get_argument('UserData', None)
            kernel_id = self.get_argument('KernelId', None)
            ramdisk_id = self.get_argument('RamdiskId', None)
            groups = self.get_argument_list('SecurityGroups.member')
            bdm = []
            mapping = self.get_argument('BlockDeviceMapping.1.DeviceName', None)
            idx = 1
            while mapping:
                pre = ('BlockDeviceMapping.%d' % idx)
                dev_name = mapping
                virt_name = self.get_argument(('%s.VirtualName' % pre), None)
                block_dev_type = boto.ec2.autoscale.launchconfig.BlockDeviceMapping(device_name=dev_name, virtual_name=virt_name)
                if (not virt_name):
                    snapshot_id = self.get_argument(('%s.Ebs.SnapshotId' % pre), None)
                    size = self.get_argument(('%s.Ebs.VolumeSize' % pre), None)
                    ebs = boto.ec2.autoscale.launchconfig.Ebs(snapshot_id=snapshot_id, volume_size=size)
                    block_dev_type.ebs = ebs
                bdm.append(block_dev_type)
                idx += 1
                mapping = self.get_argument(('BlockDeviceMapping.%d.DeviceName' % idx), None)
            if (len(bdm) == 0):
                bdm = None
            monitoring = (self.get_argument('Instancemonitoring.Enabled', '') == 'true')
            spot_price = self.get_argument('SpotPrice', None)
            iam_instance_profile = self.get_argument('IamInstanceProfile', None)
            config = LaunchConfiguration(image_id=image_id, name=name, instance_type=instance_type, key_name=key_name, user_data=user_data, kernel_id=kernel_id, ramdisk_id=ramdisk_id, instance_monitoring=monitoring, spot_price=spot_price, instance_profile_name=iam_instance_profile, block_device_mappings=bdm, security_groups=groups)
            self.user_session.scaling.create_launch_configuration(config, self.callback)
        elif (action == 'DeleteLaunchConfiguration'):
            config_name = self.get_argument('LaunchConfigurationName')
            self.user_session.scaling.delete_launch_configuration(config_name, self.callback)
        elif (action == 'DescribeLaunchConfigurations'):
            config_names = self.get_argument_list('LaunchConfigurationNames.member')
            max_records = self.get_argument('MaxRecords', None)
            next_token = self.get_argument('NextToken', None)
            self.user_session.scaling.get_all_launch_configurations(config_names, max_records, next_token, self.callback)
        elif (action == 'DeletePolicy'):
            policy_name = self.get_argument('PolicyName')
            as_group = self.get_argument('AutoScalingGroupName', None)
            self.user_session.scaling.delete_policy(policy_name, as_group, self.callback)
        elif (action == 'DescribePolicies'):
            as_group = self.get_argument('AutoScalingGroupName', None)
            policy_names = self.get_argument_list('PolicyNames.member')
            max_records = self.get_argument('MaxRecords', None)
            next_token = self.get_argument('NextToken', None)
            self.user_session.scaling.get_all_policies(as_group, policy_names, max_records, next_token, self.callback)
        elif (action == 'ExecutePolicy'):
            policy_name = self.get_argument('PolicyName')
            as_group = self.get_argument('AutoScalingGroupName', None)
            honor_cooldown = self.get_argument('HonorCooldown', None)
            self.user_session.scaling.execute_policy(policy_name, as_group, honor_cooldown, self.callback)
        elif (action == 'PutScalingPolicy'):
            policy_name = self.get_argument('PolicyName')
            adjustment_type = self.get_argument('AdjustmentType')
            as_group = self.get_argument('AutoScalingGroupName')
            scaling_adjustment = self.get_argument('ScalingAdjustment')
            cooldown = self.get_argument('Cooldown', None)
            min_adjustment_step = self.get_argument('MinAdjustmentStep', None)
            policy = ScalingPolicy(name=policy_name, adjustment_type=adjustment_type, as_name=as_group, scaling_adjustment=scaling_adjustment, cooldown=cooldown, min_adjustment_step=min_adjustment_step)
            self.user_session.scaling.create_scaling_policy(policy, self.callback)
        elif (action == 'DescribeAdjustmentTypes'):
            self.user_session.scaling.get_all_adjustment_types(self.callback)
        elif (action == 'DeleteTags'):
            tags = self.get_tags()
            self.user_session.scaling.delete_tags(tags, self.callback)
        elif (action == 'DescribeTags'):
            filters = self.get_argument_list('Filters.member')
            max_records = self.get_argument('MaxRecords', None)
            next_token = self.get_argument('NextToken', None)
            self.user_session.scaling.get_all_tags(filters, max_records, next_token, self.callback)
        elif (action == 'CreateOrUpdateTags'):
            tags = self.get_tags()
            self.user_session.scaling.create_or_update_tags(tags, self.callback)
    except Exception as ex:
        logging.error('Could not fulfill request, exception to follow')
        logging.error('Since we got here, client likely not notified either!')
        logging.exception(ex)
