def post(self):
    if (not self.authorized()):
        raise tornado.web.HTTPError(401, 'not authorized')
    if (not self.user_session.clc):
        if self.should_use_mock():
            self.user_session.clc = MockClcInterface()
        else:
            self.user_session.clc = BotoClcInterface(eucaconsole.config.get('server', 'clchost'), self.user_session.access_key, self.user_session.secret_key, self.user_session.session_token)
        self.user_session.clc = CachingClcInterface(self.user_session.clc, eucaconsole.config)
    self.user_session.session_lifetime_requests += 1
    try:
        action = self.get_argument('Action')
        if (action.find('Describe') == (-1)):
            self.user_session.session_last_used = time.time()
            self.check_xsrf_cookie()
        if (action == 'GetKeyPairFile'):
            name = self.get_argument('KeyName')
            result = self.user_session.keypair_cache[name]
            self.set_header('Content-Type', 'application/x-pem-file;charset=ISO-8859-1')
            self.set_header('Content-Disposition', (('attachment; filename="' + name) + '.pem"'))
            self.write(result)
            del self.user_session.keypair_cache[name]
            return
        if (action == 'RunInstances'):
            user_data_file = []
            try:
                user_data_file = self.request.files['user_data_file']
            except KeyError:
                pass
            if (len(user_data_file) > 0):
                ret = self.handleRunInstances(action, self.user_session.clc, user_data_file[0].body)
            else:
                ret = self.handleRunInstances(action, self.user_session.clc, None)
        elif (action == 'DescribeAvailabilityZones'):
            ret = self.user_session.clc.get_all_zones()
        elif (action.find('Image') > (-1)):
            ret = self.handleImages(action, self.user_session.clc)
        elif ((action.find('Instance') > (-1)) or (action == 'GetConsoleOutput')):
            ret = self.handleInstances(action, self.user_session.clc)
        elif (action.find('Address') > (-1)):
            ret = self.handleAddresses(action, self.user_session.clc)
        elif (action.find('KeyPair') > (-1)):
            ret = self.handleKeypairs(action, self.user_session.clc)
        elif (action.find('SecurityGroup') > (-1)):
            ret = self.handleGroups(action, self.user_session.clc)
        elif (action.find('Volume') > (-1)):
            ret = self.handleVolumes(action, self.user_session.clc)
        elif (action.find('Snapshot') > (-1)):
            ret = self.handleSnapshots(action, self.user_session.clc)
        elif (action == 'GetPassword'):
            instanceid = self.get_argument('InstanceId')
            passwd_data = self.user_session.clc.get_password_data(instanceid)
            priv_key_file = self.request.files['priv_key']
            user_priv_key = RSA.load_key_string(priv_key_file[0].body)
            string_to_decrypt = base64.b64decode(passwd_data)
            ret = user_priv_key.private_decrypt(string_to_decrypt, RSA.pkcs1_padding)
            ret = {'instance': instanceid, 'password': ret, }
        ret = Response(ret)
        data = json.dumps(ret, cls=BotoJsonEncoder, indent=2)
        try:
            if eucaconsole.config.get('test', 'apidelay'):
                time.sleep((int(eucaconsole.config.get('test', 'apidelay')) / 1000.0))
        except ConfigParser.NoOptionError:
            pass
        self.set_header('Content-Type', 'application/json;charset=UTF-8')
        self.write(data)
    except EC2ResponseError as err:
        ret = ClcError(err.status, err.reason, err.errors[0][1])
        self.set_status(err.status)
        self.set_header('Content-Type', 'application/json;charset=UTF-8')
        self.write(json.dumps(ret, cls=BotoJsonEncoder))
    except Exception as ex:
        if isinstance(ex, socket.timeout):
            ret = ClcError(504, 'Timed out', None)
            self.set_status(504)
            self.set_header('Content-Type', 'application/json;charset=UTF-8')
            self.write(json.dumps(ret, cls=BotoJsonEncoder))
        else:
            logging.error('Could not fullfil request, exception to follow')
            logging.exception(ex)
            ret = ClcError(500, ex.message, None)
            self.set_status(500)
            self.set_header('Content-Type', 'application/json;charset=UTF-8')
            self.write(json.dumps(ret, cls=BotoJsonEncoder))
