{
  final NestedTx entityWrapper=new NestedTx(persistenceContext,new Predicate<TxUnroll>(){
    /** 
 * Handles nesting of transactions and unrolling nested failures.
 * During normal operations {@link #apply(TxUnroll)} should be called with{@link TxUnroll#ROLLBACK} as
 * the argument. The returned {@code boolean} value indicates whether or not it is safe to
 * modify the transaction state -- i.e. have we unrolled the whole stack.
 * In the case of a failure, {@link #apply(TxUnroll)} should be called with{@link TxUnroll#SAFELY}.
 * This will force a rollback and clean up nested transactions state.
 * @param forceClose
 * @return {@code true} if it is safe to modify the state of any inflight transactions.{@code false} otherwise
 */
    @Override public boolean apply(    final TxUnroll forceClose){
      if (TxUnroll.ROLLBACK.equals(forceClose)) {
        final AtomicStampedReference<NestedTx> ref=txState.get().remove(persistenceContext.name());
        if ((ref.getReference() != null) && ref.getReference().isActive()) {
          ref.getReference().doRollback();
        }
        return false;
      }
 else {
        final AtomicStampedReference<NestedTx> ref=txState.get().get(persistenceContext.name());
        final int stamp=ref.getStamp();
        ref.set(ref.getReference(),stamp - 1);
        return ref.getStamp() <= 0;
      }
    }
  }
);
  final AtomicStampedReference<NestedTx> ref=new AtomicStampedReference<NestedTx>(entityWrapper,1);
  this.get().put(persistenceContext.name(),ref);
  return ref;
}
