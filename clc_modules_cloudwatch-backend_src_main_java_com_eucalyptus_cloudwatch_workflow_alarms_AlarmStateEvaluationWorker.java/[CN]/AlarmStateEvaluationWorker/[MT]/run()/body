{
  try {
    if (!CloudWatchConfigProperties.isDisabledCloudWatchService() && Bootstrap.isOperational() && Topology.isEnabledLocally(CloudWatchBackend.class)) {
      Date evaluationDate=new Date();
      Map<AlarmEntity,AlarmState> currentStates=evaluateStates(alarmEntities);
      Map<String,AlarmState> statesToUpdate=Maps.newHashMap();
      List<AlarmHistory> historyList=Collections.<AlarmHistory>synchronizedList(new ArrayList<AlarmHistory>());
      CountDownLatch alarmHistoryCountdownLatch=new CountDownLatch(currentStates != null && currentStates.keySet() != null ? currentStates.keySet().size() : 0);
      for (      AlarmEntity alarmEntity : currentStates.keySet()) {
        AlarmState currentState=currentStates.get(alarmEntity);
        if (currentState.getStateValue() != alarmEntity.getStateValue()) {
          statesToUpdate.put(alarmEntity.getNaturalId(),currentState);
          historyList.add(AlarmManager.createChangeAlarmStateHistoryItem(alarmEntity,currentState,evaluationDate));
          AlarmManager.executeActionsAndRecord(alarmEntity,currentState,true,evaluationDate,historyList,alarmHistoryCountdownLatch);
        }
 else         if (moreThanOnePeriodHasPassed(alarmEntity,evaluationDate)) {
          AlarmManager.executeActionsAndRecord(alarmEntity,currentState,false,evaluationDate,historyList,alarmHistoryCountdownLatch);
        }
 else {
          alarmHistoryCountdownLatch.countDown();
        }
      }
      try {
        alarmHistoryCountdownLatch.await();
        AlarmManager.changeAlarmStateBatch(statesToUpdate,evaluationDate);
        AlarmManager.addAlarmHistoryEvents(historyList);
      }
 catch (      InterruptedException e) {
        LOG.error(e);
      }
    }
  }
  finally {
    countDownLatch.countDown();
  }
}
