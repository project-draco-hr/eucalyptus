{
  final Map<String,VmStateVolumeAttachmentView> volumes=Maps.newHashMap();
  CollectionUtils.putAll(Iterables.transform(Iterables.concat(vmInstance.getBootRecord().getPersistentVolumes(),vmInstance.getTransientVolumeState().getAttachments()),TypeMappers.lookup(VmVolumeAttachment.class,VmStateVolumeAttachmentView.class)),volumes,HasName.GET_NAME,Functions.<VmStateVolumeAttachmentView>identity());
  final Map<String,VmStateNetworkInterfaceAttachmentView> networkInterfaces=Maps.newHashMap();
  CollectionUtils.putAll(Iterables.transform(vmInstance.getNetworkInterfaces(),TypeMappers.lookup(NetworkInterface.class,VmStateNetworkInterfaceAttachmentView.class)),networkInterfaces,HasName.GET_NAME,Functions.<VmStateNetworkInterfaceAttachmentView>identity());
  return new VmStateView(vmInstance.getInstanceId(),vmInstance.getVersion(),vmInstance.getPartition(),vmInstance.getServiceTag(),vmInstance.getState(),vmInstance.getRuntimeState().getGuestState(),vmInstance.getRuntimeState().getReachabilityStatus(),vmInstance.getRuntimeState().getReason(),ImmutableMap.copyOf(volumes),ImmutableMap.copyOf(networkInterfaces),vmInstance.getLastUpdateTimestamp().getTime(),vmInstance.getExpiration() == null ? Long.MAX_VALUE : vmInstance.getExpiration().getTime(),vmInstance.getRuntimeState().isBundling(),vmInstance.getRuntimeState().getMigrationTask().getState().isMigrating());
}
