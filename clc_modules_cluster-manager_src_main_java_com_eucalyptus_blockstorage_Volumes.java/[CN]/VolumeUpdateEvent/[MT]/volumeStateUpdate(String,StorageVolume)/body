{
  final Function<String,Volume> updateVolume=new Function<String,Volume>(){
    @Override public Volume apply(    final String input){
      final StringBuilder buf=new StringBuilder();
      try {
        final Volume v=Entities.uniqueResult(Volume.named(null,input));
        VmVolumeAttachment vmAttachedVol=null;
        boolean maybeBusy=false;
        String vmId=null;
        try {
          vmAttachedVol=VmInstances.lookupVolumeAttachment(v.getDisplayName());
          maybeBusy=true;
          vmId=vmAttachedVol.getVmInstance().getInstanceId();
        }
 catch (        final NoSuchElementException ex) {
        }
        State initialState=v.getState();
        if (!State.ANNIHILATING.equals(initialState) && maybeBusy) {
          initialState=State.BUSY;
        }
        buf.append("VolumeStateUpdate: ").append(v.getPartition()).append(" ").append(v.getDisplayName()).append(" ").append(v.getState()).append(" ").append(v.getCreationTimestamp());
        if (vmAttachedVol != null) {
          buf.append(" attachment ").append(vmId).append(" ").append(vmAttachedVol.getAttachmentState());
        }
        String status=null;
        Integer size=0;
        String actualDeviceName="unknown";
        State volumeState=initialState;
        if (storageVolume != null) {
          status=storageVolume.getStatus();
          size=Integer.parseInt(storageVolume.getSize());
          actualDeviceName=storageVolume.getActualDeviceName();
          if (State.EXTANT.equals(initialState) && ((actualDeviceName == null) || "invalid".equals(actualDeviceName) || "unknown".equals(actualDeviceName))) {
            volumeState=State.GENERATING;
          }
 else           if (State.ANNIHILATING.equals(initialState) && State.ANNIHILATED.equals(Volumes.transformStorageState(v.getState(),status))) {
            volumeState=State.ANNIHILATED;
          }
 else {
            volumeState=Volumes.transformStorageState(v.getState(),status);
          }
          buf.append(" storage-volume ").append(storageVolume.getStatus()).append("=>").append(volumeState).append(" ").append(storageVolume.getSize()).append("GB ").append(storageVolume.getSnapshotId()).append(" ").append(storageVolume.getCreateTime()).append(" ").append(storageVolume.getActualDeviceName());
        }
 else         if (State.ANNIHILATING.equals(v.getState())) {
          volumeState=State.ANNIHILATED;
        }
 else         if (State.GENERATING.equals(v.getState()) && v.lastUpdateMillis() > VOLUME_STATE_TIMEOUT) {
          volumeState=State.FAIL;
        }
        v.setState(volumeState);
        try {
          if (v.getSize() <= 0) {
            v.setSize(new Integer(size));
          }
        }
 catch (        final Exception ex) {
          LOG.error(ex);
          Logs.extreme().error(ex,ex);
        }
        buf.append(" end-state ").append(v.getState());
        LOG.debug(buf.toString());
        return v;
      }
 catch (      final TransactionException ex) {
        LOG.error(buf.toString() + " failed because of " + ex.getMessage());
        Logs.extreme().error(buf.toString() + " failed because of " + ex.getMessage(),ex);
        throw Exceptions.toUndeclared(ex);
      }
catch (      final NoSuchElementException ex) {
        LOG.error(buf.toString() + " failed because of " + ex.getMessage());
        Logs.extreme().error(buf.toString() + " failed because of " + ex.getMessage(),ex);
        throw ex;
      }
    }
  }
;
  Entities.asTransaction(Volume.class,updateVolume).apply(volumeId);
}
