{
  LOG.info(request);
  final ImportInstanceResponseType reply=request.getReply();
  final UserFullName ufn=Contexts.lookup().getUserFullName();
  for (  DiskImage diskImage : request.getDiskImageSet()) {
    final DiskImageDetail imageDetails=diskImage.getImage();
    final String manifestLocation=imageDetails.getImportManifestUrl();
    try {
      LOG.info(AsyncRequests.sendSync(Topology.lookup(Imaging.class),new ImportImageType()));
    }
 catch (    Exception ex1) {
      LOG.error(ex1,ex1);
    }
    final String imageDescription=diskImage.getDescription();
    try {
      final ImageManifest manifest=ImageManifests.lookup(manifestLocation.replaceAll("\\?.*",imageDescription));
      ImageInfo image=Images.createPendingFromManifest(ufn,manifest.getName(),imageDescription,manifest.getArchitecture(),manifest.getVirtualizationType(),manifest.getKernelId(),manifest.getRamdiskId(),manifest);
    }
 catch (    Exception ex) {
      throw new ImageManifestException("Manifest lookup failed for " + manifestLocation + " because of: "+ ex.getMessage());
    }
  }
  ConversionTask task=new ConversionTask();
  String taskId=Crypto.generateId(request.getCorrelationId(),"import-i-");
  final String instanceId=Crypto.generateId(request.getCorrelationId(),"i-");
  final String reservationId=Crypto.generateId(request.getCorrelationId(),"r-");
  final String imageId=Crypto.generateId(request.getCorrelationId(),"emi-");
  task.setConversionTaskId(taskId);
  Date expiration=Dates.hoursFromNow(CONVERSION_EXPIRATION_TIMEOUT);
  task.setExpirationTime(expiration.toString());
  task.setState(ConversionState.active.name());
  task.setStatusMessage(LogUtil.dumpObject(request));
  ImportInstanceTaskDetails taskDetails=new ImportInstanceTaskDetails();
  Function<ImportInstanceLaunchSpecification,VmInstance> builder=new Function<ImportInstanceLaunchSpecification,VmInstance>(){
    @Override public VmInstance apply(    ImportInstanceLaunchSpecification arg0){
      Partition partition=Partitions.lookupByName(arg0.getPlacement().getAvailabilityZone());
      List<NetworkGroup> groups=Lists.newArrayList();
      final EntityTransaction db=Entities.get(VmInstance.class);
      try {
        VmInstance vm=new VmInstance.Builder().owner(Contexts.lookup().getUserFullName()).withIds(instanceId,reservationId,request.getCorrelationId(),request.getCorrelationId()).bootRecord(Emis.newBootableSet(imageId),UserDatas.decode(arg0.getUserData().getData()),KeyPairs.noKey(),VmTypes.lookup(arg0.getInstanceType()),arg0.getMonitoring().getEnabled(),null,null,null).placement(partition,partition.getName()).networking(groups,PrivateNetworkIndex.bogus()).addressing(false).build(1);
        vm.setNaturalId(request.getCorrelationId());
        vm.setState(VmState.STOPPED);
        vm=Entities.persist(vm);
        Entities.flush(vm);
        db.commit();
        return vm;
      }
 catch (      final ResourceAllocationException ex) {
        Logs.extreme().error(ex,ex);
        throw Exceptions.toUndeclared(ex);
      }
catch (      final Exception ex) {
        Logs.extreme().error(ex,ex);
        throw Exceptions.toUndeclared(new TransactionExecutionException(ex));
      }
 finally {
        if (db.isActive())         db.rollback();
      }
    }
  }
;
  builder.apply(request.getLaunchSpecification());
  taskDetails.setInstanceId(instanceId);
  taskDetails.setPlatform(request.getPlatform());
  taskDetails.setDescription(request.getDescription());
  task.setImportInstance(taskDetails);
  tasks.put(taskId,task);
  return reply;
}
