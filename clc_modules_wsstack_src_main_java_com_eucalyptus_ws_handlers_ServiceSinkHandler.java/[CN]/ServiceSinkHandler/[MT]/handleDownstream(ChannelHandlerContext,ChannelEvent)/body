{
  LOG.trace(this.getClass().getSimpleName() + "[outgoing]: " + e.getClass());
  if (e instanceof MessageEvent) {
    final MessageEvent msge=(MessageEvent)e;
    if (msge.getMessage() instanceof NullPayload) {
      msge.getFuture().cancel();
    }
 else     if (msge.getMessage() instanceof HttpResponse) {
      ctx.sendDownstream(e);
    }
 else     if (msge.getMessage() instanceof IsData) {
      ctx.sendDownstream(e);
    }
 else     if (msge.getMessage() instanceof BaseMessage) {
      BaseMessage reply=(BaseMessage)((MessageEvent)e).getMessage();
      if ((RegisterComponentResponseType.class.isAssignableFrom(reply.getClass()) || DeregisterComponentResponseType.class.isAssignableFrom(reply.getClass()) || EnableServiceResponseType.class.isAssignableFrom(reply.getClass())|| DisableServiceResponseType.class.isAssignableFrom(reply.getClass())) && reply.get_return()) {
        try {
          ServiceContext.shutdown();
          ServiceContext.startup();
        }
 catch (        Throwable ex) {
          LOG.error(ex,ex);
        }
      }
      if (reply instanceof WalrusDataGetResponseType && !(reply instanceof GetObjectResponseType && ((GetObjectResponseType)reply).getBase64Data() != null)) {
        e.getFuture().cancel();
        return;
      }
 else {
        this.sendDownstreamNewEvent(ctx,e,reply);
      }
    }
 else {
      e.getFuture().cancel();
      LOG.warn("Non-specific type being written to the channel. Not dropping this message causes breakage:" + msge.getMessage().getClass());
    }
    if (e.getFuture().isCancelled()) {
      LOG.trace("Cancelling send on : " + LogUtil.dumpObject(e));
    }
  }
 else {
    ctx.sendDownstream(e);
  }
}
