{
  X509Certificate cloudCert=null;
  X509Certificate x509=null;
  String userAccessKey=null;
  String userSecretKey=null;
  KeyPair keyPair=null;
  final CredentialDownloadGenerateCertificateStrategy certificateStrategy=AuthenticationProperties.getCredentialDownloadGenerateCertificateStrategy();
  try {
    final List<AccessKey> accessKeys=u.getKeys();
    for (    final AccessKey k : accessKeys) {
      if (k.isActive()) {
        userAccessKey=k.getAccessKey();
        userSecretKey=k.getSecretKey();
      }
    }
    if (userAccessKey == null && (accessKeys.isEmpty() || (u.isSystemAdmin() && force) || accessKeys.size() < AuthenticationProperties.ACCESS_KEYS_LIMIT)) {
      final AccessKey k=u.createKey();
      userAccessKey=k.getAccessKey();
      userSecretKey=k.getSecretKey();
    }
    if (userAccessKey == null) {
      throw new IllegalStateException("Access key limit exceeded");
    }
    final int certificateCount=u.getCertificates().size();
    if ((certificateStrategy == Absent && certificateCount == 0) || (certificateStrategy == Limited && certificateCount < AuthenticationProperties.SIGNING_CERTIFICATES_LIMIT)) {
      keyPair=Certs.generateKeyPair();
      x509=Certs.generateCertificate(keyPair,u.getName());
      x509.checkValidity();
      u.addCertificate(Identifiers.generateCertificateIdentifier(x509),x509);
    }
    cloudCert=SystemCredentials.lookup(Eucalyptus.class).getCertificate();
  }
 catch (  Exception e) {
    LOG.fatal(e,e);
    throw e;
  }
  final ByteArrayOutputStream byteOut=new ByteArrayOutputStream();
  final ZipArchiveOutputStream zipOut=new ZipArchiveOutputStream(byteOut);
  ZipArchiveEntry entry=null;
  zipOut.setComment("To setup the environment run: source /path/to/eucarc");
  StringBuilder sb=new StringBuilder();
  final String userNumber=u.getAccountNumber();
  sb.append("EUCA_KEY_DIR=$(cd $(dirname ${BASH_SOURCE:-$0}); pwd -P)");
  final Optional<String> computeUrl=remotePublicify(Compute.class);
  if (computeUrl.isPresent()) {
    sb.append(entryFor("EC2_URL",null,computeUrl));
  }
 else {
    sb.append("\necho WARN:  Eucalyptus URL is not configured. >&2");
    ServiceBuilder<? extends ServiceConfiguration> builder=ServiceBuilders.lookup(Compute.class);
    ServiceConfiguration localConfig=builder.newInstance(Internets.localHostAddress(),Internets.localHostAddress(),Internets.localHostAddress(),Eucalyptus.INSTANCE.getPort());
    sb.append("\nexport EC2_URL=" + ServiceUris.remotePublicify(localConfig));
  }
  sb.append(entryFor("S3_URL","An OSG is either not registered or not configured. S3_URL is not set. " + "Please register an OSG and/or set a valid s3 endpoint and download credentials again. " + "Or set S3_URL manually to http://OSG-IP:8773/services/objectstorage",remotePublicify(ObjectStorage.class)));
  sb.append(entryFor("AWS_IAM_URL","IAM service URL is not configured.",remotePublicify(Euare.class)));
  sb.append(entryFor("EUARE_URL","EUARE URL is not configured.",remotePublicify(Euare.class)));
  sb.append(entryFor("TOKEN_URL","TOKEN URL is not configured.",remotePublicify(Tokens.class)));
  sb.append(entryFor("AWS_AUTO_SCALING_URL","Auto Scaling service URL is not configured.",remotePublicify(AutoScaling.class)));
  sb.append(entryFor("AWS_CLOUDFORMATION_URL","CloudFormation service URL is not configured.",remotePublicify(CloudFormation.class)));
  sb.append(entryFor("AWS_CLOUDWATCH_URL","CloudWatch service URL is not configured.",remotePublicify(CloudWatch.class)));
  sb.append(entryFor("AWS_ELB_URL","Load Balancing service URL is not configured.",remotePublicify(LoadBalancing.class)));
  sb.append(entryFor("AWS_SIMPLEWORKFLOW_URL",null,remotePublicify(SimpleWorkflow.class)));
  if (u.isSystemAdmin()) {
    sb.append(entryFor("EUCA_BOOTSTRAP_URL",null,Optional.of(ServiceUris.remote(Topology.lookup(Empyrean.class)).toString())));
    sb.append(entryFor("EUCA_PROPERTIES_URL",null,Optional.of(ServiceUris.remote(Topology.lookup(PropertiesService.class)).toString())));
  }
  sb.append("\nexport EUSTORE_URL=" + StackConfiguration.DEFAULT_EUSTORE_URL);
  String baseName=null;
  if (x509 != null && keyPair != null) {
    String fingerPrint=Certs.getFingerPrint(keyPair.getPublic());
    if (fingerPrint != null) {
      baseName=X509Download.NAME_SHORT + "-" + u.getName()+ "-"+ fingerPrint.replaceAll(":","").toLowerCase().substring(0,8);
      sb.append("\nexport EC2_PRIVATE_KEY=${EUCA_KEY_DIR}/" + baseName + "-pk.pem");
      sb.append("\nexport EC2_CERT=${EUCA_KEY_DIR}/" + baseName + "-cert.pem");
    }
  }
 else   if (certificateStrategy != Never) {
    sb.append("\necho WARN: Certificate credentials not present. >&2");
    if (u.isSystemUser()) {
      sb.append("\necho WARN: Review authentication.credential_download_generate_certificate and >&2");
      sb.append("\necho WARN: authentication.signing_certificates_limit properties for current >&2");
      sb.append("\necho WARN: certificate download limits. >&2");
    }
  }
  sb.append("\nexport EC2_JVM_ARGS=-Djavax.net.ssl.trustStore=${EUCA_KEY_DIR}/jssecacerts");
  sb.append("\nexport EUCALYPTUS_CERT=${EUCA_KEY_DIR}/cloud-cert.pem");
  sb.append("\nexport EC2_ACCOUNT_NUMBER='" + u.getAccountNumber() + "'");
  sb.append("\nexport EC2_ACCESS_KEY='" + userAccessKey + "'");
  sb.append("\nexport EC2_SECRET_KEY='" + userSecretKey + "'");
  sb.append("\nexport AWS_ACCESS_KEY='" + userAccessKey + "'");
  sb.append("\nexport AWS_SECRET_KEY='" + userSecretKey + "'");
  sb.append("\nexport AWS_CREDENTIAL_FILE=${EUCA_KEY_DIR}/iamrc");
  sb.append("\nexport EC2_USER_ID='" + userNumber + "'");
  sb.append("\nalias ec2-bundle-image=\"ec2-bundle-image --cert ${EC2_CERT} --privatekey ${EC2_PRIVATE_KEY} --user ${EC2_ACCOUNT_NUMBER} --ec2cert ${EUCALYPTUS_CERT}\"");
  sb.append("\nalias ec2-upload-bundle=\"ec2-upload-bundle -a ${EC2_ACCESS_KEY} -s ${EC2_SECRET_KEY} --url ${S3_URL}\"");
  sb.append("\n");
  zipOut.putArchiveEntry(entry=new ZipArchiveEntry("eucarc"));
  entry.setUnixMode(0600);
  zipOut.write(sb.toString().getBytes(StandardCharsets.UTF_8));
  zipOut.closeArchiveEntry();
  sb=new StringBuilder();
  sb.append("AWSAccessKeyId=").append(userAccessKey).append('\n');
  sb.append("AWSSecretKey=").append(userSecretKey);
  zipOut.putArchiveEntry(entry=new ZipArchiveEntry("iamrc"));
  entry.setUnixMode(0600);
  zipOut.write(sb.toString().getBytes(StandardCharsets.UTF_8));
  zipOut.closeArchiveEntry();
  zipOut.putArchiveEntry(entry=new ZipArchiveEntry("cloud-cert.pem"));
  entry.setUnixMode(0600);
  zipOut.write(PEMFiles.getBytes(cloudCert));
  zipOut.closeArchiveEntry();
  zipOut.putArchiveEntry(entry=new ZipArchiveEntry("jssecacerts"));
  entry.setUnixMode(0600);
  KeyStore tempKs=KeyStore.getInstance("jks");
  tempKs.load(null);
  tempKs.setCertificateEntry("eucalyptus",cloudCert);
  ByteArrayOutputStream bos=new ByteArrayOutputStream();
  tempKs.store(bos,"changeit".toCharArray());
  zipOut.write(bos.toByteArray());
  zipOut.closeArchiveEntry();
  if (x509 != null && keyPair != null && baseName != null) {
    zipOut.putArchiveEntry(entry=new ZipArchiveEntry(baseName + "-pk.pem"));
    entry.setUnixMode(0600);
    zipOut.write(PEMFiles.getBytes("RSA PRIVATE KEY",Crypto.getCertificateProvider().getEncoded(keyPair.getPrivate())));
    zipOut.closeArchiveEntry();
    zipOut.putArchiveEntry(entry=new ZipArchiveEntry(baseName + "-cert.pem"));
    entry.setUnixMode(0600);
    zipOut.write(PEMFiles.getBytes(x509));
    zipOut.closeArchiveEntry();
  }
  zipOut.close();
  return byteOut.toByteArray();
}
