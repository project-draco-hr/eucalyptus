{
  final DescribeVolumesResponseType reply=(DescribeVolumesResponseType)request.getReply();
  final Context ctx=Contexts.lookup();
  final boolean showAll=request.getVolumeSet().remove("verbose");
  final AccountFullName ownerFullName=(ctx.isAdministrator() && showAll) ? null : ctx.getUserFullName().asAccountFullName();
  final Set<String> volumeIds=Sets.newHashSet(normalizeVolumeIdentifiers(request.getVolumeSet()));
  final Filter filter=Filters.generate(request.getFilterSet(),Volume.class);
  final Predicate<? super Volume> requestedAndAccessible=CloudMetadatas.filteringFor(Volume.class).byId(volumeIds).byPredicate(filter.asPredicate()).byPrivileges().buildPredicate();
  final Function<Set<String>,Set<String>> lookupVolumeIds=new Function<Set<String>,Set<String>>(){
    public Set<String> apply(    final Set<String> input){
      final List<Volume> volumes=Entities.query(Volume.named(ownerFullName,null),true,filter.asCriterion(),filter.getAliases());
      Set<String> res=Sets.newHashSet();
      for (      final Volume foundVol : Iterables.filter(volumes,requestedAndAccessible)) {
        res.add(foundVol.getDisplayName());
      }
      return res;
    }
  }
;
  Set<String> allowedVolumeIds=Entities.asTransaction(Volume.class,lookupVolumeIds).apply(volumeIds);
  final EntityTransaction db=Entities.get(VmInstance.class);
  try {
    final List<VmInstance> vms=Entities.query(VmInstance.create());
    final Function<String,Volume> lookupVolume=new Function<String,Volume>(){
      @Override public Volume apply(      String input){
        try {
          Volume foundVol=Entities.uniqueResult(Volume.named(ownerFullName,input));
          if (State.ANNIHILATED.equals(foundVol.getState())) {
            Entities.delete(foundVol);
            reply.getVolumeSet().add(foundVol.morph(new com.eucalyptus.compute.common.Volume()));
            return foundVol;
          }
 else {
            AttachedVolume attachedVolume=null;
            try {
              VmVolumeAttachment attachment=VmInstances.lookupVolumeAttachment(input,vms);
              attachedVolume=VmVolumeAttachment.asAttachedVolume(attachment.getVmInstance()).apply(attachment);
            }
 catch (            NoSuchElementException ex) {
              if (State.BUSY.equals(foundVol.getState())) {
                foundVol.setState(State.EXTANT);
              }
            }
            com.eucalyptus.compute.common.Volume msgTypeVolume=foundVol.morph(new com.eucalyptus.compute.common.Volume());
            if (attachedVolume != null) {
              msgTypeVolume.setStatus("in-use");
              msgTypeVolume.getAttachmentSet().add(attachedVolume);
            }
            reply.getVolumeSet().add(msgTypeVolume);
            return foundVol;
          }
        }
 catch (        NoSuchElementException ex) {
          throw ex;
        }
catch (        TransactionException ex) {
          throw Exceptions.toUndeclared(ex);
        }
      }
    }
;
    for (    String volId : allowedVolumeIds) {
      try {
        Entities.asTransaction(Volume.class,lookupVolume).apply(volId);
      }
 catch (      Exception ex) {
        Logs.extreme().debug(ex,ex);
      }
    }
    final Map<String,List<Tag>> tagsMap=TagSupport.forResourceClass(Volume.class).getResourceTagMap(AccountFullName.getInstance(ctx.getAccount()),allowedVolumeIds);
    for (    final com.eucalyptus.compute.common.Volume volume : reply.getVolumeSet()) {
      Tags.addFromTags(volume.getTagSet(),ResourceTag.class,tagsMap.get(volume.getVolumeId()));
    }
    db.commit();
  }
 catch (  Exception ex) {
    Logs.extreme().error(ex,ex);
    throw ex;
  }
 finally {
    if (db.isActive())     db.rollback();
  }
  return reply;
}
