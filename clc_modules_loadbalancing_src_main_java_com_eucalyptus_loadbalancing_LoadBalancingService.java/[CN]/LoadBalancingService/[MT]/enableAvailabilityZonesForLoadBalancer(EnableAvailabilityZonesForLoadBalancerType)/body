{
  final EnableAvailabilityZonesForLoadBalancerResponseType reply=request.getReply();
  final Context ctx=Contexts.lookup();
  final String lbName=request.getLoadBalancerName();
  final Collection<String> requestedZones=request.getAvailabilityZones().getMember();
  LoadBalancer lb=null;
  try {
    lb=LoadBalancers.getLoadbalancer(ctx,lbName);
  }
 catch (  final Exception ex) {
    throw new AccessPointNotFoundException();
  }
  final Set<String> allZones=Sets.newHashSet(Collections2.transform(lb.getZones(),new Function<LoadBalancerZoneCoreView,String>(){
    @Override @Nullable public String apply(    @Nullable LoadBalancerZoneCoreView arg0){
      return arg0.getName();
    }
  }
));
  if (lb != null && !LoadBalancingMetadatas.filterPrivileged().apply(lb)) {
    throw new AccessPointNotFoundException();
  }
  if (requestedZones != null && requestedZones.size() > 0) {
    try {
      final EnabledZoneEvent evt=new EnabledZoneEvent();
      evt.setLoadBalancer(lbName);
      evt.setContext(ctx);
      evt.setZones(requestedZones);
      ActivityManager.getInstance().fire(evt);
    }
 catch (    EventFailedException e) {
      LOG.error("failed to handle EnabledZone event",e);
      final String reason=e.getCause() != null && e.getCause().getMessage() != null ? e.getCause().getMessage() : "internal error";
      throw new InternalFailure400Exception(String.format("Failed to enable zones: %s",reason),e);
    }
  }
  allZones.addAll(requestedZones);
  final EnableAvailabilityZonesForLoadBalancerResult result=new EnableAvailabilityZonesForLoadBalancerResult();
  final AvailabilityZones availZones=new AvailabilityZones();
  availZones.setMember(Lists.newArrayList(allZones));
  result.setAvailabilityZones(availZones);
  reply.setEnableAvailabilityZonesForLoadBalancerResult(result);
  reply.set_return(true);
  return reply;
}
