{
  final CreateLoadBalancerResponseType reply=request.getReply();
  final Context ctx=Contexts.lookup();
  final UserFullName ownerFullName=ctx.getUserFullName();
  final String lbName=request.getLoadBalancerName();
  final Predicate<String> nameChecker=new Predicate<String>(){
    @Override public boolean apply(    @Nullable String arg0){
      if (arg0 == null)       return false;
      if (!HostSpecifier.isValid(String.format("%s.com",arg0)))       return false;
      return true;
    }
  }
;
  if (!nameChecker.apply(lbName)) {
    throw new LoadBalancingException("Invalid character found in the loadbalancer name");
  }
  if (request.getListeners() != null && request.getListeners().getMember() != null)   LoadBalancers.validateListener(request.getListeners().getMember());
  final Supplier<LoadBalancer> allocator=new Supplier<LoadBalancer>(){
    @Override public LoadBalancer get(){
      try {
        return LoadBalancers.addLoadbalancer(ownerFullName,lbName);
      }
 catch (      LoadBalancingException e) {
        throw Exceptions.toUndeclared(e);
      }
    }
  }
;
  LoadBalancer lb=null;
  try {
    lb=LoadBalancingMetadatas.allocateUnitlessResource(allocator);
  }
 catch (  Exception e) {
    handleException(e);
  }
  final LoadBalancerDnsRecord dns=LoadBalancers.getDnsRecord(lb);
  if (dns == null || dns.getName() == null)   throw new LoadBalancingException("New dns name could not be created");
  Function<String,Boolean> rollback=new Function<String,Boolean>(){
    @Override public Boolean apply(    String lbName){
      try {
        LoadBalancers.unsetForeignKeys(ctx,lbName);
      }
 catch (      Exception ex) {
        LOG.warn("unable to unset foreign keys",ex);
      }
      try {
        LoadBalancers.deleteLoadbalancer(ownerFullName,lbName);
      }
 catch (      LoadBalancingException ex) {
        LOG.error("failed to rollback the loadbalancer: " + lbName,ex);
        return false;
      }
      return true;
    }
  }
;
  Collection<String> zones=request.getAvailabilityZones().getMember();
  if (zones != null && zones.size() > 0) {
    try {
      LoadBalancers.addZone(lbName,ctx,zones);
    }
 catch (    LoadBalancingException ex) {
      rollback.apply(lbName);
      throw ex;
    }
catch (    Exception ex) {
      rollback.apply(lbName);
      throw new LoadBalancingException("Failed to create the loadbalancer (internal error)",ex);
    }
  }
  try {
    NewLoadbalancerEvent evt=new NewLoadbalancerEvent();
    evt.setLoadBalancer(lbName);
    evt.setContext(ctx);
    evt.setZones(zones);
    ActivityManager.getInstance().fire(evt);
  }
 catch (  EventFailedException e) {
    LOG.error("failed to fire new loadbalancer event",e);
    rollback.apply(lbName);
    final String reason=e.getCause() != null && e.getCause().getMessage() != null ? e.getCause().getMessage() : "internal error";
    throw new LoadBalancingException(String.format("Failed to create the loadbalancer: %s",reason),e);
  }
  Collection<Listener> listeners=request.getListeners().getMember();
  if (listeners != null && listeners.size() > 0) {
    LoadBalancers.createLoadbalancerListener(lbName,ctx,Lists.newArrayList(listeners));
    try {
      CreateListenerEvent evt=new CreateListenerEvent();
      evt.setLoadBalancer(lbName);
      evt.setListeners(listeners);
      evt.setContext(ctx);
      ActivityManager.getInstance().fire(evt);
    }
 catch (    EventFailedException e) {
      LOG.error("failed to fire createListener event",e);
      rollback.apply(lbName);
      final String reason=e.getCause() != null && e.getCause().getMessage() != null ? e.getCause().getMessage() : "internal error";
      throw new LoadBalancingException(String.format("Faild to create the loadbalancer: %s",reason),e);
    }
  }
  final CreateLoadBalancerResult result=new CreateLoadBalancerResult();
  if (dns == null || dns.getDnsName() == null) {
    LOG.warn("No DNS name is assigned to the loadbalancer: " + lbName);
  }
  result.setDnsName(dns.getDnsName());
  reply.setCreateLoadBalancerResult(result);
  reply.set_return(true);
  return reply;
}
