{
  final CreateLoadBalancerResponseType reply=request.getReply();
  final Context ctx=Contexts.lookup();
  final UserFullName ownerFullName=ctx.getUserFullName();
  final String lbName=request.getLoadBalancerName();
  final Predicate<String> nameChecker=new Predicate<String>(){
    @Override public boolean apply(    @Nullable String arg0){
      if (arg0 == null)       return false;
      if (!HostSpecifier.isValid(String.format("%s.com",arg0)))       return false;
      return true;
    }
  }
;
  if (!nameChecker.apply(lbName)) {
    throw new InvalidConfigurationRequestException("Invalid character found in the loadbalancer name");
  }
  if (lbName.length() > 32) {
    throw new InvalidConfigurationRequestException("Loadbalancer name must not exceed 32 characters");
  }
  if (request.getListeners() != null && request.getListeners().getMember() != null)   LoadBalancers.validateListener(request.getListeners().getMember());
  Collection<Listener> listeners=request.getListeners().getMember();
  try {
    for (    final Listener l : listeners) {
      if ("HTTPS".equals(l.getProtocol().toUpperCase()) || "SSL".equals(l.getProtocol().toUpperCase())) {
        final String certArn=l.getSSLCertificateId();
        if (certArn == null || certArn.length() <= 0)         throw new InvalidConfigurationRequestException("SSLCertificateId is required for HTTPS or SSL protocol");
        LoadBalancers.checkSSLCertificate(ctx.getUser().getUserId(),certArn);
      }
    }
  }
 catch (  Exception ex) {
    if (!(ex instanceof LoadBalancingException)) {
      LOG.error("failed to check SSL certificate Id",ex);
      ex=new InternalFailure400Exception("failed to check SSL certificate Id",ex);
    }
    throw (LoadBalancingException)ex;
  }
  final Supplier<LoadBalancer> allocator=new Supplier<LoadBalancer>(){
    @Override public LoadBalancer get(){
      try {
        return LoadBalancers.addLoadbalancer(ownerFullName,lbName);
      }
 catch (      LoadBalancingException e) {
        throw Exceptions.toUndeclared(e);
      }
    }
  }
;
  LoadBalancer lb=null;
  try {
    lb=LoadBalancingMetadatas.allocateUnitlessResource(allocator);
  }
 catch (  Exception e) {
    handleException(e);
  }
  final Collection<String> zones=request.getAvailabilityZones().getMember();
  Function<String,Boolean> rollback=new Function<String,Boolean>(){
    @Override public Boolean apply(    String lbName){
      try {
        LoadBalancers.unsetForeignKeys(ctx,lbName);
      }
 catch (      final Exception ex) {
        LOG.warn("unable to unset foreign keys",ex);
      }
      try {
        LoadBalancers.removeZone(lbName,ctx,zones);
      }
 catch (      final Exception ex) {
        LOG.error("unable to delete availability zones during rollback",ex);
      }
      try {
        LoadBalancers.deleteLoadbalancer(ownerFullName,lbName);
      }
 catch (      LoadBalancingException ex) {
        LOG.error("failed to rollback the loadbalancer: " + lbName,ex);
        return false;
      }
      return true;
    }
  }
;
  final LoadBalancerDnsRecord dns=LoadBalancers.getDnsRecord(lb);
  if (dns == null || dns.getName() == null) {
    rollback.apply(lbName);
    throw new InternalFailure400Exception("Dns name could not be created");
  }
  if (zones != null && zones.size() > 0) {
    try {
      LoadBalancers.addZone(lbName,ctx,zones);
    }
 catch (    LoadBalancingException ex) {
      rollback.apply(lbName);
      throw ex;
    }
catch (    Exception ex) {
      rollback.apply(lbName);
      throw new InternalFailure400Exception("Failed to persist the zone");
    }
  }
  try {
    NewLoadbalancerEvent evt=new NewLoadbalancerEvent();
    evt.setLoadBalancer(lbName);
    evt.setContext(ctx);
    evt.setZones(zones);
    ActivityManager.getInstance().fire(evt);
  }
 catch (  EventFailedException e) {
    LOG.error("failed to handle new loadbalancer event",e);
    rollback.apply(lbName);
    final String reason=e.getCause() != null && e.getCause().getMessage() != null ? e.getCause().getMessage() : "internal error";
    throw new InternalFailure400Exception(String.format("Failed to create the loadbalancer: %s",reason),e);
  }
  if (listeners != null && listeners.size() > 0) {
    LoadBalancers.createLoadbalancerListener(lbName,ctx,Lists.newArrayList(listeners));
    try {
      CreateListenerEvent evt=new CreateListenerEvent();
      evt.setLoadBalancer(lbName);
      evt.setListeners(listeners);
      evt.setContext(ctx);
      ActivityManager.getInstance().fire(evt);
    }
 catch (    EventFailedException e) {
      LOG.error("failed to handle createListener event",e);
      final String reason=e.getCause() != null && e.getCause().getMessage() != null ? e.getCause().getMessage() : "internal error";
      throw new InternalFailure400Exception(String.format("Faild to setup the listener: %s",reason),e);
    }
  }
  final CreateLoadBalancerResult result=new CreateLoadBalancerResult();
  if (dns == null || dns.getDnsName() == null) {
    LOG.warn("No DNS name is assigned to the loadbalancer: " + lbName);
  }
  result.setDnsName(dns.getDnsName());
  reply.setCreateLoadBalancerResult(result);
  reply.set_return(true);
  return reply;
}
