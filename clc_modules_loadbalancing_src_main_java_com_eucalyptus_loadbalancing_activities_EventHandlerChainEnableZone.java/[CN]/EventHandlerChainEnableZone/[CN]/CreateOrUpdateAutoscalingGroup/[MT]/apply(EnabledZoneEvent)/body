{
  final List<String> zones=Lists.newArrayList(evt.getZones());
  if (zones == null || zones.size() <= 0)   return;
  LoadBalancer lb=null;
  try {
    lb=LoadBalancers.getLoadbalancer(evt.getContext().getUserFullName(),evt.getLoadBalancer());
  }
 catch (  NoSuchElementException ex) {
    throw new EventHandlerException("Could not find the loadbalancer with name=" + evt.getLoadBalancer(),ex);
  }
catch (  Exception ex) {
    throw new EventHandlerException("Error while looking for loadbalancer with name=" + evt.getLoadBalancer(),ex);
  }
  group=lb.getAutoScaleGroup();
  if (group == null) {
    final EventHandlerChain<NewLoadbalancerEvent> newChain=(new EventHandlerChain<NewLoadbalancerEvent>(){
      @Override public EventHandlerChain<NewLoadbalancerEvent> build(){
        this.insert(new EventHandlerChainNew.IAMRoleSetup(this));
        this.insert(new EventHandlerChainNew.InstanceProfileSetup(this));
        this.insert(new EventHandlerChainNew.SecurityGroupSetup(this));
        int numVm=1;
        try {
          numVm=Integer.parseInt(EventHandlerChainNew.LOADBALANCER_NUM_VM);
        }
 catch (        NumberFormatException ex) {
          LOG.warn("unable to parse loadbalancer_num_vm");
        }
        this.insert(new LoadBalancerASGroupCreator(this,numVm));
        return this;
      }
    }
).build();
    try {
      NewLoadbalancerEvent newEvt=new NewLoadbalancerEvent();
      newEvt.setContext(evt.getContext());
      newEvt.setLoadBalancer(evt.getLoadBalancer());
      newEvt.setZones(evt.getZones());
      newChain.execute(newEvt);
      this.newZones=Lists.newArrayList(evt.getZones());
      this.oldZones=Lists.newArrayList();
    }
 catch (    EventHandlerChainException e) {
      throw new EventHandlerException("failed to create autoscaling group",e);
    }
  }
 else {
    this.groupName=group.getName();
    final List<String> requestedZones=Lists.newArrayList(evt.getZones());
    final List<LoadBalancerZone> currentZones=Lists.newArrayList(Collections2.filter(lb.getZones(),new Predicate<LoadBalancerZone>(){
      @Override public boolean apply(      @Nullable LoadBalancerZone arg0){
        return arg0.getState().equals(LoadBalancerZone.STATE.InService);
      }
    }
));
    final Set<String> availableZones=Sets.newHashSet(Collections2.transform(currentZones,new Function<LoadBalancerZone,String>(){
      @Override public String apply(      @Nullable LoadBalancerZone arg0){
        return arg0.getName();
      }
    }
));
    final Set<String> newZones=new HashSet<String>(availableZones);
    newZones.addAll(requestedZones);
    if (Sets.difference(newZones,availableZones).size() > 0) {
      try {
        int capacityPerZone=Integer.parseInt(EventHandlerChainNew.LOADBALANCER_NUM_VM);
        if (capacityPerZone <= 0)         capacityPerZone=1;
        final int newCapacity=capacityPerZone * newZones.size();
        EucalyptusActivityTasks.getInstance().updateAutoScalingGroup(group.getName(),Lists.newArrayList(newZones),newCapacity);
        final EntityTransaction db=Entities.get(LoadBalancerAutoScalingGroup.class);
        try {
          final LoadBalancerAutoScalingGroup update=Entities.uniqueResult(group);
          update.setCapacity(newCapacity);
          Entities.persist(update);
          db.commit();
        }
 catch (        NoSuchElementException ex) {
          db.rollback();
          LOG.error("failed to find the autoscaling group record",ex);
        }
catch (        Exception ex) {
          db.rollback();
          LOG.error("failed to update the autoscaling group record",ex);
        }
        this.newZones=Lists.newArrayList(newZones);
        this.oldZones=Lists.newArrayList(availableZones);
      }
 catch (      final Exception ex) {
        throw new EventHandlerException("failed to update autoscaling group",ex);
      }
    }
  }
}
