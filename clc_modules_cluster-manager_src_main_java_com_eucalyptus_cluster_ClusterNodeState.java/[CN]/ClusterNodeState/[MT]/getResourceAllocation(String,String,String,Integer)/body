{
  VmTypeAvailability vmType=this.typeMap.get(vmTypeName);
  NavigableSet<VmTypeAvailability> sorted=this.sorted();
  LOG.debug(LogUtil.header("BEFORE ALLOCATE"));
  LOG.debug(sorted);
  if (vmType.getAvailable() < quantity)   throw new NotEnoughResourcesAvailable("Not enough resources available: vm resources");
  Set<VmTypeAvailability> tailSet=sorted.tailSet(vmType);
  Set<VmTypeAvailability> headSet=sorted.headSet(vmType);
  LOG.debug(LogUtil.header("DURING ALLOCATE"));
  LOG.debug(LogUtil.subheader("TAILSET: \n" + tailSet));
  LOG.debug(LogUtil.subheader("HEADSET: \n" + headSet));
  for (  VmTypeAvailability v : tailSet)   v.decrement(quantity);
  for (  VmTypeAvailability v : headSet)   v.setAvailable(vmType.getAvailable());
  LOG.debug(LogUtil.header("AFTER ALLOCATE"));
  LOG.debug(sorted);
  ResourceToken token=new ResourceToken(this.clusterName,requestId,userName,quantity,this.virtualTimer++,vmTypeName);
  EventRecord.caller(ResourceToken.class,EventType.TOKEN_RESERVED,token.toString()).info();
  this.pendingTokens.add(token);
  return token;
}
