{
  VmTypeAvailability vmType=this.typeMap.get(vmTypeName);
  Integer available=vmType.getAvailable();
  NavigableSet<VmTypeAvailability> sorted=this.sorted();
  LOG.debug(LogUtil.header("BEFORE ALLOCATE"));
  LOG.debug(sorted);
  Integer quantity=min;
  if (vmType.getAvailable() < min) {
    throw new NotEnoughResourcesAvailable("Not enough resources (" + available + " < "+ min+ ": vm instances.");
  }
 else {
    quantity=(max < available ? max : available);
  }
  Set<VmTypeAvailability> tailSet=sorted.tailSet(vmType);
  Set<VmTypeAvailability> headSet=sorted.headSet(vmType);
  LOG.debug(LogUtil.header("DURING ALLOCATE"));
  LOG.debug(LogUtil.subheader("TAILSET: \n" + tailSet));
  LOG.debug(LogUtil.subheader("HEADSET: \n" + headSet));
  for (  VmTypeAvailability v : tailSet)   v.decrement(quantity);
  for (  VmTypeAvailability v : headSet)   v.setAvailable(vmType.getAvailable());
  LOG.debug(LogUtil.header("AFTER ALLOCATE"));
  LOG.debug(sorted);
  ResourceToken token=new ResourceToken(userFullName,requestId,this.clusterName,quantity,this.virtualTimer++,vmTypeName);
  EventRecord.caller(ResourceToken.class,EventType.TOKEN_RESERVED,token.toString()).info();
  this.pendingTokens.add(token);
  return token;
}
