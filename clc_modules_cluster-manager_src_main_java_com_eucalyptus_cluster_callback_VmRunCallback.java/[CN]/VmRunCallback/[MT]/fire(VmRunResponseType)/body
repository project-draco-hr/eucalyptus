{
  Logs.extreme().error(reply);
  try {
    this.token.redeem();
  }
 catch (  Exception ex) {
    LOG.error(this.token + ": " + ex);
    Logs.extreme().error(this.token + ": " + ex,ex);
  }
  final Volume rootVolume=this.token.getRootVolume();
  final String rootVolumeId=(rootVolume != null ? rootVolume.getDisplayName() : null);
  Function<VmInfo,Boolean> updateInstance=new Function<VmInfo,Boolean>(){
    @Override public Boolean apply(    final VmInfo input){
      final VmInstance vm=VmInstances.lookup(input.getInstanceId());
      vm.updateAddresses(input.getNetParams().getIpAddress(),input.getNetParams().getIgnoredPublicIp());
      try {
        final ServiceConfiguration scConfig=Topology.lookup(Storage.class,vm.lookupPartition());
        final ServiceConfiguration ccConfig=Topology.lookup(ClusterController.class,vm.lookupPartition());
        final Cluster cluster=Clusters.lookup(ccConfig);
        final String initialIqn=VmRunCallback.this.token.getInitialIqn();
        final String iqn=cluster.getNode(input.getServiceTag()).getIqn();
        vm.getRuntimeState().setServiceTag(input.getServiceTag());
        if (rootVolume != null) {
          if (!iqn.equals(initialIqn)) {
            LOG.debug(VmRunCallback.this.token + ": initial iqn: " + initialIqn);
            LOG.debug(VmRunCallback.this.token + ": final iqn:   " + iqn);
            String volumeId=VmRunCallback.this.token.getRootVolume().getDisplayName();
            VmVolumeAttachment volumeAttachment=vm.lookupVolumeAttachment(volumeId);
            LOG.debug(VmRunCallback.this.token + ": initial remove device: " + volumeAttachment.getRemoteDevice());
            try {
              ArrayList<String> iqns=new ArrayList<String>();
              iqns.add(iqn);
              final AttachStorageVolumeType attachMsg=new AttachStorageVolumeType(iqns,volumeId);
              final AttachStorageVolumeResponseType scAttachReply=AsyncRequests.sendSync(scConfig,attachMsg);
              LOG.debug(VmRunCallback.this.token + ": " + volumeId+ " => "+ scAttachReply);
              volumeAttachment.setRemoteDevice(scAttachReply.getRemoteDeviceString());
              LOG.debug(VmRunCallback.this.token + ": final remove device:   " + volumeAttachment.getRemoteDevice());
            }
 catch (            Exception ex) {
              LOG.error(VmRunCallback.this.token + ": " + ex);
              Logs.extreme().error(ex,ex);
            }
          }
        }
        final Predicate<VmVolumeAttachment> attachVolumes=new Predicate<VmVolumeAttachment>(){
          public boolean apply(          VmVolumeAttachment input){
            final String volumeId=input.getVolumeId();
            if (!volumeId.equals(rootVolumeId)) {
              try {
                if (!AttachmentState.attached.equals(input.getAttachmentState()) && !AttachmentState.attaching.equals(input.getAttachmentState())) {
                  input.setStatus(AttachmentState.attaching.name());
                }
              }
 catch (              Exception ex) {
                input.setStatus(AttachmentState.attaching_failed.name());
                LOG.error(VmRunCallback.this.token + ": " + ex);
                Logs.extreme().error(ex,ex);
              }
            }
            return true;
          }
        }
;
        try {
          vm.eachVolumeAttachment(attachVolumes);
        }
 catch (        Exception ex) {
          LOG.error(VmRunCallback.this.token + ": " + ex);
          Logs.extreme().error(VmRunCallback.this.token + ": " + ex,ex);
        }
      }
 catch (      Exception ex) {
        LOG.error(VmRunCallback.this.token + ": " + ex);
        Logs.extreme().error(VmRunCallback.this.token + ": " + ex,ex);
      }
      final Address addr=VmRunCallback.this.token.getAddress();
      if (addr != null) {
        try {
          AsyncRequests.newRequest(addr.assign(vm).getCallback()).then(new Callback.Success<BaseMessage>(){
            @Override public void fire(            final BaseMessage response){
              vm.updateAddresses(addr.getInstanceAddress(),addr.getName());
            }
          }
).dispatch(vm.getPartition());
        }
 catch (        Exception ex) {
          LOG.error(VmRunCallback.this.token + ": " + ex);
          Logs.extreme().error(VmRunCallback.this.token + ": " + ex,ex);
          Addresses.release(addr);
        }
      }
      return true;
    }
  }
;
  for (  final VmInfo vmInfo : reply.getVms()) {
    if (this.token.getInstanceId().equals(vmInfo.getInstanceId())) {
      try {
        Entities.asTransaction(VmInstance.class,updateInstance,10).apply(vmInfo);
        break;
      }
 catch (      RuntimeException ex) {
        LOG.error("Failed: " + this.token + " because of "+ ex.getMessage(),ex);
        throw ex;
      }
    }
    throw new EucalyptusClusterException("ccRunInstancesResponse: does not contain requested instance information for: " + this.token.getInstanceId() + " but return status is "+ reply.get_return()+ "\nccRunInstancesResponse:vms="+ reply.getVms());
  }
}
