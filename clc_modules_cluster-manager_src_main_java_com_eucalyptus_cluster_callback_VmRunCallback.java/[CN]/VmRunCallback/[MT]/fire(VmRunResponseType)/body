{
  Logs.extreme().error(reply);
  if (!reply.get_return()) {
    this.token.abort();
    throw new EucalyptusClusterException("Failed to run instance: " + this.getRequest().getInstanceId());
  }
 else {
    try {
      this.token.redeem();
    }
 catch (    Exception ex) {
      LOG.error(ex);
      Logs.extreme().error(ex,ex);
    }
    Function<VmInfo,Boolean> redeemToken=new Function<VmInfo,Boolean>(){
      @Override public Boolean apply(      final VmInfo input){
        final VmInstance vm=VmInstances.lookup(input.getInstanceId());
        vm.updateAddresses(input.getNetParams().getIpAddress(),input.getNetParams().getIgnoredPublicIp());
        final Address addr=VmRunCallback.this.token.getAddress();
        if (addr != null) {
          AsyncRequests.newRequest(addr.assign(vm).getCallback()).then(new Callback.Success<BaseMessage>(){
            @Override public void fire(            final BaseMessage response){
              vm.updateAddresses(addr.getInstanceAddress(),addr.getName());
            }
          }
).dispatch(vm.getPartition());
        }
        return true;
      }
    }
;
    for (    final VmInfo vmInfo : reply.getVms()) {
      try {
        Entities.asTransaction(VmInstance.class,redeemToken,10).apply(vmInfo);
      }
 catch (      RuntimeException ex) {
        LOG.error("Failed: " + this.token + " because of "+ ex.getMessage(),ex);
        throw ex;
      }
    }
  }
}
