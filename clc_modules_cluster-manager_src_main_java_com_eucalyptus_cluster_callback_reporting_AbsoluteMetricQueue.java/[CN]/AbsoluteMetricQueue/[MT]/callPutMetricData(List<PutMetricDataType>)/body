{
  List<ServiceConfiguration> configurationServiceList=Lists.newArrayList(Topology.lookupMany(CloudWatch.class));
  int numPutMetricDataRequests=0;
  for (  PutMetricDataType putMetricData : putMetricDataList) {
    final String requestToken=UUID.randomUUID().toString();
    ServiceConfiguration serviceConfiguration=configurationServiceList.get(numPutMetricDataRequests % configurationServiceList.size());
    numPutMetricDataRequests++;
    Pair<ComponentId,String> key=new Pair<>(serviceConfiguration.getComponentId(),serviceConfiguration.getHostName());
    ArrayBlockingQueue<String> queueTemp=putMetricDataRequestCountMap.get(key);
    if (queueTemp == null) {
      final ArrayBlockingQueue<String> value=new ArrayBlockingQueue<String>(MAX_CONCURRENT_PUT_METRIC_DATA_REQUESTS);
      queueTemp=putMetricDataRequestCountMap.putIfAbsent(key,value);
      if (queueTemp == null) {
        queueTemp=value;
      }
    }
    final ArrayBlockingQueue<String> queue=queueTemp;
    queue.put(requestToken);
    LOG.info("putting token" + requestToken);
    LOG.info("current = " + queue.size());
    LOG.info("size = " + putMetricData.toString().length());
    try {
      final CheckedListenableFuture<PutMetricDataResponseType> future=AsyncRequests.<PutMetricDataType,PutMetricDataResponseType>dispatch(serviceConfiguration,putMetricData);
      future.addListener(new Runnable(){
        @Override public void run(){
          try {
            future.get();
          }
 catch (          Exception ex) {
            LOG.error(ex,ex);
          }
          queue.remove(requestToken);
          LOG.info("removing token" + requestToken);
          LOG.info("current = " + queue.size());
        }
      }
);
    }
 catch (    Exception ex) {
      queue.remove(requestToken);
      LOG.info("removing token" + requestToken);
      LOG.info("current = " + queue.size());
      throw new EucalyptusCloudException("Unable to send put metric data to cloud watch");
    }
  }
}
