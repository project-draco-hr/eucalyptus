{
  ChannelUtil.setupServer();
  final ServerBootstrap bootstrap=new ServerBootstrap(ChannelUtil.getServerSocketChannelFactory());
  bootstrap.setPipelineFactory(ChannelUtil.getServerPipeline());
  if (!Logs.TRACE) {
    LOG.info("Creating server bootstrap. (log level TRACE for details)");
  }
 else {
    LOG.trace(LogUtil.subheader("Creating server boss thread pool."));
    LOG.trace(String.format("-> Server option: %25.25s = %s","child.tcpNoDelay",CHANNEL_NODELAY));
    LOG.trace(String.format("-> Server option: %25.25s = %s","child.keepAlive",CHANNEL_KEEP_ALIVE));
    LOG.trace(String.format("-> Server option: %25.25s = %s","child.reuseAddress",CHANNEL_REUSE_ADDRESS));
    LOG.trace(String.format("-> Server option: %25.25s = %s","child.connectTimeoutMillis",CHANNEL_CONNECT_TIMEOUT));
    LOG.trace(String.format("-> Server option: %25.25s = %s","tcpNoDelay",SERVER_CHANNEL_NODELAY));
    LOG.trace(String.format("-> Server option: %25.25s = %s","reuseAddress",SERVER_CHANNEL_REUSE_ADDRESS));
  }
  bootstrap.setOption("child.tcpNoDelay",CHANNEL_NODELAY);
  bootstrap.setOption("child.keepAlive",CHANNEL_KEEP_ALIVE);
  bootstrap.setOption("child.reuseAddress",CHANNEL_REUSE_ADDRESS);
  bootstrap.setOption("child.connectTimeoutMillis",CHANNEL_CONNECT_TIMEOUT);
  bootstrap.setOption("tcpNoDelay",SERVER_CHANNEL_NODELAY);
  bootstrap.setOption("reuseAddress",SERVER_CHANNEL_REUSE_ADDRESS);
  return bootstrap;
}
