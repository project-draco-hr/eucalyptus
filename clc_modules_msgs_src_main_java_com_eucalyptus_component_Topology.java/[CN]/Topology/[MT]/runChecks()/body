{
  this.getWorker().submit(new Runnable(){
    @Override public void run(){
      List<ServiceConfiguration> checkServicesList=ServiceConfigurations.collect(new Predicate<ServiceConfiguration>(){
        @Override public boolean apply(        ServiceConfiguration arg0){
          if (BootstrapArgs.isCloudController()) {
            return true;
          }
 else {
            return arg0.isVmLocal();
          }
        }
      }
);
      Logs.exhaust().debug("PARTITIONS ==============================\n" + Joiner.on("\n\t").join(Topology.this.services.keySet()));
      Logs.exhaust().debug("PRIMARY =================================\n" + Joiner.on("\n\t").join(Topology.this.services.values()));
      Predicate<Future<?>> futureIsDone=new Predicate<Future<?>>(){
        @Override public boolean apply(        Future<?> arg0){
          if (!arg0.isDone()) {
            try {
              arg0.get(100,TimeUnit.MILLISECONDS);
            }
 catch (            InterruptedException ex) {
              Thread.currentThread().interrupt();
            }
catch (            ExecutionException ex) {
              LOG.error(ex);
            }
catch (            TimeoutException ex) {
            }
          }
          return arg0.isDone();
        }
      }
;
      Map<ServiceConfiguration,Future<ServiceConfiguration>> futures=Maps.newHashMap();
      for (      ServiceConfiguration config : checkServicesList) {
        futures.put(config,Topology.getInstance().submitExternal(config,TopologyChanges.checkFunction()));
      }
      for (int i=0; i < 100 && !Iterables.all(futures.values(),futureIsDone); i++)       ;
      final List<ServiceConfiguration> disabledServices=Lists.newArrayList();
      final List<ServiceConfiguration> checkedServices=Lists.newArrayList();
      for (      Map.Entry<ServiceConfiguration,Future<ServiceConfiguration>> result : futures.entrySet()) {
        try {
          ServiceConfiguration resultConfig=result.getValue().get();
          checkedServices.add(resultConfig);
        }
 catch (        InterruptedException ex) {
          LOG.error(ex,ex);
          Thread.currentThread().interrupt();
        }
catch (        Throwable ex) {
          LOG.debug("Error while inspecting result of CHECK for: \n\t" + result.getKey() + ": \n\t"+ ex.getMessage());
          try {
            disabledServices.add(result.getKey());
            Topology.this.getGuard().tryDisable(result.getKey());
          }
 catch (          ServiceRegistrationException ex1) {
            LOG.error(ex1,ex1);
          }
          LOG.error(ex,ex);
        }
      }
      Logs.exhaust().debug("CHECK ===================================\n" + Joiner.on("\n\t").join(checkedServices));
      Logs.exhaust().debug("DISABLED ================================\n" + Joiner.on("\n\t").join(disabledServices));
      if (BootstrapArgs.isCloudController()) {
        final Predicate<ServiceConfiguration> predicate=new Predicate<ServiceConfiguration>(){
          @Override public boolean apply(          ServiceConfiguration arg0){
            try {
              ServiceKey key=ServiceKey.create(arg0);
              if (!BootstrapArgs.isCloudController()) {
                Logs.exhaust().debug("FAILOVER-REJECT: " + arg0 + ": not cloud controller.");
                return false;
              }
 else               if (disabledServices.contains(arg0)) {
                Logs.exhaust().debug("FAILOVER-REJECT: " + arg0 + ": service was just DISABLED.");
                return false;
              }
 else               if (Component.State.NOTREADY.isIn(arg0)) {
                Logs.exhaust().debug("FAILOVER-REJECT: " + arg0 + ": service is NOTREADY.");
                return false;
              }
 else               if (Topology.this.services.containsKey(key) && arg0.equals(Topology.this.services.get(key))) {
                Logs.exhaust().debug("FAILOVER-REJECT: " + arg0 + ": service is ENABLED.");
                return false;
              }
 else               if (!Topology.this.services.containsKey(key)) {
                Logs.exhaust().debug("FAILOVER-ACCEPT: " + arg0 + ": service for partition: "+ key);
                return true;
              }
 else {
                Logs.exhaust().debug("FAILOVER-ACCEPT: " + arg0);
                return true;
              }
            }
 catch (            ServiceRegistrationException ex) {
              LOG.error(ex,ex);
              return false;
            }
          }
        }
;
        List<ServiceConfiguration> failoverServicesList=ServiceConfigurations.collect(predicate);
        Logs.exhaust().debug("FAILOVER ================================\n" + Joiner.on("\n\t").join(failoverServicesList));
        for (        ServiceConfiguration config : failoverServicesList) {
          try {
            Topology.getInstance().submitExternal(config,CloudTopologyCallables.ENABLE).get();
          }
 catch (          InterruptedException ex) {
            LOG.error(ex,ex);
            Thread.currentThread().interrupt();
          }
catch (          ExecutionException ex) {
            LOG.error(ex,ex);
          }
catch (          Exception ex) {
            LOG.error(ex,ex);
          }
        }
      }
    }
  }
);
}
