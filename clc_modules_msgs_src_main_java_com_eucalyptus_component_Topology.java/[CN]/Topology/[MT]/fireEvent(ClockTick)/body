{
  final int backoff=Hosts.isCoordinator() ? COORDINATOR_CHECK_BACKOFF_SECS : LOCAL_CHECK_BACKOFF_SECS;
  Callable<Object> call=new Callable<Object>(){
    @Override public Object call(){
      try {
        return RunChecks.INSTANCE.call();
      }
  finally {
        busy.set(false);
      }
    }
  }
;
  if (busy.compareAndSet(false,true)) {
    try {
      TimeUnit.SECONDS.sleep(backoff);
    }
 catch (    InterruptedException ex) {
      busy.set(false);
      return;
    }
    if (lock.writeLock().tryLock() && (Hosts.isCoordinator() || counter.incrementAndGet() % 5 == 0)) {
      lock.writeLock().unlock();
      try {
        Queue.INTERNAL.enqueue(call);
      }
 catch (      Exception ex) {
        busy.set(false);
      }
    }
 else {
      busy.set(false);
    }
  }
}
