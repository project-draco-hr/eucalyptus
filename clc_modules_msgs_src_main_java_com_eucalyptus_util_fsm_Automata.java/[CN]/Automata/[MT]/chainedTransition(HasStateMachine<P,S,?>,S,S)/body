{
  if (toStates.length < 1) {
    throw new IllegalArgumentException("At least one toState must be specified");
  }
  final S toState=(toStates.length != 0) ? toStates[0] : null;
  final S nextFromState=toState;
  final S[] nextStates=(toStates.length > 1) ? Arrays.copyOfRange(toStates,1,toStates.length) : Arrays.copyOfRange(toStates,0,0);
  LOG.debug("Preparing callback for " + config.getFullName() + " of transition "+ fromState+ " -> "+ toState+ " with subsequent states: "+ Joiner.on("->").join(nextStates));
  final Callable<CheckedListenableFuture<ServiceConfiguration>> nextTransition=(nextStates.length != 0) ? chainedTransition(config,nextFromState,nextStates) : null;
  return new Callable<CheckedListenableFuture<ServiceConfiguration>>(){
    @Override public CheckedListenableFuture<ServiceConfiguration> call() throws Exception {
      StateMachine serviceStateMachine=config.getStateMachine();
      if (!fromState.equals(serviceStateMachine.getState())) {
        return Futures.predestinedFailedFuture(new IllegalStateException("Attempt to transition from " + fromState + "->"+ toState+ " when service is currently in "+ serviceStateMachine.getState()+ " for "+ config.toString()));
      }
 else {
        EventRecord.here(Automata.class,EventType.CALLBACK,EventType.COMPONENT_SERVICE_TRANSITION.toString(),fromState.toString(),toState.toString(),config.getFullName().toString()).debug();
        CheckedListenableFuture<ServiceConfiguration> future;
        try {
          future=serviceStateMachine.transition(toState);
          if (nextTransition != null) {
            return future.addListener(nextTransition).get();
          }
 else {
            return future;
          }
        }
 catch (        Exception ex) {
          LOG.error(ex,ex);
          return Futures.predestinedFailedFuture(ex);
        }
      }
    }
  }
;
}
