{
  final List<Callable<CheckedListenableFuture<P>>> callables=Lists.newArrayList();
  final StateMachine<P,S,?> fsm=hasFsm.getStateMachine();
  for (  final S toState : toStates) {
    callables.add(new Callable<CheckedListenableFuture<P>>(){
      @Override public CheckedListenableFuture<P> call(){
        try {
          return fsm.transition(toState);
        }
 catch (        final IllegalStateException ex) {
          return Futures.predestinedFailedFuture(ex);
        }
catch (        final ExistingTransitionException ex) {
          return Futures.predestinedFailedFuture(ex.getCause());
        }
catch (        final UndeclaredThrowableException ex) {
          return Futures.predestinedFailedFuture(ex.getCause());
        }
catch (        final Throwable ex) {
          return Futures.predestinedFailedFuture(ex);
        }
      }
    }
);
  }
  return callables;
}
