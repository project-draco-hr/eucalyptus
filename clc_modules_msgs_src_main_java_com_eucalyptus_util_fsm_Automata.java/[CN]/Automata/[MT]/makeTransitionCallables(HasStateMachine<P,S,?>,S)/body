{
  final List<Callable<CheckedListenableFuture<P>>> callables=Lists.newArrayList();
  final StateMachine<P,S,?> fsm=hasFsm.getStateMachine();
  for (  final S toState : toStates) {
    callables.add(new Callable<CheckedListenableFuture<P>>(){
      final CheckedListenableFuture<P> res=Futures.newGenericeFuture();
      @Override public CheckedListenableFuture<P> call(){
        try {
          LOG.trace("Invoking transition for state " + toState + " for "+ hasFsm);
          res.set(fsm.transition(toState).get());
        }
 catch (        IllegalStateException ex1) {
          LOG.error(ex1,ex1);
          res.setException(ex1);
        }
catch (        ExecutionException ex1) {
          LOG.error(ex1,ex1);
          res.setException(ex1);
        }
catch (        InterruptedException ex1) {
          LOG.error(ex1,ex1);
          res.setException(ex1);
        }
catch (        ExistingTransitionException ex1) {
          LOG.error(ex1,ex1);
          res.setException(ex1);
        }
        return res;
      }
    }
);
  }
  return callables;
}
