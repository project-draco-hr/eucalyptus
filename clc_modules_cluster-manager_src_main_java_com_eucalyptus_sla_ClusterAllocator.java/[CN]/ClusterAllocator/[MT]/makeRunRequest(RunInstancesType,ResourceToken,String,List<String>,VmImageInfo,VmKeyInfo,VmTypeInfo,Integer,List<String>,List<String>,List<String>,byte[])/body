{
  List<String> macs=Lists.transform(instanceIds,new Function<String,String>(){
    @Override public String apply(    String instanceId){
      return VmInstances.getAsMAC(instanceId);
    }
  }
);
  VmRunType run=new VmRunType(rsvId,request.getUserData(),childToken.getAmount(),imgInfo,vmInfo,keyInfo,instanceIds,macs,vlan,networkNames,netIndexes).regardingUserRequest(request);
  VmRunCallback cb=new VmRunCallback(run,childToken);
  if (!addrList.isEmpty()) {
    cb.then(new SuccessCallback<VmRunResponseType>(){
      @Override public void apply(      VmRunResponseType response){
        Iterator<String> addrs=addrList.iterator();
        for (        VmInfo vmInfo : response.getVms()) {
          final Address addr=Addresses.getInstance().lookup(addrs.next());
          final VmInstance vm=VmInstances.getInstance().lookup(vmInfo.getInstanceId());
          addr.assign(vm.getInstanceId(),vm.getPrivateAddress()).getCallback().then(new SuccessCallback(){
            public void apply(            BaseMessage response){
              vm.updatePublicAddress(addr.getName());
            }
          }
).dispatch(addr.getCluster());
        }
      }
    }
);
  }
  return cb;
}
