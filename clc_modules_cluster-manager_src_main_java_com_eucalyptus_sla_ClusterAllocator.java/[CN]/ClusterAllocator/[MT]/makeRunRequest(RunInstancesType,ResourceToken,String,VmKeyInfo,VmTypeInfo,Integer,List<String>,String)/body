{
  List<String> macs=Lists.transform(childToken.getInstanceIds(),new Function<String,String>(){
    @Override public String apply(    String instanceId){
      return VmInstances.getAsMAC(instanceId);
    }
  }
);
  List<String> networkIndexes=(childToken.getPrimaryNetwork() == null) ? new ArrayList<String>() : Lists.newArrayList(Iterables.transform(childToken.getPrimaryNetwork().getIndexes(),Functions.TO_STRING));
  VmRunType run=new VmRunType(rsvId,userData,childToken.getAmount(),vmInfo,keyInfo,childToken.getInstanceIds(),macs,vlan,networkNames,networkIndexes).regardingUserRequest(request);
  Request<VmRunType,VmRunResponseType> req=Callbacks.newClusterRequest(new VmRunCallback(run,childToken));
  if (!childToken.getAddresses().isEmpty()) {
    req.then(new Callback.Success<VmRunResponseType>(){
      @Override public void fire(      VmRunResponseType response){
        Iterator<String> addrs=childToken.getAddresses().iterator();
        for (        VmInfo vmInfo : response.getVms()) {
          final Address addr=Addresses.getInstance().lookup(addrs.next());
          final VmInstance vm=VmInstances.getInstance().lookup(vmInfo.getInstanceId());
          Callbacks.newClusterRequest(addr.assign(vm).getCallback()).then(new Callback.Success<BaseMessage>(){
            public void fire(            BaseMessage response){
              vm.updatePublicAddress(addr.getName());
            }
          }
).dispatch(addr.getCluster());
        }
      }
    }
);
  }
  return req;
}
