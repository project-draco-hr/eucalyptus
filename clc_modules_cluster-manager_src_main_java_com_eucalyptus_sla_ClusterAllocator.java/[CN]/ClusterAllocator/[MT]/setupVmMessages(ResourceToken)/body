{
  List<String> macs=Lists.newArrayList();
  for (  String instanceId : token.getInstanceIds())   macs.add(VmInstances.getAsMAC(instanceId));
  int vlan=token.getPrimaryNetwork().getVlan();
  if (vlan < 0)   vlan=9;
  List<String> networkNames=Lists.newArrayList(token.getPrimaryNetwork().getNetworkName());
  final List<String> addresses=Lists.newArrayList(token.getAddresses());
  RunInstancesType request=this.vmAllocInfo.getRequest();
  VmImageInfo imgInfo=this.vmAllocInfo.getImageInfo();
  VmTypeInfo vmInfo=this.vmAllocInfo.getVmTypeInfo();
  String rsvId=this.vmAllocInfo.getReservationId();
  VmKeyInfo keyInfo=this.vmAllocInfo.getKeyInfo();
  ArrayList<String> networkIndexes=Lists.newArrayList();
  for (  Integer index : token.getPrimaryNetwork().getIndexes()) {
    networkIndexes.add(index.toString());
  }
  VmRunType run=new VmRunType(request,rsvId,request.getUserData(),token.getAmount(),imgInfo,vmInfo,keyInfo,token.getInstanceIds(),macs,vlan,networkNames,networkIndexes);
  QueuedEventCallback<VmRunType> cb=new VmRunCallback(this,token).then(new SuccessCallback<VmRunResponseType>(){
    @Override public void apply(    VmRunResponseType response){
      for (      VmInfo vmInfo : response.getVms()) {
        Address addr=Addresses.getInstance().lookup(addresses.remove(0));
        VmInstance vm=VmInstances.getInstance().lookup(vmInfo.getInstanceId());
        AddressCategory.assign(addr,vm).dispatch(addr.getCluster());
      }
    }
  }
);
  this.msgMap.put(State.CREATE_VMS,QueuedEvent.make(cb,run));
}
