{
  this.msgMap=Multimaps.newHashMultimap();
  this.pendingEvents=new ConcurrentLinkedQueue<QueuedEventCallback>();
  this.state=State.START;
  this.rollback=new AtomicBoolean(false);
  this.vmAllocInfo=vmAllocInfo;
  if (vmToken != null) {
    try {
      this.cluster=Clusters.getInstance().lookup(vmToken.getCluster());
      for (      NetworkToken networkToken : vmToken.getNetworkTokens())       this.setupNetworkMessages(networkToken);
      this.setupVmMessages(vmToken);
    }
 catch (    Throwable e) {
      LOG.debug(e,e);
      try {
        Clusters.getInstance().lookup(vmToken.getCluster()).getNodeState().releaseToken(vmToken);
      }
 catch (      Throwable e1) {
        LOG.debug(e1);
        LOG.trace(e1,e1);
      }
      for (      String addr : vmToken.getAddresses()) {
        try {
          Addresses.release(Addresses.getInstance().lookup(addr));
        }
 catch (        Throwable e1) {
          LOG.debug(e1);
          LOG.trace(e1,e1);
        }
      }
      try {
        if (vmToken.getPrimaryNetwork() != null) {
          Network net=Networks.getInstance().lookup(vmToken.getPrimaryNetwork().getName());
          for (          Integer i : vmToken.getPrimaryNetwork().getIndexes()) {
            net.returnNetworkIndex(i);
          }
        }
      }
 catch (      Throwable e1) {
        LOG.debug(e1);
        LOG.trace(e1,e1);
      }
    }
  }
}
