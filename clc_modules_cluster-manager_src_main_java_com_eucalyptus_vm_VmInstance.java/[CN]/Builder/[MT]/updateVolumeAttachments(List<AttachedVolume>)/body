{
  try (TransactionResource db=Entities.transactionFor(VmInstance.class)){
    final VmInstance entity=Entities.merge(this);
    final List<VmVolumeAttachment> ncAttachedVols=Lists.transform(volumes,VmVolumeAttachment.fromAttachedVolume(entity));
    Set<String> remoteVolumes=Sets.newHashSet(Collections2.transform(ncAttachedVols,VmVolumeAttachmentName.INSTANCE));
    Set<String> localVolumes=Sets.newHashSet(Collections2.transform(entity.getTransientVolumeState().getAttachments(),VmVolumeAttachmentName.INSTANCE));
    localVolumes.addAll(Collections2.transform(entity.getBootRecord().getPersistentVolumes(),VmVolumeAttachmentName.INSTANCE));
    Set<String> intersection=Sets.intersection(remoteVolumes,localVolumes);
    Set<String> remoteOnly=Sets.difference(remoteVolumes,localVolumes);
    Set<String> localOnly=Sets.difference(localVolumes,remoteVolumes);
    if (!intersection.isEmpty() || !remoteOnly.isEmpty() || !localOnly.isEmpty()) {
      LOG.debug("Updating volume attachments for: " + entity.getInstanceId() + " intersection="+ intersection+ " local="+ localOnly+ " remote="+ remoteOnly);
      LOG.debug("Reported state for: " + entity.getInstanceId() + Collections2.transform(ncAttachedVols,VmVolumeAttachmentStateInfo.INSTANCE));
    }
    final Map<String,VmVolumeAttachment> ncAttachedVolMap=new HashMap<String,VmVolumeAttachment>(){
{
        for (        final VmVolumeAttachment v : ncAttachedVols) {
          this.put(v.getVolumeId(),v);
        }
      }
    }
;
    for (    String volId : intersection) {
      try {
        VmVolumeAttachment ncVolumeAttachment=ncAttachedVolMap.get(volId);
        VmVolumeAttachment localVolumeAttachment=this.lookupVolumeAttachment(volId);
        final AttachmentState localState=localVolumeAttachment.getAttachmentState();
        final AttachmentState remoteState=AttachmentState.parse(ncVolumeAttachment.getStatus());
        if (!localState.isVolatile()) {
          if (AttachmentState.detached.equals(remoteState)) {
            this.removeVolumeAttachment(volId);
          }
 else           if (AttachmentState.attaching_failed.equals(remoteState)) {
            this.removeVolumeAttachment(volId);
          }
 else           if (AttachmentState.detaching_failed.equals(remoteState) && !AttachmentState.attached.equals(localState)) {
            this.updateVolumeAttachment(volId,AttachmentState.attached);
          }
 else           if (AttachmentState.attached.equals(remoteState) && !AttachmentState.attached.equals(localState)) {
            this.updateVolumeAttachment(volId,AttachmentState.attached);
          }
        }
 else {
          if (AttachmentState.detaching.equals(localState) && AttachmentState.detached.equals(remoteState)) {
            this.removeVolumeAttachment(volId);
          }
 else           if (AttachmentState.attaching.equals(localState) && AttachmentState.attached.equals(remoteState)) {
            this.updateVolumeAttachment(volId,AttachmentState.attached);
          }
 else           if (AttachmentState.attaching.equals(localState) && AttachmentState.attaching_failed.equals(remoteState)) {
            this.removeVolumeAttachment(volId);
          }
 else           if (AttachmentState.detaching.equals(localState) && AttachmentState.detaching_failed.equals(remoteState)) {
            this.updateVolumeAttachment(volId,AttachmentState.attached);
          }
        }
      }
 catch (      Exception ex) {
        LOG.error(ex);
      }
    }
    for (    String volId : remoteOnly) {
      try {
        Volumes.lookup(null,volId);
      }
 catch (      NoSuchElementException e) {
        LOG.debug("Invalid volume id " + volId + " passed from back-end");
        continue;
      }
      try {
        VmVolumeAttachment ncVolumeAttachment=ncAttachedVolMap.get(volId);
        final AttachmentState remoteState=AttachmentState.parse(ncVolumeAttachment.getStatus());
        if (AttachmentState.attached.equals(remoteState) || AttachmentState.detaching_failed.equals(remoteState)) {
          LOG.warn("Restoring volume attachment state for " + entity.getInstanceId() + " with "+ ncVolumeAttachment.toString());
          entity.getTransientVolumeState().addVolumeAttachment(ncVolumeAttachment);
        }
      }
 catch (      Exception ex) {
        LOG.error(ex);
      }
    }
    for (    String volId : localOnly) {
      try {
        final AttachmentState localState=this.lookupVolumeAttachment(volId).getAttachmentState();
        if (!localState.isVolatile()) {
        }
      }
 catch (      Exception ex) {
        LOG.error(ex);
      }
    }
    db.commit();
  }
 catch (  final Exception ex) {
    Logs.extreme().error(ex,ex);
  }
}
