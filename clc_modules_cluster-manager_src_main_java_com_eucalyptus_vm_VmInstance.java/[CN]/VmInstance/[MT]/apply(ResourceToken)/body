{
  final EntityTransaction db=Entities.get(VmInstance.class);
  try {
    final Allocation allocInfo=token.getAllocationInfo();
    final VmInstance.Builder builder=new VmInstance.Builder();
    RunHelpers.getRunHelper().prepareVmInstance(token,builder);
    VmInstance vmInst=builder.owner(allocInfo.getOwnerFullName()).withIds(token.getInstanceId(),allocInfo.getReservationId(),allocInfo.getClientToken(),allocInfo.getUniqueClientToken(token.getLaunchIndex())).bootRecord(allocInfo.getBootSet(),allocInfo.getUserData(),allocInfo.getSshKeyPair(),allocInfo.getVmType(),allocInfo.isMonitoring(),allocInfo.getIamInstanceProfileArn(),allocInfo.getIamInstanceProfileId(),allocInfo.getIamRoleArn()).placement(allocInfo.getPartition()).networkGroups(allocInfo.getNetworkGroups()).addressing(allocInfo.isUsePrivateAddressing()).expiresOn(allocInfo.getExpiration()).build(token.getLaunchIndex());
    vmInst.setNaturalId(token.getInstanceUuid());
    vmInst=Entities.persist(vmInst);
    Entities.flush(vmInst);
    db.commit();
    token.setVmInstance(vmInst);
    return vmInst;
  }
 catch (  final ResourceAllocationException ex) {
    Logs.extreme().error(ex,ex);
    throw Exceptions.toUndeclared(ex);
  }
catch (  final Exception ex) {
    Logs.extreme().error(ex,ex);
    throw Exceptions.toUndeclared(new TransactionExecutionException(ex));
  }
 finally {
    if (db.isActive())     db.rollback();
  }
}
