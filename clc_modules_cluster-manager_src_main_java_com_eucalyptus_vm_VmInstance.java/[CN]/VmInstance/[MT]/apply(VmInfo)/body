{
  final VmState inputState=VmState.Mapper.get(input.getStateName());
  if (!VmStateSet.RUN.contains(inputState)) {
    return false;
  }
 else {
    final UserFullName userFullName=UserFullName.getInstance(input.getOwnerId());
    final List<NetworkGroup> networks=RestoreAllocation.restoreNetworks(input,userFullName);
    final PrivateNetworkIndex index=RestoreAllocation.restoreNetworkIndex(input,networks);
    final EntityTransaction db=Entities.get(VmInstance.class);
    try {
      final VmType vmType=RestoreAllocation.restoreVmType(input);
      final Partition partition=RestoreAllocation.restorePartition(input);
      final String imageId=RestoreAllocation.restoreImage(input);
      final String kernelId=RestoreAllocation.restoreKernel(input);
      final String ramdiskId=RestoreAllocation.restoreRamdisk(input);
      final BootableSet bootSet=RestoreAllocation.restoreBootSet(input,imageId,kernelId,ramdiskId);
      final int launchIndex=RestoreAllocation.restoreLaunchIndex(input);
      final SshKeyPair keyPair=RestoreAllocation.restoreSshKeyPair(input,userFullName);
      final byte[] userData=RestoreAllocation.restoreUserData(input);
      VmInstance vmInst;
      try {
        vmInst=new VmInstance.Builder().owner(userFullName).withIds(input.getInstanceId(),input.getReservationId()).bootRecord(bootSet,userData,keyPair,vmType).placement(partition,partition.getName()).networking(networks,index).build(launchIndex);
        vmInst.setNaturalId(input.getUuid());
        RestoreAllocation.restoreAddress(input,vmInst);
        Entities.persist(vmInst);
      }
 catch (      final Exception ex1) {
        LOG.error("Failed to restore instance " + input.getInstanceId() + " because of: "+ ex1.getMessage());
        Logs.extreme().error(ex1,ex1);
      }
      db.commit();
      return true;
    }
 catch (    final Exception ex) {
      LOG.error(ex);
      Logs.extreme().error(ex,ex);
      return false;
    }
 finally {
      if (db.isActive())       db.rollback();
    }
  }
}
