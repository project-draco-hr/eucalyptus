{
  try (final TransactionResource db=Entities.transactionFor(VmInstance.class)){
    final VmInstance instance=VmInstances.lookup(input.getInstanceId());
    Predicate<Address> assign=new Predicate<Address>(){
      @Override public boolean apply(      final Address address){
        address.assign(instance).clearPending();
        return true;
      }
    }
;
    Predicate<Address> updateInstanceAddresses=new Predicate<Address>(){
      @Override public boolean apply(      final Address address){
        instance.updateAddresses(input.getNetParams().getIpAddress(),address.getDisplayName());
        return true;
      }
    }
;
    if (reservedPublicIp.isPresent()) {
      final Address pendingAddress=Addresses.getInstance().lookup(reservedPublicIp.get().getValue());
      updateInstanceAddresses.apply(pendingAddress);
      if (!pendingAddress.isReallyAssigned()) {
        assign.apply(pendingAddress);
      }
    }
 else {
      final UserFullName userFullName=UserFullName.getInstance(input.getOwnerId());
      final Address address=Addresses.getInstance().lookup(input.getNetParams().getIgnoredPublicIp());
      if (address.isAssigned() && address.getInstanceAddress().equals(input.getNetParams().getIpAddress()) && address.getInstanceId().equals(input.getInstanceId())) {
        updateInstanceAddresses.apply(address);
      }
 else       if (!address.isAssigned() && address.isAllocated() && address.getOwnerAccountNumber().equals(userFullName.getAccountNumber())) {
        updateInstanceAddresses.apply(address);
        assign.apply(address);
      }
    }
    db.commit();
  }
 catch (  final Exception e) {
    LOG.error("Failed to restore address state " + input.getNetParams() + " for instance "+ input.getInstanceId()+ " because of: "+ e.getMessage());
    Logs.extreme().error(e,e);
  }
}
