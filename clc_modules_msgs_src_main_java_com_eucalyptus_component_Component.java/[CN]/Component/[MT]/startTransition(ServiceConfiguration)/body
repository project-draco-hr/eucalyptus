{
  final CheckedListenableFuture<ServiceConfiguration> transitionFuture=Futures.newGenericFuture();
  if (!this.hasLocalService()) {
    this.serviceRegistry.register(configuration);
  }
  Callable<ServiceConfiguration> transition=null;
switch (this.getState()) {
case LOADED:
case STOPPED:
    transition=makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture));
  break;
case INITIALIZED:
transition=makeLoadCallable(configuration,null,makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture)));
break;
case DISABLED:
case ENABLED:
case NOTREADY:
transition=noTransition;
transitionFuture.set(this.getLocalService().getServiceConfiguration());
break;
default :
throw new IllegalStateException("Failed to find transition for current component state: " + this.toString());
}
Threads.lookup(Empyrean.class).submit(transition);
return transitionFuture;
}
