{
  final CheckedListenableFuture<ServiceConfiguration> transitionFuture=Futures.newGenericFuture();
  Service service=null;
  if (this.serviceRegistry.hasService(configuration)) {
    service=this.serviceRegistry.lookup(configuration);
  }
 else {
    service=this.serviceRegistry.register(configuration);
  }
  if (Component.State.PRIMORDIAL.equals(service.getState())) {
    try {
      this.loadService(configuration);
    }
 catch (    ServiceRegistrationException ex) {
      LOG.error(ex,ex);
      throw new IllegalStateException(ex.getMessage(),ex);
    }
  }
  Callable<ServiceConfiguration> transition=null;
switch (service.getState()) {
case LOADED:
case STOPPED:
    transition=makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture));
  break;
case INITIALIZED:
transition=makeLoadCallable(configuration,null,makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture)));
break;
case DISABLED:
case ENABLED:
case NOTREADY:
transition=noTransition;
transitionFuture.set(this.getLocalService().getServiceConfiguration());
break;
default :
throw new IllegalStateException("Failed to find transition for current component state: " + this.toString());
}
Threads.lookup(Empyrean.class).submit(transition);
return transitionFuture;
}
