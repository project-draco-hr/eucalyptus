{
  final CheckedListenableFuture<ServiceConfiguration> transitionFuture=Futures.newGenericFuture();
  Service service=null;
  if (this.serviceRegistry.hasService(configuration)) {
    service=this.serviceRegistry.lookup(configuration);
  }
 else {
    service=this.serviceRegistry.register(configuration);
  }
  if (Component.State.PRIMORDIAL.equals(service.getState())) {
    try {
      service.transition(State.INITIALIZED);
    }
 catch (    NoSuchElementException ex) {
      LOG.error(ex,ex);
    }
catch (    ExistingTransitionException ex) {
      LOG.error(ex,ex);
    }
  }
  Callable<ServiceConfiguration> transition=null;
switch (service.getState()) {
case NOTREADY:
case DISABLED:
    transition=makeEnableCallable(configuration,transitionFuture);
  break;
case LOADED:
case STOPPED:
transition=makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture));
break;
case INITIALIZED:
transition=makeLoadCallable(configuration,null,makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture)));
break;
case ENABLED:
transition=noTransition;
transitionFuture.set(this.getLocalService().getServiceConfiguration());
break;
default :
throw new IllegalStateException("Failed to find transition for current component state: " + this.toString());
}
Threads.lookup(Empyrean.class).submit(transition);
return transitionFuture;
}
