{
  final CheckedListenableFuture<ServiceConfiguration> transitionFuture=Futures.newGenericFuture();
  if (!this.hasLocalService()) {
    try {
      this.serviceRegistry.register(configuration).transition(State.INITIALIZED);
    }
 catch (    NoSuchElementException ex) {
      LOG.error(ex,ex);
      throw new RuntimeException(ex.getMessage());
    }
catch (    ExistingTransitionException ex) {
      LOG.error(ex,ex);
      throw new RuntimeException(ex.getMessage());
    }
  }
  Callable<ServiceConfiguration> transition=null;
switch (this.getState()) {
case NOTREADY:
case DISABLED:
    transition=makeEnableCallable(configuration,transitionFuture);
  break;
case LOADED:
case STOPPED:
transition=makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture));
break;
case INITIALIZED:
transition=makeLoadCallable(configuration,null,makeStartCallable(configuration,null,makeEnableCallable(configuration,transitionFuture)));
break;
case ENABLED:
transition=noTransition;
transitionFuture.set(this.getLocalService().getServiceConfiguration());
break;
default :
throw new IllegalStateException("Failed to find transition for current component state: " + this.toString());
}
Threads.lookup(Empyrean.class).submit(transition);
return transitionFuture;
}
