{
  if ((input == null) || (output == null)) {
    throw new NullPointerException("Input and output buffers must not be null");
  }
  int inPos=input.position();
  int inLimit=input.limit();
  int inLen=inLimit - inPos;
  if (isUpdate && (inLen == 0)) {
    return 0;
  }
  int outLenNeeded=engineGetOutputSize(inLen);
  if (output.remaining() < outLenNeeded) {
    throw new ShortBufferException("Need at least " + outLenNeeded + " bytes of space in output buffer");
  }
  boolean a1=input.hasArray();
  boolean a2=output.hasArray();
  if (a1 && a2) {
    byte[] inArray=input.array();
    int inOfs=input.arrayOffset() + inPos;
    byte[] outArray=output.array();
    int outPos=output.position();
    int outOfs=output.arrayOffset() + outPos;
    int n;
    if (isUpdate) {
      n=engineUpdate(inArray,inOfs,inLen,outArray,outOfs);
    }
 else {
      n=engineDoFinal(inArray,inOfs,inLen,outArray,outOfs);
    }
    input.position(inLimit);
    output.position(outPos + n);
    return n;
  }
 else   if (!a1 && a2) {
    int outPos=output.position();
    byte[] outArray=output.array();
    int outOfs=output.arrayOffset() + outPos;
    byte[] inArray=new byte[getTempArraySize(inLen)];
    int total=0;
    while (inLen > 0) {
      int chunk=Math.min(inLen,inArray.length);
      input.get(inArray,0,chunk);
      int n;
      if (isUpdate || (inLen != chunk)) {
        n=engineUpdate(inArray,0,chunk,outArray,outOfs);
      }
 else {
        n=engineDoFinal(inArray,0,chunk,outArray,outOfs);
      }
      total+=n;
      outOfs+=n;
      inLen-=chunk;
    }
    output.position(outPos + total);
    return total;
  }
 else {
    byte[] inArray;
    int inOfs;
    if (a1) {
      inArray=input.array();
      inOfs=input.arrayOffset() + inPos;
    }
 else {
      inArray=new byte[getTempArraySize(inLen)];
      inOfs=0;
    }
    byte[] outArray=new byte[getTempArraySize(outLenNeeded)];
    int outSize=outArray.length;
    int total=0;
    boolean resized=false;
    while (inLen > 0) {
      int chunk=Math.min(inLen,outSize);
      if ((a1 == false) && (resized == false)) {
        input.get(inArray,0,chunk);
        inOfs=0;
      }
      try {
        int n;
        if (isUpdate || (inLen != chunk)) {
          n=engineUpdate(inArray,inOfs,chunk,outArray,0);
        }
 else {
          n=engineDoFinal(inArray,inOfs,chunk,outArray,0);
        }
        resized=false;
        inOfs+=chunk;
        inLen-=chunk;
        output.put(outArray,0,n);
        total+=n;
      }
 catch (      ShortBufferException e) {
        if (resized) {
          throw (ProviderException)new ProviderException("Could not determine buffer size").initCause(e);
        }
        resized=true;
        int newOut=engineGetOutputSize(chunk);
        outArray=new byte[newOut];
      }
    }
    input.position(inLimit);
    return total;
  }
}
