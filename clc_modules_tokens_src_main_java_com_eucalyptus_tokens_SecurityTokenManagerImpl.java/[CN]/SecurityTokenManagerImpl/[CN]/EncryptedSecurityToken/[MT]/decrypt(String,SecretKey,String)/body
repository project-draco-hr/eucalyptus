{
  try {
    final Cipher cipher=Ciphers.AES_GCM.get();
    final byte[] securityTokenBytes=B64.standard.dec(securityToken);
    if (securityTokenBytes.length < 64 + TOKEN_PREFIX.length || !Arrays.equals(TOKEN_PREFIX,Arrays.copyOf(securityTokenBytes,TOKEN_PREFIX.length))) {
      throw new GeneralSecurityException("Invalid token format");
    }
    cipher.init(Cipher.DECRYPT_MODE,key,new IvParameterSpec(securityTokenBytes,TOKEN_PREFIX.length,32),randomSupplier.get());
    final int offset=TOKEN_PREFIX.length + 32;
    final SecurityTokenInput in=new SecurityTokenInput(cipher.doFinal(securityTokenBytes,offset,securityTokenBytes.length - offset));
    if (in.readInt() != 2)     throw new GeneralSecurityException("Invalid token format");
    final String originatingAccessKeyIdOrUserId=in.readString();
    final String nonce=in.readString();
    final long created=in.readLong();
    final long expires=in.readLong();
    return new EncryptedSecurityToken(accessKeyId,originatingAccessKeyIdOrUserId,nonce,created,expires);
  }
 catch (  IOException e) {
    throw Exceptions.toUndeclared(e);
  }
}
