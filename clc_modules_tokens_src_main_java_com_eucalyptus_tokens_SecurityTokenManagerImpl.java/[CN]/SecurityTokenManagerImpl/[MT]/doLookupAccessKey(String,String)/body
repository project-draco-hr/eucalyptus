{
  Preconditions.checkNotNull(accessKeyId,"Access key identifier is required");
  Preconditions.checkNotNull(token,"Token is required");
  final SecurityTokenContent securityTokenContent;
  try {
    final Pair<String,String> tokenKey=Pair.pair(accessKeyId,token);
    securityTokenContent=tokenCache.get(tokenKey,new Callable<SecurityTokenContent>(){
      @Override public SecurityTokenContent call() throws Exception {
        return doDispatchingDecode(accessKeyId,token);
      }
    }
);
  }
 catch (  ExecutionException e) {
    log.debug(e,e);
    throw new InvalidAccessKeyAuthException("Invalid security token");
  }
  final String originatingAccessKeyId=securityTokenContent.getOriginatingAccessKeyId().orNull();
  final String userId=securityTokenContent.getOriginatingUserId().orNull();
  final UserPrincipal user;
  final TemporaryKeyType type;
  if (originatingAccessKeyId != null) {
    user=lookupByAccessKeyId(originatingAccessKeyId,securityTokenContent.getNonce());
    type=TemporaryKeyType.Session;
  }
 else   if (userId != null) {
    user=lookupByUserById(userId,securityTokenContent.getNonce());
    type=TemporaryKeyType.Access;
  }
 else {
    user=lookupByRoleById(securityTokenContent.getOriginatingRoleId().get(),securityTokenContent.getNonce());
    type=TemporaryKeyType.Role;
  }
  return new TemporaryAccessKey(){
    private static final long serialVersionUID=1L;
    private UserPrincipal principal=new UserPrincipalImpl(user,Collections.<AccessKey>singleton(this));
    @Override public Boolean isActive(){
      return user.isEnabled() && EncryptedSecurityToken.isValid(securityTokenContent);
    }
    @Override public String getAccessKey(){
      return accessKeyId;
    }
    @Override public String getSecurityToken(){
      return token;
    }
    @Override public String getSecretKey(){
      return Iterables.getOnlyElement(user.getKeys()).getSecretKey();
    }
    @Override public TemporaryKeyType getType(){
      return type;
    }
    @Override public Date getCreateDate(){
      return new Date(securityTokenContent.getCreated());
    }
    @Override public Date getExpiryDate(){
      return new Date(securityTokenContent.getExpires());
    }
    @Override public UserPrincipal getPrincipal() throws AuthException {
      return principal;
    }
  }
;
}
