{
  if (Bootstrap.isFinished() && Topology.isEnabledLocally(LoadBalancing.class) && Topology.isEnabled(Eucalyptus.class)) {
    EntityTransaction db=Entities.get(LoadBalancerAutoScalingGroup.class);
    List<LoadBalancerAutoScalingGroup> groups=Lists.newArrayList();
    Map<String,LoadBalancerAutoScalingGroup> allGroupMap=new ConcurrentHashMap<String,LoadBalancerAutoScalingGroup>();
    try {
      groups=Entities.query(LoadBalancerAutoScalingGroup.named(),true);
      db.commit();
      for (      LoadBalancerAutoScalingGroup g : groups) {
        allGroupMap.put(g.getName(),g);
      }
    }
 catch (    NoSuchElementException ex) {
      db.rollback();
    }
catch (    Exception ex) {
      db.rollback();
    }
    Map<String,LoadBalancerAutoScalingGroup> groupToQuery=new ConcurrentHashMap<String,LoadBalancerAutoScalingGroup>();
    final Date current=new Date(System.currentTimeMillis());
    for (    final LoadBalancerAutoScalingGroup group : groups) {
      final Date lastUpdate=group.getLastUpdateTimestamp();
      int elapsedSec=(int)((current.getTime() - lastUpdate.getTime()) / 1000.0);
      if (elapsedSec > AUTOSCALE_GROUP_CHECK_INTERVAL_SEC) {
        db=Entities.get(LoadBalancerAutoScalingGroup.class);
        try {
          LoadBalancerAutoScalingGroup update=Entities.uniqueResult(group);
          update.setLastUpdateTimestamp(current);
          Entities.persist(update);
          db.commit();
        }
 catch (        NoSuchElementException ex) {
          db.rollback();
        }
catch (        Exception ex) {
          db.rollback();
        }
        groupToQuery.put(group.getName(),group);
      }
    }
    if (groupToQuery.size() <= 0)     return;
    List<AutoScalingGroupType> queriedGroups=Lists.newArrayList();
    try {
      DescribeAutoScalingGroupsResponseType response=EucalyptusActivityTasks.getInstance().describeAutoScalingGroups(Lists.newArrayList(groupToQuery.keySet()));
      DescribeAutoScalingGroupsResult result=response.getDescribeAutoScalingGroupsResult();
      AutoScalingGroupsType asgroups=result.getAutoScalingGroups();
      queriedGroups=asgroups.getMember();
    }
 catch (    Exception ex) {
      LOG.error("Failed to describe autoscaling groups",ex);
      return;
    }
    Map<String,LoadBalancerServoInstance> servoMap=new ConcurrentHashMap<String,LoadBalancerServoInstance>();
    db=Entities.get(LoadBalancerServoInstance.class);
    try {
      final List<LoadBalancerServoInstance> result=Entities.query(LoadBalancerServoInstance.named(),true);
      db.commit();
      for (      LoadBalancerServoInstance inst : result) {
        servoMap.put(inst.getInstanceId(),inst);
      }
    }
 catch (    NoSuchElementException ex) {
      db.rollback();
    }
catch (    Exception ex) {
      db.rollback();
    }
    final List<LoadBalancerServoInstance> newServos=Lists.newArrayList();
    final Map<String,Instance> foundInstances=new ConcurrentHashMap<String,Instance>();
    for (    final AutoScalingGroupType asg : queriedGroups) {
      Instances instances=asg.getInstances();
      if (instances != null && instances.getMember() != null && instances.getMember().size() > 0) {
        for (        final Instance instance : instances.getMember()) {
          String instanceId=instance.getInstanceId();
          foundInstances.put(instanceId,instance);
          if (!servoMap.containsKey(instanceId)) {
            try {
              LoadBalancerAutoScalingGroup group=allGroupMap.get(asg.getAutoScalingGroupName());
              if (group == null)               throw new IllegalArgumentException("The group with name " + asg.getAutoScalingGroupName() + " not found in the database");
              final LoadBalancer lb=group.getLoadBalancer();
              LoadBalancerZone zone=null;
              for (              LoadBalancerZone z : lb.getZones()) {
                if (z.getName().equals(instance.getAvailabilityZone())) {
                  zone=z;
                  break;
                }
              }
              if (zone == null)               throw new Exception("No availability zone with name=" + instance.getAvailabilityZone() + " found for loadbalancer "+ lb.getDisplayName());
              final List<LoadBalancerSecurityGroup> sgroups=Lists.newArrayList(lb.getGroups());
              if (sgroups == null || sgroups.size() <= 0)               throw new Exception("No security group is found for loadbalancer " + lb.getDisplayName());
              final LoadBalancerSecurityGroup sgroup=sgroups.get(0);
              final LoadBalancerDnsRecord dns=lb.getDns();
              final LoadBalancerServoInstance newInstance=LoadBalancerServoInstance.newInstance(zone,sgroup,dns,group,instanceId);
              newServos.add(newInstance);
            }
 catch (            Exception ex) {
              LOG.error("Failed to construct new servo instance",ex);
              continue;
            }
          }
        }
      }
    }
    if (newServos.size() > 0) {
      db=Entities.get(LoadBalancerServoInstance.class);
      try {
        for (        LoadBalancerServoInstance instance : newServos) {
          Entities.persist(instance);
        }
        db.commit();
      }
 catch (      Exception ex) {
        db.rollback();
        LOG.error("Failed to persist the servo instance record",ex);
      }
    }
    List<LoadBalancerServoInstance> servoRecords=Lists.newArrayList();
    for (    String groupName : groupToQuery.keySet()) {
      final LoadBalancerAutoScalingGroup group=groupToQuery.get(groupName);
      servoRecords.addAll(group.getServos());
    }
    List<LoadBalancerServoInstance> registerDnsARec=Lists.newArrayList();
    for (    LoadBalancerServoInstance instance : servoRecords) {
      if (!foundInstances.containsKey(instance.getInstanceId())) {
        db=Entities.get(LoadBalancerServoInstance.class);
        try {
          final LoadBalancerServoInstance update=Entities.uniqueResult(instance);
          update.setState(LoadBalancerServoInstance.STATE.Error);
          Entities.persist(update);
          db.commit();
        }
 catch (        NoSuchElementException ex) {
          db.rollback();
        }
catch (        Exception ex) {
          db.rollback();
        }
      }
 else {
        Instance instanceCurrent=foundInstances.get(instance.getInstanceId());
        final String healthState=instanceCurrent.getHealthStatus();
        final String lifecycleState=instanceCurrent.getLifecycleState();
        LoadBalancerServoInstance.STATE curState=instance.getState();
        LoadBalancerServoInstance.STATE newState=curState;
        if (healthState != null && !healthState.equals("Healthy")) {
          newState=LoadBalancerServoInstance.STATE.Error;
        }
 else         if (lifecycleState != null) {
          if (lifecycleState.equals("Pending"))           newState=LoadBalancerServoInstance.STATE.Pending;
 else           if (lifecycleState.equals("Quarantined"))           newState=LoadBalancerServoInstance.STATE.Error;
 else           if (lifecycleState.equals("InService"))           newState=LoadBalancerServoInstance.STATE.InService;
 else           if (lifecycleState.equals("Terminating") || lifecycleState.equals("Terminated"))           newState=LoadBalancerServoInstance.STATE.OutOfService;
        }
        if (!curState.equals(newState)) {
          if (newState.equals(LoadBalancerServoInstance.STATE.InService))           registerDnsARec.add(instance);
          db=Entities.get(LoadBalancerServoInstance.class);
          try {
            final LoadBalancerServoInstance update=Entities.uniqueResult(instance);
            update.setState(newState);
            Entities.persist(update);
            db.commit();
          }
 catch (          NoSuchElementException ex) {
            db.rollback();
          }
catch (          Exception ex) {
            db.rollback();
          }
        }
      }
    }
    for (    LoadBalancerServoInstance instance : registerDnsARec) {
      String ipAddr=null;
      String privateIpAddr=null;
      try {
        List<RunningInstancesItemType> result=EucalyptusActivityTasks.getInstance().describeSystemInstances(Lists.newArrayList(instance.getInstanceId()));
        if (result != null && result.size() > 0) {
          ipAddr=result.get(0).getIpAddress();
          privateIpAddr=result.get(0).getPrivateIpAddress();
        }
      }
 catch (      Exception ex) {
        LOG.warn("failed to run describe-instances",ex);
        continue;
      }
      if (ipAddr == null || ipAddr.length() <= 0) {
        LOG.warn("no ipaddress found for instance " + instance.getInstanceId());
        continue;
      }
      try {
        String zone=instance.getDns().getZone();
        String name=instance.getDns().getName();
        EucalyptusActivityTasks.getInstance().addARecord(zone,name,ipAddr);
      }
 catch (      Exception ex) {
        LOG.warn("failed to register new ipaddress with dns A record",ex);
        continue;
      }
      db=Entities.get(LoadBalancerServoInstance.class);
      try {
        final LoadBalancerServoInstance update=Entities.uniqueResult(instance);
        update.setAddress(ipAddr);
        if (privateIpAddr != null)         update.setPrivateIp(privateIpAddr);
        Entities.persist(update);
        db.commit();
      }
 catch (      NoSuchElementException ex) {
        db.rollback();
        LOG.warn("failed to find the servo instance named " + instance.getInstanceId(),ex);
      }
catch (      Exception ex) {
        db.rollback();
        LOG.warn("failed to update servo instance's ip address",ex);
      }
    }
  }
}
