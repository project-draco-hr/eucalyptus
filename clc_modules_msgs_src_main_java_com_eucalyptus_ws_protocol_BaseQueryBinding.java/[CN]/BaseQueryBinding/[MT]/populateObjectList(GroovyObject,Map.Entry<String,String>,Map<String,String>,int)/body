{
  final List<String> failedMappings=new ArrayList<String>();
  try {
    final Field declaredField=getRecursiveField(obj.getClass(),paramFieldPair.getValue());
    final ArrayList theList=(ArrayList)obj.getProperty(paramFieldPair.getValue());
    final Class genericType=(Class)((ParameterizedType)declaredField.getGenericType()).getActualTypeArguments()[0];
    if (String.class.equals(genericType)) {
      if (params.containsKey(paramFieldPair.getKey())) {
        theList.add(params.remove(paramFieldPair.getKey()));
      }
 else {
        final List<String> keys=Lists.newArrayList(params.keySet());
        for (        final String k : keys) {
          if (k.matches(paramFieldPair.getKey() + "\\.\\d*")) {
            theList.add(params.remove(k));
          }
        }
      }
    }
 else     if (declaredField.isAnnotationPresent(HttpEmbedded.class)) {
      final HttpEmbedded annoteEmbedded=(HttpEmbedded)declaredField.getAnnotation(HttpEmbedded.class);
      if (annoteEmbedded.multiple()) {
        final List<String> keys=Lists.newArrayList(params.keySet());
        final Map<String,String> subParams=Maps.newConcurrentMap();
        for (        final String k : keys) {
          if (k.contains(paramFieldPair.getKey() + ".1.")) {
            final String currentValue=params.remove(k);
            final String newKey=k.replaceAll(paramFieldPair.getKey() + ".1.","");
            subParams.put(newKey,currentValue);
          }
        }
        failedMappings.addAll(this.populateEmbedded(genericType,subParams,theList));
      }
 else       failedMappings.addAll(this.populateEmbedded(genericType,params,theList));
    }
  }
 catch (  final Exception e1) {
    LOG.debug("FAILED HERE : ",e1);
    failedMappings.add(paramFieldPair.getKey());
  }
  return failedMappings;
}
