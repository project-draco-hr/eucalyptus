{
  List<String> failedMappings=new ArrayList<String>();
  for (  Map.Entry<String,String> e : paramFieldMap.entrySet()) {
    try {
      if (getRecursiveField(obj.getClass(),e.getValue()).getType().equals(ArrayList.class))       failedMappings.addAll(populateObjectList(obj,e,params,params.size()));
    }
 catch (    Exception e1) {
      LOG.debug("Failed mapping : ",e1);
      failedMappings.add(e.getKey());
    }
  }
  Class<?> declaredType=null;
  for (  Map.Entry<String,String> e : paramFieldMap.entrySet()) {
    try {
      declaredType=getRecursiveField(obj.getClass(),e.getValue()).getType();
    }
 catch (    Exception e2) {
      e2.printStackTrace();
    }
    if (params.containsKey(e.getKey()) && !populateObjectField(obj,e,params)) {
      failedMappings.add(e.getKey());
    }
 else     if (declaredType != null && EucalyptusData.class.isAssignableFrom(declaredType)) {
      try {
        Map<String,String> fieldMap=this.buildFieldMap(declaredType);
        Object newInstance=declaredType.newInstance();
        Map<String,String> subParams=Maps.newHashMap();
        for (        String item : Sets.newHashSet(params.keySet())) {
          if (item.startsWith(e.getKey())) {
            params.get(item);
            subParams.put(item.replace(e.getKey() + ".",""),params.remove(item));
          }
        }
        populateObject((GroovyObject)newInstance,fieldMap,subParams);
        obj.setProperty(e.getValue(),newInstance);
      }
 catch (      Exception e1) {
        e1.printStackTrace();
      }
    }
 else {
      failedMappings.remove(e.getKey());
    }
  }
  return failedMappings;
}
