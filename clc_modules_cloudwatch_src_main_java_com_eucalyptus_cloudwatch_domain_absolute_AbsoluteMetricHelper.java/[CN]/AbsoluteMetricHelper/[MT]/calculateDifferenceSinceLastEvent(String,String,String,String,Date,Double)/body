{
  LOG.trace("namespace=" + namespace + ",metricName="+ metricName+ ",dimensionName="+ dimensionName+ ",dimensionValue="+ dimensionValue+ ",newTimestamp="+ newTimestamp+ ",newMetricValue="+ newMetricValue);
  MetricDifferenceInfo returnValue=null;
  EntityTransaction db=Entities.get(AbsoluteMetricHistory.class);
  try {
    Criteria criteria=Entities.createCriteria(AbsoluteMetricHistory.class).add(Restrictions.eq("namespace",namespace)).add(Restrictions.eq("metricName",metricName)).add(Restrictions.eq("dimensionName",dimensionName)).add(Restrictions.eq("dimensionValue",dimensionValue));
    AbsoluteMetricHistory lastEntity=(AbsoluteMetricHistory)criteria.uniqueResult();
    if (lastEntity == null) {
      LOG.trace("First entry");
      lastEntity=new AbsoluteMetricHistory();
      lastEntity.setNamespace(namespace);
      lastEntity.setMetricName(metricName);
      lastEntity.setDimensionName(dimensionName);
      lastEntity.setDimensionValue(dimensionValue);
      lastEntity.setTimestamp(newTimestamp);
      lastEntity.setLastMetricValue(newMetricValue);
      Entities.persist(lastEntity);
      returnValue=null;
    }
 else {
      boolean sendNullReturnValue=false;
      double TOLERANCE=0.0000001;
      long elapsedTimeInMillis=newTimestamp.getTime() - lastEntity.getTimestamp().getTime();
      LOG.trace("lastTimestamp=" + lastEntity.getTimestamp());
      double valueDifference=newMetricValue - lastEntity.getLastMetricValue();
      if (elapsedTimeInMillis < 0) {
        LOG.trace("earlier point, kicking out");
        sendNullReturnValue=true;
      }
 else       if (elapsedTimeInMillis == 0) {
        if (Math.abs(valueDifference) > TOLERANCE) {
          LOG.warn("Getting different values " + newMetricValue + " and "+ lastEntity.getLastMetricValue()+ " for absolute metric "+ metricName+ " at the same timestamp "+ newTimestamp+ ", keeping the second value.");
        }
        sendNullReturnValue=true;
      }
 else       if (elapsedTimeInMillis > MAX_DIFFERENCE_DURATION_MS) {
        LOG.trace("too much time has passed, (" + elapsedTimeInMillis + " ms), starting over");
        lastEntity.setTimestamp(newTimestamp);
        lastEntity.setLastMetricValue(newMetricValue);
        sendNullReturnValue=true;
      }
 else       if (elapsedTimeInMillis > 0) {
        lastEntity.setTimestamp(newTimestamp);
        lastEntity.setLastMetricValue(newMetricValue);
        if (Math.abs(valueDifference) < TOLERANCE) {
          valueDifference=0.0;
        }
 else {
          LOG.trace("smaller value, assuming reset");
          sendNullReturnValue=true;
        }
      }
      LOG.trace("new values=valueDifference=" + valueDifference + ",elapsedTimeInMillis="+ elapsedTimeInMillis);
      if (!sendNullReturnValue) {
        returnValue=new MetricDifferenceInfo(valueDifference,elapsedTimeInMillis);
      }
    }
    db.commit();
  }
 catch (  RuntimeException ex) {
    Logs.extreme().error(ex,ex);
    throw ex;
  }
 finally {
    if (db.isActive())     db.rollback();
  }
  return returnValue;
}
