{
  ListVersionsResponseType reply=(ListVersionsResponseType)request.getReply();
  EntityWrapper<BucketInfo> db=EntityWrapper.get(BucketInfo.class);
  try {
    String bucketName=request.getBucket();
    BucketInfo bucketInfo=new BucketInfo(bucketName);
    bucketInfo.setHidden(false);
    List<BucketInfo> bucketList=db.queryEscape(bucketInfo);
    Context ctx=Contexts.lookup();
    Account account=ctx.getAccount();
    String prefix=request.getPrefix();
    int maxKeys=-1;
    String maxKeysString=request.getMaxKeys();
    if (maxKeysString != null) {
      maxKeys=Integer.parseInt(maxKeysString);
    }
 else {
      maxKeys=WalrusProperties.MAX_KEYS;
    }
    if (bucketList.size() > 0) {
      BucketInfo bucket=bucketList.get(0);
      BucketLogData logData=bucket.getLoggingEnabled() ? request.getLogData() : null;
      if (ctx.hasAdministrativePrivileges() || (bucket.canRead(account.getAccountNumber()) && (bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKETVERSIONS,PolicySpec.VENDOR_S3,PolicySpec.S3_RESOURCE_BUCKET,bucketName,null)))) {
        if (logData != null) {
          updateLogData(bucket,logData);
          reply.setLogData(logData);
        }
        if (Contexts.lookup().hasAdministrativePrivileges()) {
          try {
            if (bucketHasSnapshots(bucketName)) {
              db.rollback();
              throw new NoSuchBucketException(bucketName);
            }
          }
 catch (          Exception e) {
            db.rollback();
            throw new EucalyptusCloudException(e);
          }
        }
        String keyMarker=request.getKeyMarker();
        String versionMarker=request.getVersionIdMarker();
        String delimiter=request.getDelimiter();
        reply.setName(bucketName);
        reply.setIsTruncated(false);
        reply.setPrefix(prefix);
        if (maxKeys >= 0) {
          reply.setMaxKeys(maxKeys);
        }
        reply.setDelimiter(delimiter);
        reply.setKeyMarker(keyMarker);
        reply.setVersionIdMarker(versionMarker);
        if (bucket.isVersioningDisabled()) {
          db.commit();
          return reply;
        }
        if (maxKeys == 0) {
          reply.setKeyEntries(new ArrayList<KeyEntry>());
          reply.setCommonPrefixesList(new ArrayList<CommonPrefixesEntry>());
          db.commit();
          return reply;
        }
        final int queryStrideSize=maxKeys + 1;
        EntityWrapper<ObjectInfo> dbObject=db.recast(ObjectInfo.class);
        ObjectInfo searchObj=new ObjectInfo();
        searchObj.setBucketName(bucketName);
        Criteria objCriteria=dbObject.createCriteria(ObjectInfo.class);
        objCriteria.add(Example.create(searchObj));
        objCriteria.addOrder(Order.asc("objectKey"));
        objCriteria.addOrder(Order.desc("lastModified"));
        objCriteria.setMaxResults(queryStrideSize);
        keyMarker=(Strings.isNullOrEmpty(keyMarker) ? "" : keyMarker);
        prefix=(Strings.isNullOrEmpty(prefix) ? "" : prefix);
        versionMarker=(Strings.isNullOrEmpty(versionMarker) ? "" : versionMarker);
        if (!Strings.isNullOrEmpty(keyMarker)) {
          if (!Strings.isNullOrEmpty(versionMarker)) {
            Date resumeDate=null;
            try {
              ObjectInfo markerObj=new ObjectInfo();
              markerObj.setBucketName(bucketName);
              markerObj.setVersionId(versionMarker);
              markerObj.setObjectKey(keyMarker);
              ObjectInfo lastFromPrevObj=dbObject.uniqueResultEscape(markerObj);
              if (lastFromPrevObj != null && lastFromPrevObj.getLastModified() != null) {
                resumeDate=lastFromPrevObj.getLastModified();
              }
 else {
                dbObject.rollback();
                throw new NoSuchEntityException("VersionIDMarker " + versionMarker + " does not match an existing object version");
              }
            }
 catch (            TransactionException e) {
              LOG.error(e);
              dbObject.rollback();
              throw new EucalyptusCloudException("Next-Key-Marker or Next-Version-Id marker invalid");
            }
            objCriteria.add(Restrictions.or(Restrictions.and(Restrictions.eq("objectKey",keyMarker),Restrictions.lt("lastModified",resumeDate)),Restrictions.gt("objectKey",keyMarker)));
          }
 else {
            objCriteria.add(Restrictions.and(Restrictions.gt("objectKey",keyMarker),Restrictions.not(Restrictions.like("objectKey",keyMarker,MatchMode.START))));
          }
        }
        if (!Strings.isNullOrEmpty(prefix)) {
          objCriteria.add(Restrictions.like("objectKey",prefix,MatchMode.START));
        }
 else {
          prefix="";
        }
        List<ObjectInfo> objectInfos=null;
        int resultKeyCount=0;
        ArrayList<KeyEntry> keyEntries=new ArrayList<KeyEntry>();
        String nextKeyMarker=null;
        String nextVersionIdMarker=null;
        TreeSet<String> commonPrefixes=new TreeSet<String>();
        int firstResult=-1;
        do {
          objCriteria.setFirstResult(queryStrideSize * (++firstResult));
          objectInfos=(List<ObjectInfo>)objCriteria.list();
          if (objectInfos.size() > 0) {
            for (            ObjectInfo objectInfo : objectInfos) {
              String objectKey=objectInfo.getObjectKey();
              if (!Strings.isNullOrEmpty(delimiter)) {
                String[] parts=objectKey.substring(prefix.length()).split(delimiter);
                if (parts.length > 1) {
                  String prefixString=prefix + parts[0] + delimiter;
                  if (!commonPrefixes.contains(prefixString)) {
                    if (resultKeyCount == maxKeys) {
                      reply.setNextKeyMarker(nextKeyMarker);
                      reply.setNextVersionIdMarker(nextVersionIdMarker);
                      reply.setIsTruncated(true);
                      resultKeyCount++;
                      break;
                    }
                    commonPrefixes.add(prefixString);
                    resultKeyCount++;
                    if (resultKeyCount == maxKeys) {
                      nextKeyMarker=prefixString;
                      nextVersionIdMarker=null;
                    }
                  }
                  continue;
                }
              }
              if (resultKeyCount == maxKeys) {
                reply.setNextKeyMarker(nextKeyMarker);
                reply.setNextVersionIdMarker(nextVersionIdMarker);
                reply.setIsTruncated(true);
                resultKeyCount++;
                break;
              }
              KeyEntry keyEntry=null;
              if (!objectInfo.getDeleted()) {
                keyEntry=new VersionEntry();
                ((VersionEntry)keyEntry).setEtag(objectInfo.getEtag());
                ((VersionEntry)keyEntry).setSize(objectInfo.getSize());
                ((VersionEntry)keyEntry).setStorageClass(objectInfo.getStorageClass());
              }
 else {
                keyEntry=new DeleteMarkerEntry();
              }
              keyEntry.setKey(objectKey);
              keyEntry.setVersionId(objectInfo.getVersionId());
              keyEntry.setIsLatest(objectInfo.getLast());
              keyEntry.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(),DateUtils.ALT_ISO8601_DATE_PATTERN));
              try {
                Account ownerAccount=Accounts.lookupAccountById(objectInfo.getOwnerId());
                keyEntry.setOwner(new CanonicalUserType(ownerAccount.getCanonicalId(),ownerAccount.getName()));
              }
 catch (              AuthException e) {
                db.rollback();
                throw new AccessDeniedException("Bucket",bucketName,logData);
              }
              keyEntries.add(keyEntry);
              resultKeyCount++;
              if (resultKeyCount == maxKeys) {
                nextKeyMarker=objectKey;
                nextVersionIdMarker=objectInfo.getVersionId();
              }
            }
          }
          if (resultKeyCount <= maxKeys && objectInfos.size() <= maxKeys) {
            break;
          }
        }
 while (resultKeyCount <= maxKeys);
        reply.setKeyEntries(keyEntries);
        if (commonPrefixes != null && !commonPrefixes.isEmpty()) {
          ArrayList<CommonPrefixesEntry> commonPrefixesList=new ArrayList<CommonPrefixesEntry>();
          for (          String prefixEntry : commonPrefixes) {
            commonPrefixesList.add(new CommonPrefixesEntry().add(new PrefixEntry(prefixEntry)));
          }
          reply.setCommonPrefixesList(commonPrefixesList);
        }
      }
 else {
        db.rollback();
        throw new AccessDeniedException("Bucket",bucketName,logData);
      }
    }
 else {
      db.rollback();
      throw new NoSuchBucketException(bucketName);
    }
    db.commit();
    return reply;
  }
 catch (  Exception ex) {
    LOG.error("Error listing versions for request: " + request,ex);
    if (db.isActive()) {
      db.rollback();
    }
    throw new EucalyptusCloudException(ex);
  }
}
