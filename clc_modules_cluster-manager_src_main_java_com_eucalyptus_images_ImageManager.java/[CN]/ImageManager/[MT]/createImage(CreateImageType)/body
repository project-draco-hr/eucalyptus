{
  final CreateImageResponseType reply=request.getReply();
  final Context ctx=Contexts.lookup();
  verifyImageNameAndDescription(request.getName(),request.getDescription());
  VmInstance vm;
  try {
    vm=RestrictedTypes.doPrivileged(request.getInstanceId(),VmInstance.class);
    if (!vm.isBlockStorage())     throw new EucalyptusCloudException("Cannot create an image from an instance which is not booted from an EBS volume");
    if (!VmState.RUNNING.equals(vm.getState()) && !VmState.STOPPED.equals(vm.getState())) {
      throw new EucalyptusCloudException("Cannot create an image from an instance which is not in either the 'running' or 'stopped' state: " + vm.getInstanceId() + " is in state "+ vm.getState().getName());
    }
    Cluster cluster=null;
    try {
      ServiceConfiguration ccConfig=Topology.lookup(ClusterController.class,vm.lookupPartition());
      cluster=Clusters.lookup(ccConfig);
    }
 catch (    NoSuchElementException e) {
      LOG.debug(e);
      throw new EucalyptusCloudException("Cluster does not exist: " + vm.getPartition());
    }
  }
 catch (  AuthException ex) {
    throw new EucalyptusCloudException("Not authorized to create an image from instance " + request.getInstanceId() + " as "+ ctx.getUser().getName());
  }
catch (  NoSuchElementException ex) {
    throw new EucalyptusCloudException("Instance does not exist: " + request.getInstanceId(),ex);
  }
catch (  PersistenceException ex) {
    throw new EucalyptusCloudException("Instance does not exist: " + request.getInstanceId(),ex);
  }
  final String userId=ctx.getUser().getUserId();
  final String instanceId=request.getInstanceId();
  final String name=request.getName();
  final boolean noReboot=true ? request.getNoReboot() != null && request.getNoReboot().booleanValue() : false;
  final String desc=request.getDescription();
  String rootDeviceName=null;
  List<BlockDeviceMappingItemType> blockDevices=request.getBlockDeviceMappings();
  ImageMetadata.Architecture arch=null;
  ImageMetadata.Platform platform=null;
  try {
    final BlockStorageImageInfo image=Emis.LookupBlockStorage.INSTANCE.apply(vm.getImageId());
    arch=image.getArchitecture();
    platform=image.getPlatform();
    rootDeviceName=image.getRootDeviceName();
  }
 catch (  final Exception ex) {
    throw new EucalyptusCloudException("Unable to get the image information");
  }
  final ImageMetadata.Architecture imageArch=arch;
  final ImageMetadata.Platform imagePlatform=platform;
  if (blockDevices == null || blockDevices.size() <= 0) {
    try {
      blockDevices=Lists.transform(VmInstances.lookupEphemeralDevices(instanceId),VmInstances.EphemeralAttachmentToDevice);
    }
 catch (    final Exception ex) {
      LOG.warn("Failed to retrieve ephemeral device information",ex);
      blockDevices=Lists.newArrayList();
    }
  }
 else {
    for (    final BlockDeviceMappingItemType device : blockDevices) {
      if (rootDeviceName != null && rootDeviceName.equals(device.getDeviceName()))       throw new ClientComputeException("InvalidBlockDeviceMapping","The device names should not contain root device");
    }
    if (!bdmCreateImageVerifier().apply(request)) {
      throw new ClientComputeException("InvalidBlockDeviceMapping","A block device mapping parameter is not valid");
    }
  }
  final List<BlockDeviceMappingItemType> blockDeviceMapping=blockDevices;
  Supplier<ImageInfo> allocator=new Supplier<ImageInfo>(){
    @Override public ImageInfo get(){
      try {
        return Images.createPendingFromDeviceMapping(ctx.getUserFullName(),name,desc,imageArch,imagePlatform,blockDeviceMapping);
      }
 catch (      final Exception ex) {
        throw new RuntimeException(ex);
      }
    }
  }
;
  Predicate<ImageInfo> deallocator=new Predicate<ImageInfo>(){
    @Override public boolean apply(    @Nullable ImageInfo input){
      try {
        Images.setImageState(input.getDisplayName(),ImageMetadata.State.failed);
        Images.deregisterImage(input.getDisplayName());
      }
 catch (      final Exception ex) {
        LOG.error("failed to delete image from unsucccessful create-image request",ex);
        return false;
      }
      return true;
    }
  }
;
  ImageInfo imageInfo=null;
  try {
    imageInfo=RestrictedTypes.allocateUnitlessResource(allocator);
    reply.setImageId(imageInfo.getDisplayName());
  }
 catch (  final AuthException ex) {
    throw new ClientComputeException("AuthFailure","Not authorized to create an image");
  }
catch (  final Exception ex) {
    LOG.error("Unable to register the image",ex);
    throw new EucalyptusCloudException("Unable to register the image",ex);
  }
  final CreateImageTask task=new CreateImageTask(userId,instanceId,noReboot,blockDevices);
  try {
    task.create(imageInfo.getDisplayName());
  }
 catch (  final Exception ex) {
    deallocator.apply(imageInfo);
    LOG.error("CreateImage task failed",ex);
    if (ex instanceof EucalyptusCloudException)     throw (EucalyptusCloudException)ex;
 else     throw new EucalyptusCloudException("Create-image has failed",ex);
  }
  return reply;
}
