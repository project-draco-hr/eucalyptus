{
  try {
    Transactions.naturalId((T)this,new Callback<T>(){
      @Override public void fire(      T input){
        if (!ResourceAllocation.State.FREE.equals(input.getState())) {
          throw new RuntimeException("Error allocating resource " + PersistentResource.this.getClass().getSimpleName() + " with id "+ PersistentResource.this.getDisplayName()+ " as the state is not FREE (currently "+ PersistentResource.this.getState()+ ").");
        }
 else {
          PersistentResource.this.setState(ResourceAllocation.State.PENDING);
        }
      }
    }
);
  }
 catch (  TransactionException ex) {
    Logs.extreme().error(ex,ex);
  }
  return new ResourceAllocation.Reference<T,R>(){
    private volatile boolean finished=false;
    @Override public T set(    R referer){
      this.checkFinished();
      try {
        T ret=PersistentResource.this.doSetReferer(referer);
        this.finished=true;
        return ret;
      }
 catch (      TransactionException ex) {
        throw new UndeclaredThrowableException(ex);
      }
    }
    private void checkFinished() throws RuntimeException {
      if (this.finished) {
        throw new RuntimeException("Failed to set referer since this reference has already been set: " + PersistentResource.this.getDisplayName() + " to "+ PersistentResource.this.getReferer()+ " and is currently in state "+ PersistentResource.this.getState());
      }
    }
    @Override public T abort(){
      this.checkFinished();
      try {
        T ret=PersistentResource.this.doClearReferer();
        this.finished=true;
        return ret;
      }
 catch (      TransactionException ex) {
        throw new UndeclaredThrowableException(ex);
      }
    }
  }
;
}
