{
  final List<SearchResultRow> results=Lists.newArrayList();
  try {
    final AuthContext authContext=authContext(requestUser);
    if (query.hasOnlySingle(USERID)) {
      User user=Accounts.lookupUserById(query.getSingle(USERID).getValue());
      Account account=user.getAccount();
      for (      AccessKey key : Privileged.listAccessKeys(authContext,account,user)) {
        results.add(serializeKey(key,account,user));
      }
    }
 else {
      forAllUsers(getAccounts(query),false,new IdentityCallback<User>(){
        @Override public void doWithIdentities(        final Map<String,Account> accountsById,        final Map<String,User> usersById,        final List<String> userIds) throws AuthException {
          final Map<String,List<AccessKey>> accessKeysByUserId=Accounts.listAccessKeysForUsers(userIds);
          for (          final Map.Entry<String,List<AccessKey>> entry : accessKeysByUserId.entrySet()) {
            final User user=usersById.get(entry.getKey());
            if (user == null)             continue;
            final Account account=accountsById.get(user.getAccountNumber());
            if (userListingMatchQuery(user,query) && Privileged.allowListAccessKeys(authContext,account,user)) {
              for (              AccessKey key : entry.getValue())               if (keyMatchQuery(key,query)) {
                results.add(serializeKey(key,account,user));
              }
            }
          }
        }
      }
);
    }
  }
 catch (  Exception e) {
    LOG.error("Failed to get keys",e);
    LOG.debug(e,e);
    throw new EucalyptusServiceException("Failed to get keys for query " + query + ": "+ e.getMessage());
  }
  return results;
}
