{
  Table<String,String,Boolean> clonedEdgeTable=HashBasedTable.create(edgeTable);
  List<String> sortedElements=Lists.newArrayList();
  Set<String> nodesWithNoIncomingEdges=Sets.newHashSet();
  for (  String node : nodes) {
    if (clonedEdgeTable.column(node).isEmpty()) {
      nodesWithNoIncomingEdges.add(node);
    }
  }
  while (!nodesWithNoIncomingEdges.isEmpty()) {
    String internalNode=nodesWithNoIncomingEdges.iterator().next();
    nodesWithNoIncomingEdges.remove(internalNode);
    sortedElements.add(internalNode);
    Set<String> destinationsFromInternalNode=Sets.newHashSet(clonedEdgeTable.row(internalNode).keySet());
    for (    String destinationNode : destinationsFromInternalNode) {
      clonedEdgeTable.remove(internalNode,destinationNode);
      if (clonedEdgeTable.column(destinationNode).isEmpty()) {
        nodesWithNoIncomingEdges.add(destinationNode);
      }
    }
  }
  if (clonedEdgeTable.isEmpty()) {
    return sortedElements;
  }
 else {
    throw new ValidationErrorException("One or more cyclic dependencies exist in Resource References");
  }
}
