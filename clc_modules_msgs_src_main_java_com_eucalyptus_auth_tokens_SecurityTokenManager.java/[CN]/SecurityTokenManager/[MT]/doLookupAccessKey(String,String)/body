{
  Preconditions.checkNotNull(accessKeyId,"Access key identifier is required");
  Preconditions.checkNotNull(token,"Token is required");
  final EncryptedSecurityToken encryptedToken;
  try {
    final Pair<String,String> tokenKey=Pair.pair(accessKeyId,token);
    encryptedToken=tokenCache.get(tokenKey,new Callable<EncryptedSecurityToken>(){
      @Override public EncryptedSecurityToken call() throws Exception {
        return EncryptedSecurityToken.decrypt(accessKeyId,getEncryptionKey(accessKeyId),token);
      }
    }
);
  }
 catch (  ExecutionException e) {
    log.debug(e,e);
    throw new InvalidAccessKeyAuthException("Invalid security token");
  }
  final String originatingAccessKeyId=encryptedToken.getOriginatingAccessKeyId();
  final String userId=encryptedToken.getUserId();
  final boolean active;
  final String secretKey;
  final User user;
  final TemporaryKeyType type;
  if (originatingAccessKeyId != null) {
    final AccessKey key=lookupAccessKeyById(originatingAccessKeyId);
    active=key.isActive();
    secretKey=encryptedToken.getSecretKey(key.getSecretKey());
    user=key.getUser();
    type=TemporaryKeyType.Session;
  }
 else   if (userId != null) {
    user=lookupUserById(encryptedToken.getUserId());
    active=user.isEnabled();
    secretKey=encryptedToken.getSecretKey(Objects.firstNonNull(user.getToken(),""));
    type=TemporaryKeyType.Access;
  }
 else {
    final Role role=lookupRoleById(encryptedToken.getRoleId());
    user=roleAsUser(role);
    active=true;
    secretKey=encryptedToken.getSecretKey(role.getSecret());
    type=TemporaryKeyType.Role;
  }
  return new TemporaryAccessKey(){
    private static final long serialVersionUID=1L;
    @Override public Boolean isActive(){
      return active && encryptedToken.isValid();
    }
    @Override public String getAccessKey(){
      return encryptedToken.getAccessKeyId();
    }
    @Override public String getSecurityToken(){
      return token;
    }
    @Override public String getSecretKey(){
      return secretKey;
    }
    @Override public TemporaryKeyType getType(){
      return type;
    }
    @Override public Date getCreateDate(){
      return new Date(encryptedToken.getCreated());
    }
    @Override public Date getExpiryDate(){
      return new Date(encryptedToken.getExpires());
    }
    @Override public User getUser() throws AuthException {
      return user;
    }
    @Override public void setActive(    final Boolean active) throws AuthException {
    }
  }
;
}
