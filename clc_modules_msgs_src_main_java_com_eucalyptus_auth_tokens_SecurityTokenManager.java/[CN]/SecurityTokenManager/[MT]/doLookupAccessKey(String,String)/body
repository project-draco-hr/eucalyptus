{
  Preconditions.checkNotNull(accessKeyId,"Access key identifier is required");
  Preconditions.checkNotNull(token,"Token is required");
  final EncryptedSecurityToken encryptedToken;
  try {
    encryptedToken=EncryptedSecurityToken.decrypt(accessKeyId,getEncryptionKey(accessKeyId),token);
  }
 catch (  GeneralSecurityException e) {
    log.debug(e,e);
    throw new AuthException("Invalid security token");
  }
  final AccessKey key=lookupAccessKeyById(encryptedToken.getOriginatingAccessKeyId());
  final String secretKey=encryptedToken.getSecretKey(key.getSecretKey());
  return new AccessKey(){
    @Override public Boolean isActive(){
      return key.isActive() && encryptedToken.isValid();
    }
    @Override public String getAccessKey(){
      return encryptedToken.getAccessKeyId();
    }
    @Override public String getSecretKey(){
      return secretKey;
    }
    @Override public Date getCreateDate(){
      return new Date(encryptedToken.getCreated());
    }
    @Override public User getUser() throws AuthException {
      return key.getUser();
    }
    @Override public void setActive(    final Boolean active) throws AuthException {
    }
    @Override public void setCreateDate(    final Date createDate) throws AuthException {
    }
  }
;
}
