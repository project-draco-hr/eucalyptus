{
  GetObjectResponseType reply=(GetObjectResponseType)request.getReply();
  String bucketName=request.getBucket();
  String objectKey=request.getKey();
  String userId=request.getUserId();
  Boolean deleteAfterGet=request.getDeleteAfterGet();
  if (deleteAfterGet == null)   deleteAfterGet=false;
  Boolean getTorrent=request.getGetTorrent();
  if (getTorrent == null)   getTorrent=false;
  Boolean getMetaData=request.getGetMetaData();
  if (getMetaData == null)   getMetaData=false;
  EntityWrapper<BucketInfo> db=new EntityWrapper<BucketInfo>();
  BucketInfo bucketInfo=new BucketInfo(bucketName);
  List<BucketInfo> bucketList=db.query(bucketInfo);
  if (bucketList.size() > 0) {
    EntityWrapper<ObjectInfo> dbObject=db.recast(ObjectInfo.class);
    ObjectInfo searchObjectInfo=new ObjectInfo(bucketName,objectKey);
    List<ObjectInfo> objectInfos=dbObject.query(searchObjectInfo);
    if (objectInfos.size() > 0) {
      ObjectInfo objectInfo=objectInfos.get(0);
      if (objectInfo.canRead(userId)) {
        String objectName=objectInfo.getObjectName();
        if (getMetaData) {
          ArrayList<MetaDataEntry> metaData=new ArrayList<MetaDataEntry>();
          objectInfo.returnMetaData(metaData);
          reply.setMetaData(metaData);
          reply.setMetaData(metaData);
        }
        if (getTorrent) {
          if (objectInfo.isGlobalRead()) {
            if (!WalrusProperties.enableTorrents) {
              LOG.warn("Bittorrent support has been disabled. Please check pre-requisites");
              throw new EucalyptusCloudException("Torrents disabled");
            }
            EntityWrapper<TorrentInfo> dbTorrent=new EntityWrapper<TorrentInfo>();
            TorrentInfo torrentInfo=new TorrentInfo(bucketName,objectKey);
            TorrentInfo foundTorrentInfo;
            String absoluteObjectPath=storageManager.getObjectPath(bucketName,objectName);
            try {
              foundTorrentInfo=dbTorrent.getUnique(torrentInfo);
            }
 catch (            EucalyptusCloudException ex) {
              String torrentFile=objectName + ".torrent";
              String torrentFilePath=storageManager.getObjectPath(bucketName,torrentFile);
              TorrentCreator torrentCreator=new TorrentCreator(absoluteObjectPath,objectKey,objectName,torrentFilePath,WalrusProperties.TRACKER_URL);
              try {
                torrentCreator.create();
              }
 catch (              Exception e) {
                LOG.error(e);
                throw new EucalyptusCloudException("could not create torrent file " + torrentFile);
              }
              torrentInfo.setTorrentFile(torrentFile);
              dbTorrent.add(torrentInfo);
              foundTorrentInfo=torrentInfo;
            }
            dbTorrent.commit();
            String torrentFile=foundTorrentInfo.getTorrentFile();
            String torrentFilePath=storageManager.getObjectPath(bucketName,torrentFile);
            TorrentClient torrentClient=new TorrentClient(torrentFilePath,absoluteObjectPath);
            Torrents.addClient(bucketName + objectKey,torrentClient);
            torrentClient.start();
            String key=bucketName + "." + objectKey;
            String randomKey=key + "." + Hashes.getRandom(10);
            request.setRandomKey(randomKey);
            LinkedBlockingQueue<WalrusDataMessage> getQueue=null;
            File torrent=new File(torrentFilePath);
            if (torrent.exists()) {
              long torrentLength=torrent.length();
              ObjectReader reader=new ObjectReader(bucketName,torrentFile,torrentLength,getQueue,false,null,storageManager);
              reader.start();
              reply.setEtag("");
              reply.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(),DateUtils.ISO8601_DATETIME_PATTERN));
              reply.setSize(torrentLength);
              Status status=new Status();
              status.setCode(200);
              status.setDescription("OK");
              reply.setStatus(status);
              reply.setContentType("binary/octet-stream");
              db.commit();
              return reply;
            }
 else {
              String errorString="Could not get torrent file " + torrentFilePath;
              LOG.error(errorString);
              throw new EucalyptusCloudException(errorString);
            }
          }
 else {
            db.rollback();
            throw new AccessDeniedException(objectKey);
          }
        }
        if (request.getGetData()) {
          if (request.getInlineData()) {
            try {
              byte[] bytes=new byte[102400];
              int bytesRead=0;
              String base64Data="";
              while ((bytesRead=storageManager.readObject(bucketName,objectName,bytes,bytesRead)) > 0) {
                base64Data+=new String(bytes,0,bytesRead);
              }
              reply.setBase64Data(base64Data);
            }
 catch (            IOException ex) {
              db.rollback();
              LOG.error(ex);
              return reply;
            }
          }
 else {
            String key=bucketName + "." + objectKey;
            String randomKey=key + "." + Hashes.getRandom(10);
            request.setRandomKey(randomKey);
            LinkedBlockingQueue<WalrusDataMessage> getQueue=null;
            ObjectReader reader=new ObjectReader(bucketName,objectName,objectInfo.getSize(),getQueue,deleteAfterGet,null,storageManager);
            reader.start();
          }
        }
        reply.setEtag(objectInfo.getEtag());
        reply.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(),DateUtils.ISO8601_DATETIME_PATTERN + ".000Z"));
        reply.setSize(objectInfo.getSize());
        reply.setContentType(objectInfo.getContentType());
        reply.setContentDisposition(objectInfo.getContentDisposition());
        Status status=new Status();
        status.setCode(200);
        status.setDescription("OK");
        reply.setStatus(status);
        db.commit();
        return reply;
      }
 else {
        db.rollback();
        throw new AccessDeniedException(objectKey);
      }
    }
 else {
      db.rollback();
      throw new NoSuchEntityException(objectKey);
    }
  }
 else {
    db.rollback();
    throw new NoSuchBucketException(bucketName);
  }
}
