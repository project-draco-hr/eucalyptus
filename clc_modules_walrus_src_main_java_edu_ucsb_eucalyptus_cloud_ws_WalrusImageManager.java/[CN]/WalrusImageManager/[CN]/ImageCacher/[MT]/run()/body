{
  String decryptedImageName=storageManager.getObjectPath(bucketName,decryptedImageKey);
  String imageName=decryptedImageName.substring(0,decryptedImageName.lastIndexOf(".tgz"));
  String tarredImageName=imageName + (".tar");
  String imageKey=decryptedImageKey.substring(0,decryptedImageKey.lastIndexOf(".tgz"));
  Long unencryptedSize;
  int numberOfRetries=0;
  while ((unencryptedSize=tryToCache(decryptedImageName,tarredImageName,imageName)) < 0) {
    try {
      Thread.sleep(WalrusProperties.IMAGE_CACHE_RETRY_TIMEOUT);
    }
 catch (    InterruptedException ex) {
      notifyWaiters();
      return;
    }
    WalrusProperties.IMAGE_CACHE_RETRY_TIMEOUT=2 * WalrusProperties.IMAGE_CACHE_RETRY_TIMEOUT;
    if (numberOfRetries++ >= WalrusProperties.IMAGE_CACHE_RETRY_LIMIT) {
      notifyWaiters();
      return;
    }
    EntityWrapper<ImageCacheInfo> db=EntityWrapper.get(ImageCacheInfo.class);
    ImageCacheInfo searchImageCacheInfo=new ImageCacheInfo();
    searchImageCacheInfo.setInCache(true);
    List<ImageCacheInfo> imageCacheInfos=db.queryEscape(searchImageCacheInfo);
    if (imageCacheInfos.size() == 0) {
      LOG.error("No cached images found to flush. Unable to cache image. Please check the error log and the image cache size.");
      db.rollback();
      notifyWaiters();
      return;
    }
    Collections.sort(imageCacheInfos);
    db.commit();
    try {
      if (spaceNeeded > 0) {
        ArrayList<ImageCacheInfo> imagesToFlush=new ArrayList<ImageCacheInfo>();
        long tryToFree=spaceNeeded;
        for (        ImageCacheInfo imageCacheInfo : imageCacheInfos) {
          if (tryToFree <= 0)           break;
          long imageSize=imageCacheInfo.getSize();
          tryToFree-=imageSize;
          imagesToFlush.add(imageCacheInfo);
        }
        if (imagesToFlush.size() == 0) {
          LOG.error("Unable to flush existing images. Sorry.");
          notifyWaiters();
          return;
        }
        for (        ImageCacheInfo imageCacheInfo : imagesToFlush) {
          flushCachedImage(imageCacheInfo.getBucketName(),imageCacheInfo.getManifestName());
        }
      }
 else {
        LOG.error("Unable to cache image. Unable to flush existing images.");
        notifyWaiters();
        return;
      }
    }
 catch (    Exception ex) {
      LOG.error(ex);
      LOG.error("Unable to flush previously cached image. Please increase your image cache size");
      notifyWaiters();
    }
  }
  try {
    storageManager.deleteAbsoluteObject(decryptedImageName);
    storageManager.deleteAbsoluteObject(tarredImageName);
    EntityWrapper<ImageCacheInfo> db=EntityWrapper.get(ImageCacheInfo.class);
    ImageCacheInfo searchImageCacheInfo=new ImageCacheInfo(bucketName,manifestKey);
    List<ImageCacheInfo> foundImageCacheInfos=db.queryEscape(searchImageCacheInfo);
    if (foundImageCacheInfos.size() > 0) {
      ImageCacheInfo foundImageCacheInfo=foundImageCacheInfos.get(0);
      foundImageCacheInfo.setImageName(imageKey);
      foundImageCacheInfo.setInCache(true);
      foundImageCacheInfo.setSize(unencryptedSize);
      db.commit();
    }
 else {
      db.rollback();
      LOG.error("Could not expand image" + decryptedImageName);
    }
  }
 catch (  Exception ex) {
    LOG.error(ex);
  }
  notifyWaiters();
}
