def save(self):
    '\n        Write the current dictionary back to the config file.  This function\n        is now very sensitive to duplicate keys, and will try to preserve\n        key/value pairs in comments if there is already an uncommented line\n        containing the same key.\n        '
    unseenKeys = self.keys()
    if (not self._dirty):
        return
    if (not os.access(self.path, os.W_OK)):
        raise IOError(("You don't have write access to %s" % self.path))
    self._backup()
    idx = 0
    while (idx < len(self._content)):
        line = self._content[idx]
        if line.startswith('#'):
            m = ckvRE.match(line)
            if m:
                match = m.groups()
                if (self.has_key(match[1]) and (match[1] not in self._ordered_key_list) and (match[1] in unseenKeys)):
                    self._content[idx] = match[0].replace(match[2], self[match[1]])
                    unseenKeys.pop(unseenKeys.index(match[1]))
        elif re.match('^\\s*$', line):
            pass
        else:
            m = kvRE.match(line)
            if (not m):
                idx += 1
                continue
            match = m.groups()
            if (not self.has_key(match[0])):
                self._content[idx] = ('# ' + line)
            elif (self._ordered_key_list.count(match[0]) > 1):
                self._content[idx] = ('# ' + line)
                self._ordered_key_list.pop(self._ordered_key_list.index(match[0]))
            else:
                if (self[match[0]] != match[1]):
                    self._content[idx] = line.replace(('"%s"' % match[1]), ('"%s"' % self[match[0]]))
                unseenKeys.pop(unseenKeys.index(match[0]))
        idx += 1
    for key in unseenKeys:
        self._content.append(('%s="%s"' % (key, self[key])))
    open(self.path, 'w').write(('\n'.join(self._content) + '\n'))
    self._dirty = False
