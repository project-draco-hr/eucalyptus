{
  final List<String> instancesToTerminate=Lists.newArrayList();
  int currentCapacity=0;
  try {
    final List<AutoScalingInstance> currentInstances=autoScalingInstances.listByGroup(group);
    currentCapacity=currentInstances.size();
    if (currentInstances.size() == terminateCount) {
      Iterables.addAll(instancesToTerminate,Iterables.transform(currentInstances,AutoScalingInstances.instanceId()));
    }
 else {
      final Set<String> unwantedZones=Sets.newHashSet(Iterables.transform(currentInstances,availabilityZone()));
      unwantedZones.removeAll(group.getAvailabilityZones());
      final Set<String> targetZones;
      final List<AutoScalingInstance> remainingInstances=Lists.newArrayList(currentInstances);
      if (!unwantedZones.isEmpty()) {
        int unwantedInstanceCount=CollectionUtils.reduce(currentInstances,0,CollectionUtils.count(withAvailabilityZone(unwantedZones)));
        if (unwantedInstanceCount < terminateCount) {
          Iterable<AutoScalingInstance> unwantedInstances=Iterables.filter(currentInstances,withAvailabilityZone(unwantedZones));
          Iterables.addAll(instancesToTerminate,Iterables.transform(unwantedInstances,instanceId()));
          Iterables.removeAll(remainingInstances,Lists.newArrayList(unwantedInstances));
          targetZones=group.getAvailabilityZones();
        }
 else {
          targetZones=unwantedZones;
        }
      }
 else {
        targetZones=group.getAvailabilityZones();
      }
      final Map<String,Integer> zoneCounts=buildAvailabilityZoneInstanceCounts(currentInstances,targetZones);
      for (int i=instancesToTerminate.size(); i < terminateCount && remainingInstances.size() >= 1; i++) {
        final Map.Entry<String,Integer> entry=selectEntry(zoneCounts,Ordering.natural().reverse());
        final AutoScalingInstance instanceForTermination=TerminationPolicyType.selectForTermination(group.getTerminationPolicies(),Lists.newArrayList(Iterables.filter(remainingInstances,withAvailabilityZone(entry.getKey()))));
        remainingInstances.remove(instanceForTermination);
        entry.setValue(entry.getValue() - 1);
        instancesToTerminate.add(instanceForTermination.getInstanceId());
      }
    }
  }
 catch (  final Exception e) {
    logger.error(e,e);
  }
  return new TerminateInstancesScalingProcessTask(group,currentCapacity,instancesToTerminate,false);
}
