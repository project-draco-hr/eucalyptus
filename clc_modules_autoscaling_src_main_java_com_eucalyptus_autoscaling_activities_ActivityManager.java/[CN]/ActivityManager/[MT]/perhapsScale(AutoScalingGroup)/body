{
  final List<AutoScalingInstance> currentInstances;
  try {
    currentInstances=autoScalingInstances.listByGroup(group);
  }
 catch (  final Exception e) {
    logger.error(e,e);
    return new LaunchInstancesScalingProcessTask(group,0);
  }
  if (group.getCapacity() > group.getDesiredCapacity()) {
    if (!Iterables.all(currentInstances,Predicates.and(LifecycleState.InService,ConfigurationState.Registered,HealthStatus.Healthy))) {
      return new LaunchInstancesScalingProcessTask(group,0);
    }
    return perhapsTerminateInstances(group,group.getCapacity() - group.getDesiredCapacity());
  }
 else {
    final List<String> zones=Lists.transform(currentInstances,AutoScalingInstances.availabilityZone());
    final Set<String> groupZones=Sets.newLinkedHashSet(group.getAvailabilityZones());
    groupZones.removeAll(zoneMonitor.getUnavailableZones(zoneFailureThreshold));
    final int expectedInstancesPerZone=group.getCapacity() / Math.max(1,groupZones.size());
    int requiredInstances=0;
    for (    final String zone : groupZones) {
      int instanceCount=CollectionUtils.reduce(zones,0,CollectionUtils.count(Predicates.equalTo(zone)));
      if (instanceCount < expectedInstancesPerZone) {
        requiredInstances+=expectedInstancesPerZone - instanceCount;
      }
    }
    final int hardInstanceLimit=group.getDesiredCapacity() + Math.max(1,group.getDesiredCapacity() / 10);
    if (requiredInstances + group.getCapacity() > hardInstanceLimit) {
      requiredInstances=hardInstanceLimit - group.getCapacity();
    }
 else     if (requiredInstances + group.getCapacity() < group.getDesiredCapacity()) {
      requiredInstances=group.getDesiredCapacity() - group.getCapacity();
    }
    if (requiredInstances == 0) {
      setScalingNotRequired(group);
    }
 else     if (!ScalingProcessType.AZRebalance.apply(group) && group.getCapacity().equals(group.getDesiredCapacity())) {
      requiredInstances=0;
    }
    return new LaunchInstancesScalingProcessTask(group,requiredInstances);
  }
}
