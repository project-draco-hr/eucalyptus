{
  try {
    Channel channel=request.getChannel();
    httpResponse.addHeader(HttpHeaders.Names.CONTENT_TYPE,contentType != null ? contentType : "binary/octet-stream");
    if (etag != null)     httpResponse.addHeader(HttpHeaders.Names.ETAG,etag);
    httpResponse.addHeader(HttpHeaders.Names.LAST_MODIFIED,lastModified);
    if (contentDisposition != null)     httpResponse.addHeader("Content-Disposition",contentDisposition);
    if (versionId != null) {
      httpResponse.addHeader(WalrusProperties.X_AMZ_VERSION_ID,versionId);
    }
    channel.write(httpResponse);
    for (    PartInfo part : parts) {
      isCompressed=isCompressed == null ? false : isCompressed;
      final ChunkedInput file;
      RandomAccessFile raf=new RandomAccessFile(new File(getObjectPath(part.getBucketName(),part.getObjectName())),"r");
      if (isCompressed) {
        file=new CompressedChunkedFile(raf,size);
      }
 else {
        file=new ChunkedDataFile(raf,0,size,8192);
        httpResponse.addHeader(HttpHeaders.Names.CONTENT_LENGTH,String.valueOf(size));
      }
      channel.write(file).addListener(new ChannelFutureListener(){
        @Override public void operationComplete(        ChannelFuture future) throws Exception {
          file.close();
        }
      }
);
    }
  }
 catch (  Exception ex) {
    LOG.error(ex,ex);
  }
}
