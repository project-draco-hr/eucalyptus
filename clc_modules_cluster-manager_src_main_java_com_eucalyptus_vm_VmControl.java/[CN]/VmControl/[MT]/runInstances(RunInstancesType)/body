{
  RunInstancesResponseType reply=request.getReply();
  Allocation allocInfo=Allocations.run(request);
  final EntityTransaction db=Entities.get(VmInstance.class);
  try {
    if (!Strings.isNullOrEmpty(allocInfo.getClientToken())) {
      final List<VmInstance> instances=VmInstances.listByClientToken(allocInfo.getOwnerFullName().asAccountFullName(),allocInfo.getClientToken(),RestrictedTypes.filterPrivileged());
      if (!instances.isEmpty()) {
        final VmInstance vm=instances.get(0);
        final ReservationInfoType reservationInfoType=TypeMappers.transform(vm,ReservationInfoType.class);
        Iterables.addAll(reservationInfoType.getInstancesSet(),Iterables.transform(instances,TypeMappers.lookup(VmInstance.class,RunningInstancesItemType.class)));
        reply.setRsvInfo(reservationInfoType);
        return reply;
      }
    }
    Predicates.and(VerifyMetadata.get(),AdmissionControl.run(),ContractEnforcement.run()).apply(allocInfo);
    allocInfo.commit();
    ReservationInfoType reservation=new ReservationInfoType(allocInfo.getReservationId(),allocInfo.getOwnerFullName().getAccountNumber(),allocInfo.getNetworkGroupsMap());
    reply.setRsvInfo(reservation);
    for (    ResourceToken allocToken : allocInfo.getAllocationTokens()) {
      VmInstance entity=Entities.merge(allocToken.getVmInstance());
      reservation.getInstancesSet().add(VmInstances.transform(entity));
    }
    db.commit();
  }
 catch (  Exception ex) {
    LOG.error(ex,ex);
    allocInfo.abort();
    throw ex;
  }
 finally {
    if (db.isActive())     db.rollback();
  }
  ClusterAllocator.get().apply(allocInfo);
  return reply;
}
