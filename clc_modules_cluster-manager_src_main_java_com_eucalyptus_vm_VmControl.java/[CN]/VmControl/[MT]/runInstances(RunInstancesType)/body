{
  RunInstancesResponseType reply=request.getReply();
  Allocation allocInfo=Allocations.run(request);
  final EntityTransaction db=Entities.get(VmInstance.class);
  try {
    if (!Strings.isNullOrEmpty(allocInfo.getClientToken())) {
      final List<VmInstance> instances=VmInstances.listByClientToken(allocInfo.getOwnerFullName().asAccountFullName(),allocInfo.getClientToken(),RestrictedTypes.filterPrivileged());
      if (!instances.isEmpty()) {
        final VmInstance vm=instances.get(0);
        final ReservationInfoType reservationInfoType=TypeMappers.transform(vm,ReservationInfoType.class);
        for (        final VmInstance instance : instances) {
          reservationInfoType.getInstancesSet().add(VmInstance.transform(instance));
        }
        reply.setRsvInfo(reservationInfoType);
        return reply;
      }
    }
    Predicates.and(VerifyMetadata.get(),AdmissionControl.run(),ContractEnforcement.run()).apply(allocInfo);
    allocInfo.commit();
    ReservationInfoType reservation=new ReservationInfoType(allocInfo.getReservationId(),allocInfo.getOwnerFullName().getAccountNumber(),Collections2.transform(allocInfo.getNetworkGroups(),TypeMappers.lookup(NetworkGroup.class,GroupItemType.class)));
    reply.setRsvInfo(reservation);
    for (    ResourceToken allocToken : allocInfo.getAllocationTokens()) {
      reservation.getInstancesSet().add(VmInstance.transform(allocToken.getVmInstance()));
    }
    db.commit();
  }
 catch (  Exception ex) {
    allocInfo.abort();
    final ImageInstanceTypeVerificationException e1=Exceptions.findCause(ex,ImageInstanceTypeVerificationException.class);
    if (e1 != null)     throw new ClientComputeException("InvalidParameterCombination",e1.getMessage());
    final NotEnoughResourcesException e2=Exceptions.findCause(ex,NotEnoughResourcesException.class);
    if (e2 != null)     throw new ComputeException("InsufficientInstanceCapacity",e2.getMessage());
    final NoSuchKeyMetadataException e3=Exceptions.findCause(ex,NoSuchKeyMetadataException.class);
    if (e3 != null)     throw new ClientComputeException("InvalidKeyPair.NotFound",e3.getMessage());
    final InvalidMetadataException e4=Exceptions.findCause(ex,InvalidMetadataException.class);
    if (e4 instanceof VpcRequiredMetadataException) {
      throw new ClientComputeException("VPCIdNotSpecified","Default VPC not found, please specify a subnet.");
    }
    if (e4 instanceof InvalidParameterCombinationMetadataException) {
      throw new ClientComputeException("InvalidParameterCombination",e4.getMessage());
    }
    if (e4 != null)     throw new ClientComputeException("InvalidParameterValue",e4.getMessage());
    final NoSuchImageIdException e5=Exceptions.findCause(ex,NoSuchImageIdException.class);
    if (e5 != null)     throw new ClientComputeException("InvalidAMIID.NotFound",e5.getMessage());
    final NoSuchSubnetMetadataException e6=Exceptions.findCause(ex,NoSuchSubnetMetadataException.class);
    if (e6 != null)     throw new ClientComputeException("InvalidSubnetID.NotFound",e6.getMessage());
    final IllegalMetadataAccessException e7=Exceptions.findCause(ex,IllegalMetadataAccessException.class);
    if (e7 != null)     throw new ClientUnauthorizedComputeException(e7.getMessage());
    final SecurityGroupLimitMetadataException e8=Exceptions.findCause(ex,SecurityGroupLimitMetadataException.class);
    if (e8 != null)     throw new ClientComputeException("SecurityGroupLimitExceeded","Security group limit exceeded");
    LOG.error(ex,ex);
    throw ex;
  }
 finally {
    if (db.isActive())     db.rollback();
  }
  MessageContexts.remember(allocInfo.getReservationId(),request.getClass(),request);
  for (  final ResourceToken allocToken : allocInfo.getAllocationTokens()) {
    MessageContexts.remember(allocToken.getInstanceId(),request.getClass(),request);
  }
  ClusterAllocator.get().apply(allocInfo);
  return reply;
}
