{
  Callable<CheckedListenableFuture<ServiceConfiguration>> transition;
  try {
switch (goalState) {
case LOADED:
      return executeTransition(configuration,Automata.sequenceTransitions(configuration,pathToLoaded(configuration.lookupState())));
case DISABLED:
    return executeTransition(configuration,Automata.sequenceTransitions(configuration,pathToDisabled(configuration.lookupState())));
case ENABLED:
  return executeTransition(configuration,Automata.sequenceTransitions(configuration,pathToEnabled(configuration.lookupState())));
case STOPPED:
return executeTransition(configuration,Automata.sequenceTransitions(configuration,pathToStopped(configuration.lookupState())));
case NOTREADY:
return executeTransition(configuration,Automata.sequenceTransitions(configuration,pathToStarted(configuration.lookupState())));
case PRIMORDIAL:
return executeTransition(configuration,Automata.sequenceTransitions(configuration,pathToPrimordial(configuration.lookupState())));
default :
return Futures.predestinedFuture(configuration);
}
}
 catch (RuntimeException ex) {
Logs.extreme().error(ex,ex);
LOG.error(configuration.getFullName() + " failed to transition to " + goalState+ " because of: "+ Exceptions.causeString(ex));
throw ex;
}
}
