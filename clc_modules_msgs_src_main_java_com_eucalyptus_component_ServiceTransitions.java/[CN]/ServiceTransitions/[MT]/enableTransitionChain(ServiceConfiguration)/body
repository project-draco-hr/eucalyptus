{
  final Service service=config.lookupService();
  Callable<CheckedListenableFuture<ServiceConfiguration>> transition=null;
switch (service.getState()) {
case ENABLED:
    break;
case NOTREADY:
case DISABLED:
  transition=Automata.chainedTransition(config,Component.State.DISABLED,Component.State.ENABLED);
break;
case LOADED:
case STOPPED:
transition=Automata.chainedTransition(config,Component.State.LOADED,Component.State.NOTREADY,Component.State.DISABLED,Component.State.ENABLED);
break;
case INITIALIZED:
transition=Automata.chainedTransition(config,Component.State.INITIALIZED,Component.State.LOADED,Component.State.NOTREADY,Component.State.DISABLED,Component.State.ENABLED);
break;
default :
throw new IllegalStateException("Failed to find transition for current component state: " + config.lookupComponent().toString());
}
CheckedListenableFuture<ServiceConfiguration> transitionResult=null;
try {
transitionResult=Threads.lookup(Empyrean.class).submit(transition).get();
}
 catch (InterruptedException ex) {
LOG.error(ex,ex);
transitionResult=Futures.predestinedFailedFuture(ex);
}
catch (ExecutionException ex) {
LOG.error(ex.getCause(),ex.getCause());
transitionResult=Futures.predestinedFailedFuture(ex.getCause());
}
return transitionResult;
}
