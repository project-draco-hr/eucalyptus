{
  final CreateAutoScalingGroupResponseType reply=request.getReply();
  final Context ctx=Contexts.lookup();
  final Supplier<AutoScalingGroup> allocator=new Supplier<AutoScalingGroup>(){
    @Override public AutoScalingGroup get(){
      try {
        final AutoScalingGroups.PersistingBuilder builder=autoScalingGroups.create(ctx.getUserFullName(),request.getAutoScalingGroupName(),launchConfigurations.lookup(ctx.getUserFullName().asAccountFullName(),request.getLaunchConfigurationName()),Numbers.intValue(request.getMinSize()),Numbers.intValue(request.getMaxSize())).withAvailabilityZones(request.availabilityZones()).withDefaultCooldown(Numbers.intValue(request.getDefaultCooldown())).withDesiredCapacity(Numbers.intValue(request.getDesiredCapacity())).withHealthCheckGracePeriod(Numbers.intValue(request.getHealthCheckGracePeriod())).withHealthCheckType(request.getHealthCheckType() == null ? null : HealthCheckType.valueOf(request.getHealthCheckType())).withLoadBalancerNames(request.loadBalancerNames()).withTerminationPolicyTypes(request.terminationPolicies() == null ? null : Collections2.filter(Collections2.transform(request.terminationPolicies(),Enums.valueOfFunction(TerminationPolicyType.class)),Predicates.not(Predicates.isNull())));
        final List<String> referenceErrors=activityManager.validateReferences(ctx.getUserFullName(),request.availabilityZones());
        if (!referenceErrors.isEmpty()) {
          throw Exceptions.toUndeclared(new InvalidParameterValueException("Invalid parameters " + referenceErrors));
        }
        return builder.persist();
      }
 catch (      AutoScalingMetadataNotFoundException e) {
        throw Exceptions.toUndeclared(new InvalidParameterValueException("Launch configuration not found: " + request.getLaunchConfigurationName()));
      }
catch (      IllegalArgumentException e) {
        throw Exceptions.toUndeclared(new InvalidParameterValueException("Invalid health check type: " + request.getHealthCheckType()));
      }
catch (      Exception ex) {
        throw new RuntimeException(ex);
      }
    }
  }
;
  try {
    RestrictedTypes.allocateUnitlessResource(allocator);
  }
 catch (  Exception e) {
    handleException(e,true);
  }
  return reply;
}
