{
  final SshKeyPair keyPair=this.allocInfo.getSshKeyPair();
  final VmKeyInfo vmKeyInfo=new VmKeyInfo(keyPair.getName(),keyPair.getPublicKey(),keyPair.getFingerPrint());
  final String platform=this.allocInfo.getBootSet().getMachine().getPlatform().name() != null ? this.allocInfo.getBootSet().getMachine().getPlatform().name() : "linux";
  ExtantNetwork exNet;
  try {
    exNet=this.allocInfo.getPrimaryNetwork().extantNetwork();
  }
 catch (  NotEnoughResourcesAvailable ex) {
    Logs.extreme().error(ex,ex);
    exNet=ExtantNetwork.bogus(this.allocInfo.getPrimaryNetwork());
  }
  final VmRunType run=VmRunType.builder().instanceId(childToken.getInstanceId()).instanceId(childToken.getInstanceUuid()).keyInfo(vmKeyInfo).launchIndex(childToken.getLaunchIndex()).networkIndex(childToken.getNetworkIndex().get().getIndex()).networkNames(this.allocInfo.getNetworkGroups()).platform(platform).reservationId(childToken.getAllocationInfo().getReservationId()).userData(this.allocInfo.getRequest().getUserData()).vlan(exNet.getTag()).vmTypeInfo(vmInfo).owner(this.allocInfo.getOwnerFullName()).create();
  final Request<VmRunType,VmRunResponseType> req=AsyncRequests.newRequest(new VmRunCallback(run,childToken));
  if (childToken.getAddress() != null) {
    req.then(new Callback.Success<VmRunResponseType>(){
      @Override public void fire(      final VmRunResponseType response){
        final Address addr=childToken.getAddress();
        for (        final VmInfo vmInfo : response.getVms()) {
          final VmInstance vm=VmInstances.getInstance().lookup(vmInfo.getInstanceId());
          AsyncRequests.newRequest(addr.assign(vm).getCallback()).then(new Callback.Success<BaseMessage>(){
            @Override public void fire(            final BaseMessage response){
              vm.updatePublicAddress(addr.getName());
            }
          }
).dispatch(addr.getPartition());
        }
      }
    }
);
  }
  return req;
}
