{
  try {
    final User owner=Accounts.lookupUserById(this.allocInfo.getOwnerFullName().getUserId());
    if (!owner.isSystemAdmin())     return;
  }
 catch (  final AuthException ex) {
    return;
  }
  if (allocInfo.getUserData() == null || allocInfo.getUserData().length <= 0)   return;
  final String userData=new String(allocInfo.getUserData());
  if (!VmInstances.VmSpecialUserData.apply(userData))   return;
  String payload=null;
  int expirationDays=180;
  try {
    final VmInstances.VmSpecialUserData specialData=new VmInstances.VmSpecialUserData(userData);
    if (!VmInstances.VmSpecialUserData.EUCAKEY_CRED_SETUP.equals(specialData.getKey()))     return;
    final String strExpDay=specialData.getArgValue("expiration_day");
    if (strExpDay != null)     expirationDays=Integer.parseInt(strExpDay);
    payload=specialData.getPayload();
  }
 catch (  final Exception ex) {
    LOG.error("Failed to parse VM user data",ex);
    return;
  }
  this.allocInfo.setUserDataAsString(payload);
  try {
    final KeyPair kp=Certs.generateKeyPair();
    final ServiceConfiguration euare=Topology.lookup(Euare.class);
    final SignCertificateType req=new SignCertificateType();
    final String pubkey=B64.standard.encString(kp.getPublic().getEncoded());
    req.setKey(pubkey);
    req.setInstance(allocInfo.getInstanceId(0));
    req.setExpirationDays(expirationDays);
    final SignCertificateResponseType resp=AsyncRequests.sendSync(euare,req);
    final X509Certificate kpCert=PEMFiles.getCert(B64.standard.dec(resp.getSignCertificateResult().getCertificate()));
    final String b64PubKey=B64.standard.encString(PEMFiles.getBytes(kpCert));
    final MessageDigest digest=Digest.SHA256.get();
    final byte[] salt=new byte[32];
    Crypto.getSecureRandomSupplier().get().nextBytes(salt);
    digest.update(salt);
    final SecretKey symmKey=new SecretKeySpec(digest.digest(),"AES");
    Cipher cipher=Ciphers.AES_GCM.get();
    final byte[] iv=new byte[12];
    Crypto.getSecureRandomSupplier().get().nextBytes(iv);
    cipher.init(Cipher.ENCRYPT_MODE,symmKey,new IvParameterSpec(iv),Crypto.getSecureRandomSupplier().get());
    final byte[] cipherText=cipher.doFinal(Base64.encode(PEMFiles.getBytes(kp.getPrivate())));
    final String encPrivKey=new String(Base64.encode(Arrays.concatenate(iv,cipherText)));
    final String token="NULL";
    cipher=Ciphers.AES_GCM.get();
    cipher.init(Cipher.ENCRYPT_MODE,symmKey,new IvParameterSpec(iv),Crypto.getSecureRandomSupplier().get());
    final byte[] byteToken=cipher.doFinal(token.getBytes());
    final String encToken=new String(Base64.encode(Arrays.concatenate(iv,byteToken)));
    X509Certificate nodeCert=this.allocInfo.getPartition().getNodeCertificate();
    cipher=Ciphers.RSA_PKCS1.get();
    cipher.init(Cipher.ENCRYPT_MODE,nodeCert.getPublicKey(),Crypto.getSecureRandomSupplier().get());
    byte[] symmkey=cipher.doFinal(symmKey.getEncoded());
    final String encSymmKey=new String(Base64.encode(symmkey));
    X509Certificate euareCert=SystemCredentials.lookup(Euare.class).getCertificate();
    final String b64EuarePubkey=B64.standard.encString(PEMFiles.getBytes(euareCert));
    X509Certificate eucalyptusCert=SystemCredentials.lookup(Eucalyptus.class).getCertificate();
    final String b64EucalyptusPubkey=B64.standard.encString(PEMFiles.getBytes(eucalyptusCert));
    final String credential=String.format("%s\n%s\n%s\n%s\n%s\n%s",b64EuarePubkey,b64PubKey,encToken,encSymmKey,encPrivKey,b64EucalyptusPubkey);
    this.allocInfo.setCredential(credential);
  }
 catch (  final Exception ex) {
    LOG.error("failed to setup instance credential",ex);
  }
}
