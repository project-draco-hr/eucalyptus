{
  try {
    USER_GROUP_NAME_CHECKER.check(roleName);
  }
 catch (  InvalidValueException e) {
    Debugging.logError(LOG,e,"Invalid role name " + roleName);
    throw new AuthException(AuthException.INVALID_NAME,e);
  }
  try {
    PATH_CHECKER.check(path);
  }
 catch (  InvalidValueException e) {
    Debugging.logError(LOG,e,"Invalid path " + path);
    throw new AuthException(AuthException.INVALID_PATH,e);
  }
  if (DatabaseAuthUtils.checkRoleExists(roleName,this.delegate.getName())) {
    throw new AuthException(AuthException.ROLE_ALREADY_EXISTS);
  }
  final PolicyEntity parsedPolicy=PolicyParser.getResourceInstance().parse(assumeRolePolicy);
  final EntityWrapper<AccountEntity> db=EntityWrapper.get(AccountEntity.class);
  try {
    final AccountEntity account=DatabaseAuthUtils.getUnique(db,AccountEntity.class,"name",this.delegate.getName());
    final RoleEntity newRole=new RoleEntity(roleName);
    newRole.setRoleId(Crypto.generateQueryId());
    newRole.setPath(path);
    newRole.setAccount(account);
    newRole.setAssumeRolePolicy(parsedPolicy);
    parsedPolicy.setName("assume-role-policy-for-" + newRole.getRoleId());
    final RoleEntity persistedRole=db.recast(RoleEntity.class).persist(newRole);
    db.commit();
    return new DatabaseRoleProxy(persistedRole);
  }
 catch (  Exception e) {
    Debugging.logError(LOG,e,"Failed to add role: " + roleName + " in "+ this.delegate.getName());
    throw new AuthException(AuthException.ROLE_CREATE_FAILURE,e);
  }
 finally {
    if (db.isActive())     db.rollback();
  }
}
