{
  if (!(Bootstrap.isFinished() && Topology.isEnabledLocally(LoadBalancingBackend.class) && Topology.isEnabled(Compute.class)))   return;
  final List<LoadBalancerBackendInstance> allInstances=Lists.newArrayList();
  final List<LoadBalancerBackendInstance> stateOutdated=Lists.newArrayList();
  try (final TransactionResource db=Entities.transactionFor(LoadBalancerBackendInstance.class)){
    allInstances.addAll(Entities.query(LoadBalancerBackendInstance.named()));
  }
 catch (  final Exception ex) {
  }
  final Date current=new Date(System.currentTimeMillis());
  for (  final LoadBalancerBackendInstance be : allInstances) {
    final Date lastUpdate=be.getLastUpdateTimestamp();
    int elapsedSec=(int)((current.getTime() - lastUpdate.getTime()) / 1000.0);
    if (elapsedSec > CHECK_EVERY_SECONDS) {
      stateOutdated.add(be);
    }
  }
  try (final TransactionResource db=Entities.transactionFor(LoadBalancerBackendInstance.class)){
    for (    final LoadBalancerBackendInstance be : stateOutdated) {
      final LoadBalancerBackendInstance update=Entities.uniqueResult(be);
      update.setLastUpdateTimestamp(current);
    }
    db.commit();
  }
 catch (  final Exception ex) {
  }
  final Set<String> instancesToCheck=Sets.newHashSet(Lists.transform(stateOutdated,new Function<LoadBalancerBackendInstance,String>(){
    @Override @Nullable public String apply(    @Nullable LoadBalancerBackendInstance arg0){
      return arg0.getInstanceId();
    }
  }
));
  final List<RunningInstancesItemType> result=Lists.newArrayList();
  for (  final List<String> partition : Iterables.partition(instancesToCheck,NUM_INSTANCES_TO_DESCRIBE)) {
    try {
      result.addAll(EucalyptusActivityTasks.getInstance().describeSystemInstancesWithVerbose(partition));
    }
 catch (    final Exception ex) {
      LOG.warn("failed to query instances",ex);
      break;
    }
  }
  final Set<String> instancesToDelete=Sets.newHashSet();
  final Map<String,STATE> stateMap=new HashMap<String,STATE>();
  final Map<String,RunningInstancesItemType> instanceMap=new HashMap<String,RunningInstancesItemType>();
  for (  final RunningInstancesItemType instance : result) {
    final String state=instance.getStateName();
    if ("pending".equals(state))     stateMap.put(instance.getInstanceId(),STATE.OutOfService);
 else     if ("running".equals(state)) {
      instanceMap.put(instance.getInstanceId(),instance);
    }
 else     if ("shutting-down".equals(state))     stateMap.put(instance.getInstanceId(),STATE.Error);
 else     if ("terminated".equals(state)) {
      stateMap.put(instance.getInstanceId(),STATE.Error);
      instancesToDelete.add(instance.getInstanceId());
    }
 else     if ("stopping".equals(state))     stateMap.put(instance.getInstanceId(),STATE.Error);
 else     if ("stopped".equals(state))     stateMap.put(instance.getInstanceId(),STATE.Error);
  }
  final List<LoadBalancerBackendInstance> beToDelete=Lists.newArrayList();
  for (  final LoadBalancerBackendInstance be : stateOutdated) {
    if (instancesToDelete.contains(be.getInstanceId())) {
      beToDelete.add(be);
      continue;
    }
    if (stateMap.containsKey(be.getInstanceId())) {
      try (final TransactionResource db=Entities.transactionFor(LoadBalancerBackendInstance.class)){
        final STATE trueState=stateMap.get(be.getInstanceId());
        final LoadBalancerBackendInstance update=Entities.uniqueResult(be);
        update.setBackendState(trueState);
        Entities.persist(update);
        db.commit();
      }
 catch (      final Exception ex) {
        ;
      }
 finally {
        LoadBalancingServoCache.getInstance().invalidate(be);
      }
    }
 else     if (instanceMap.containsKey(be.getInstanceId()) && !instanceMap.get(be.getInstanceId()).getIpAddress().equals(be.getIpAddress())) {
      try (final TransactionResource db=Entities.transactionFor(LoadBalancerBackendInstance.class)){
        final LoadBalancerBackendInstance update=Entities.uniqueResult(be);
        update.setIpAddress(instanceMap.get(be.getInstanceId()).getIpAddress());
        update.setPartition(instanceMap.get(be.getInstanceId()).getPlacement());
        Entities.persist(update);
        db.commit();
      }
 catch (      final Exception ex) {
        ;
      }
 finally {
        LoadBalancingServoCache.getInstance().invalidate(be);
      }
    }
  }
  for (  final LoadBalancerBackendInstance be : beToDelete) {
    try (final TransactionResource db=Entities.transactionFor(LoadBalancerBackendInstance.class)){
      final LoadBalancerBackendInstance entity=Entities.uniqueResult(be);
      Entities.delete(entity);
      LOG.info("Instance " + be.getInstanceId() + " is terminated and removed from ELB");
      db.commit();
    }
 catch (    final Exception ex) {
      ;
    }
 finally {
      LoadBalancingServoCache.getInstance().invalidate(be);
    }
  }
}
