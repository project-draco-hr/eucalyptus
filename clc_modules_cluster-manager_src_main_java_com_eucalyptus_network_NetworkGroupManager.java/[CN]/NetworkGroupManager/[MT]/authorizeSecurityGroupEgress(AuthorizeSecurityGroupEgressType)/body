{
  final AuthorizeSecurityGroupEgressResponseType reply=request.getReply().markFailed();
  final Context ctx=Contexts.lookup();
  try (final TransactionResource tx=Entities.transactionFor(NetworkGroup.class)){
    final NetworkGroup ruleGroup=lookupGroup(request.getGroupId(),null);
    if (!RestrictedTypes.filterPrivileged().apply(ruleGroup)) {
      throw new EucalyptusCloudException("Not authorized to authorize network group " + ruleGroup.getDisplayName() + " for "+ ctx.getUser());
    }
    if (ruleGroup.getVpcId() == null) {
      throw new ClientComputeException("InvalidGroup.NotFound","VPC security group (" + request.getGroupId() + ") not found");
    }
    final List<NetworkRule> ruleList=Lists.newArrayList();
    final List<IpPermissionType> ipPermissions=request.getIpPermissions();
    try {
      NetworkGroups.resolvePermissions(ipPermissions,ctx.getUser().getAccountNumber(),ruleGroup.getVpcId(),false);
    }
 catch (    final NoSuchMetadataException e) {
      throw new ClientComputeException("InvalidGroup.NotFound",e.getMessage());
    }
    for (    final IpPermissionType ipPerm : ipPermissions) {
      if (ipPerm.getCidrIpRanges().isEmpty() && ipPerm.getGroups().isEmpty()) {
        continue;
      }
      if (ipPerm.getIpProtocol() == null || !NetworkRule.PROTOCOL_PATTERN.matcher(ipPerm.getIpProtocol()).matches()) {
        throw new ClientComputeException("InvalidPermission.Malformed","Invalid protocol (" + ipPerm.getIpProtocol() + ")");
      }
      try {
        final List<NetworkRule> rules=NetworkGroups.ipPermissionAsNetworkRules(ipPerm,ruleGroup.getVpcId() != null);
        for (        final NetworkRule rule : rules)         rule.setEgress(true);
        ruleList.addAll(rules);
      }
 catch (      final IllegalArgumentException ex) {
        throw new ClientComputeException("InvalidPermission.Malformed",ex.getMessage());
      }
    }
    if (Iterables.any(ruleGroup.getNetworkRules(),new Predicate<NetworkRule>(){
      @Override public boolean apply(      final NetworkRule rule){
        return Iterables.any(ruleList,Predicates.equalTo(rule));
      }
    }
)) {
      return reply;
    }
 else {
      ruleGroup.getNetworkRules().addAll(ruleList);
      if (ruleGroup.getVpcId() != null && ruleGroup.getNetworkRules().size() > VpcConfiguration.getRulesPerSecurityGroup()) {
        throw new ClientComputeException(" RulesPerSecurityGroupLimitExceeded","Rules limit exceeded for " + request.getGroupId());
      }
      reply.set_return(true);
    }
    tx.commit();
    NetworkGroups.flushRules();
    return reply;
  }
 catch (  Exception ex) {
    Logs.exhaust().error(ex,ex);
    throw ex;
  }
}
