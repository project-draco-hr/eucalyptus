{
  ListBucketResponseType reply=(ListBucketResponseType)request.getReply();
  String bucketName=request.getBucket();
  Context ctx=Contexts.lookup();
  Account account=ctx.getAccount();
  String prefix=request.getPrefix();
  if (prefix == null) {
    prefix="";
  }
  String marker=request.getMarker();
  int maxKeys=-1;
  String maxKeysString=request.getMaxKeys();
  if (maxKeysString != null) {
    maxKeys=Integer.parseInt(maxKeysString);
  }
 else {
    maxKeys=WalrusProperties.MAX_KEYS;
  }
  String delimiter=request.getDelimiter();
  EntityWrapper<BucketInfo> db=EntityWrapper.get(BucketInfo.class);
  BucketInfo bucketInfo=new BucketInfo(bucketName);
  bucketInfo.setHidden(false);
  List<BucketInfo> bucketList=db.queryEscape(bucketInfo);
  Hashtable<String,PrefixEntry> prefixes=new Hashtable<String,PrefixEntry>();
  if (bucketList.size() > 0) {
    BucketInfo bucket=bucketList.get(0);
    BucketLogData logData=bucket.getLoggingEnabled() ? request.getLogData() : null;
    if (ctx.hasAdministrativePrivileges() || (bucket.canRead(account.getAccountNumber()) && (bucket.isGlobalRead() || Lookups.checkPrivilege(PolicySpec.S3_LISTBUCKET,PolicySpec.VENDOR_S3,PolicySpec.S3_RESOURCE_BUCKET,bucketName,null)))) {
      if (logData != null) {
        updateLogData(bucket,logData);
        reply.setLogData(logData);
      }
      if (Contexts.lookup().hasAdministrativePrivileges()) {
        try {
          if (bucketHasSnapshots(bucketName)) {
            db.rollback();
            throw new NoSuchBucketException(bucketName);
          }
        }
 catch (        Exception e) {
          db.rollback();
          throw new EucalyptusCloudException(e);
        }
      }
      reply.setName(bucketName);
      reply.setIsTruncated(false);
      reply.setPrefix(prefix);
      if (maxKeys >= 0) {
        reply.setMaxKeys(maxKeys);
      }
      if (delimiter != null) {
        reply.setDelimiter(delimiter);
      }
      if (maxKeys == 0) {
        reply.setContents(new ArrayList<ListEntry>());
        db.commit();
        return reply;
      }
      final int queryStrideSize=maxKeys + 1;
      EntityWrapper<ObjectInfo> dbObject=db.recast(ObjectInfo.class);
      ObjectInfo searchObj=new ObjectInfo();
      searchObj.setBucketName(bucketName);
      searchObj.setLast(true);
      searchObj.setDeleted(false);
      Criteria objCriteria=dbObject.createCriteria(ObjectInfo.class);
      objCriteria.add(Example.create(searchObj));
      objCriteria.addOrder(Order.asc("objectKey"));
      objCriteria.setMaxResults(queryStrideSize);
      if (marker != null) {
        objCriteria.add(Restrictions.ge("objectKey",marker));
      }
      if (prefix != null && !prefix.equals("")) {
        objCriteria.add(Restrictions.like("objectKey",prefix,MatchMode.START));
      }
      List<ObjectInfo> objectInfos=null;
      int resultKeyCount=0;
      String objectKey=null;
      String[] parts=null;
      String prefixString=null;
      ArrayList<ListEntry> contents=new ArrayList<ListEntry>();
      ArrayList<MetaDataEntry> metaData=new ArrayList<MetaDataEntry>();
      do {
        objectKey=null;
        parts=null;
        prefixString=null;
        if (resultKeyCount > 0) {
          objCriteria.setFirstResult(queryStrideSize);
        }
        objectInfos=(List<ObjectInfo>)objCriteria.list();
        if (objectInfos.size() > 0) {
          for (          ObjectInfo objectInfo : objectInfos) {
            objectKey=objectInfo.getObjectKey();
            if (delimiter != null) {
              parts=objectKey.substring(prefix.length()).split(delimiter);
              if (parts.length > 1) {
                prefixString=parts[0] + delimiter;
                if (!prefixes.containsKey(prefixString)) {
                  if (resultKeyCount == maxKeys) {
                    reply.setNextMarker(objectKey);
                    reply.setIsTruncated(true);
                    resultKeyCount++;
                    break;
                  }
                  prefixes.put(prefixString,new PrefixEntry(prefixString));
                  resultKeyCount++;
                }
                continue;
              }
            }
            if (resultKeyCount == maxKeys) {
              reply.setNextMarker(objectKey);
              reply.setIsTruncated(true);
              resultKeyCount++;
              break;
            }
            ListEntry listEntry=new ListEntry();
            listEntry.setKey(objectKey);
            listEntry.setEtag(objectInfo.getEtag());
            listEntry.setLastModified(DateUtils.format(objectInfo.getLastModified().getTime(),DateUtils.ISO8601_DATETIME_PATTERN) + ".000Z");
            listEntry.setStorageClass(objectInfo.getStorageClass());
            try {
              listEntry.setOwner(new CanonicalUserType(objectInfo.getOwnerId(),Accounts.lookupAccountById(objectInfo.getOwnerId()).getName()));
            }
 catch (            AuthException e) {
              db.rollback();
              throw new AccessDeniedException("Bucket",bucketName,logData);
            }
            objectInfo.returnMetaData(metaData);
            listEntry.setSize(objectInfo.getSize());
            listEntry.setStorageClass(objectInfo.getStorageClass());
            contents.add(listEntry);
            resultKeyCount++;
          }
        }
        if (resultKeyCount <= maxKeys && objectInfos.size() <= maxKeys) {
          break;
        }
      }
 while (resultKeyCount <= maxKeys);
      reply.setMetaData(metaData);
      reply.setContents(contents);
      if (prefixes != null && prefixes.size() > 0) {
        ArrayList<PrefixEntry> prefixList=new ArrayList<PrefixEntry>();
        prefixList.addAll(prefixes.values());
        Collections.sort(prefixList,new Comparator<PrefixEntry>(){
          public int compare(          PrefixEntry e1,          PrefixEntry e2){
            return e1.getPrefix().compareTo(e2.getPrefix());
          }
        }
);
        reply.setCommonPrefixes(prefixList);
      }
    }
 else {
      db.rollback();
      throw new AccessDeniedException("Bucket",bucketName,logData);
    }
  }
 else {
    db.rollback();
    throw new NoSuchBucketException(bucketName);
  }
  db.commit();
  return reply;
}
