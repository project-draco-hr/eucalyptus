{
  Class<?> eventDecl=Classes.ncestor(listener,EventListener.class);
  if (eventDecl == null) {
    throw Exceptions.fatal(new IllegalArgumentException("Failed to register listener " + listener.getClass().getCanonicalName() + " because of a bug in looking up the interface declaration."));
  }
  final List<Class<?>> lookupTypes=Classes.genericsToClasses(eventDecl);
  boolean illegal=(type == null && lookupTypes.isEmpty());
  illegal|=(type != null && !lookupTypes.contains(Event.class) && !lookupTypes.get(0).isAssignableFrom(Classes.typeOf(type)));
  if (illegal) {
    throw Exceptions.fatal(new IllegalArgumentException("Failed to register listener " + listener.getClass().getCanonicalName() + " because the declared generic type "+ lookupTypes+ " is not assignable from the provided event type: "+ (type != null ? type.getClass().getCanonicalName() : "null")));
  }
 else {
    if ((type instanceof Class) && Event.class.isAssignableFrom((Class)type)) {
      this.eventMap.register((Class)type,listener);
    }
 else {
      if (!this.registryMap.containsKey(type.getClass())) {
        this.registryMap.put(type.getClass(),new ReentrantListenerRegistry());
      }
      this.registryMap.get(type.getClass()).register(type,listener);
    }
  }
}
