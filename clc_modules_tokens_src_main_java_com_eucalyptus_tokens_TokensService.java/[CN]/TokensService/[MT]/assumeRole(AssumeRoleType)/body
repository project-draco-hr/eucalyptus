{
  final AssumeRoleResponseType reply=request.getReply();
  reply.getResponseMetadata().setRequestId(reply.getCorrelationId());
  final Context ctx=Contexts.lookup();
  final Subject subject=ctx.getSubject();
  final Set<QueryIdCredential> queryIdCreds=subject == null ? Collections.<QueryIdCredential>emptySet() : subject.getPublicCredentials(QueryIdCredential.class);
  if (queryIdCreds.size() == 1 && Iterables.get(queryIdCreds,0).getType().isPresent()) {
    throw new TokensException(TokensException.Code.MissingAuthenticationToken,"Temporary credential not permitted.");
  }
  rejectPasswordCredentials();
  final BaseRole role=lookupRole(request.getRoleArn());
  try {
    ExternalIdContext.doWithExternalId(request.getExternalId(),EucalyptusCloudException.class,new Callable<BaseRole>(){
      @Override public BaseRole call() throws TokensException {
        try {
          return RestrictedTypes.doPrivilegedWithoutOwner(Accounts.getRoleFullName(role),new RoleResolver(role));
        }
 catch (        final AuthException e) {
          throw new TokensException(TokensException.Code.AccessDenied,e.getMessage());
        }
      }
    }
);
    final SecurityToken token=SecurityTokenManager.issueSecurityToken(role,Objects.firstNonNull(request.getDurationSeconds(),(int)TimeUnit.HOURS.toSeconds(1)));
    reply.getAssumeRoleResult().setCredentials(new CredentialsType(token.getAccessKeyId(),token.getSecretKey(),token.getToken(),token.getExpires()));
    reply.getAssumeRoleResult().setAssumedRoleUser(new AssumedRoleUserType(role.getRoleId() + ":" + request.getRoleSessionName(),assumedRoleArn(role,request.getRoleSessionName())));
  }
 catch (  final SecurityTokenValidationException e) {
    throw new TokensException(TokensException.Code.ValidationError,e.getMessage());
  }
catch (  final AuthException e) {
    throw new EucalyptusCloudException(e.getMessage(),e);
  }
  return reply;
}
