{
  GetObjectResponseType reply=(GetObjectResponseType)request.getReply();
  reply.setHasStreamingData(false);
  String bucketName=request.getBucket();
  String objectKey=request.getKey();
  Context ctx=Contexts.lookup();
  Account account=ctx.getAccount();
  Boolean deleteAfterGet=request.getDeleteAfterGet();
  if (deleteAfterGet == null) {
    deleteAfterGet=false;
  }
  Boolean getMetaData=request.getGetMetaData();
  if (getMetaData == null) {
    getMetaData=false;
  }
  Boolean getData=request.getGetData();
  if (getData == null) {
    getData=false;
  }
  EntityWrapper<BucketInfo> db=EntityWrapper.get(BucketInfo.class);
  BucketInfo bucketInfo=new BucketInfo(bucketName);
  List<BucketInfo> bucketList=db.queryEscape(bucketInfo);
  if (bucketList.size() > 0) {
    BucketInfo bucket=bucketList.get(0);
    BucketLogData logData=bucket.getLoggingEnabled() ? request.getLogData() : null;
    boolean versioning=false;
    if (bucket.isVersioningEnabled()) {
      versioning=true;
    }
    EntityWrapper<ObjectInfo> dbObject=db.recast(ObjectInfo.class);
    ObjectInfo searchObjectInfo=new ObjectInfo(bucketName,objectKey);
    searchObjectInfo.setVersionId(request.getVersionId());
    searchObjectInfo.setDeleted(false);
    if (request.getVersionId() == null) {
      searchObjectInfo.setLast(true);
    }
    List<ObjectInfo> objectInfos=dbObject.queryEscape(searchObjectInfo);
    if (objectInfos.size() > 0) {
      ObjectInfo objectInfo=objectInfos.get(0);
      String objectName=objectInfo.getObjectName();
      if (getMetaData) {
        ArrayList<MetaDataEntry> metaData=new ArrayList<MetaDataEntry>();
        List<MetaDataInfo> metaDataInfos=objectInfo.getMetaData();
        for (        MetaDataInfo metaDataInfo : metaDataInfos) {
          metaData.add(new MetaDataEntry(metaDataInfo.getName(),metaDataInfo.getValue()));
        }
        reply.setMetaData(metaData);
      }
      Date lastModified=objectInfo.getLastModified();
      Long size=objectInfo.getSize();
      String etag=objectInfo.getEtag();
      String contentType=objectInfo.getContentType();
      String contentDisposition=objectInfo.getContentDisposition();
      db.commit();
      if (logData != null) {
        updateLogData(bucket,logData);
        logData.setObjectSize(size);
      }
      String versionId=null;
      if (versioning) {
        versionId=objectInfo.getVersionId();
      }
      if (request.getGetData()) {
        if (objectInfo.isMultipart()) {
          String inlineData=getMultipartData(objectInfo,request,reply);
          if (inlineData != null) {
            reply.setBase64Data(inlineData);
          }
        }
 else {
          if (request.getInlineData()) {
            if ((size * 4) > WalrusProperties.MAX_INLINE_DATA_SIZE) {
              throw new InlineDataTooLargeException(bucketName + "/" + objectKey);
            }
            byte[] bytes=new byte[102400];
            int bytesRead=0, offset=0;
            String base64Data="";
            try {
              FileIO fileIO=storageManager.prepareForRead(bucketName,objectName);
              while ((bytesRead=fileIO.read(offset)) > 0) {
                ByteBuffer buffer=fileIO.getBuffer();
                if (buffer != null) {
                  buffer.get(bytes,0,bytesRead);
                  base64Data+=new String(bytes,0,bytesRead);
                  offset+=bytesRead;
                }
              }
              fileIO.finish();
            }
 catch (            Exception e) {
              LOG.error(e,e);
              throw new InternalErrorException(e);
            }
            reply.setBase64Data(Hashes.base64encode(base64Data));
          }
 else {
            reply.setHasStreamingData(true);
            storageManager.getObject(bucketName,objectName,reply,size,request.getIsCompressed());
          }
        }
      }
      reply.setEtag(etag);
      reply.setLastModified(lastModified);
      reply.setVersionId(versionId);
      reply.setSize(size);
      reply.setContentType(contentType);
      reply.setContentDisposition(contentDisposition);
      Status status=new Status();
      status.setCode(200);
      status.setDescription("OK");
      reply.setStatus(status);
      return reply;
    }
 else {
      db.rollback();
      if (getData) {
        throw new NoSuchEntityException(objectKey);
      }
 else {
        throw new HeadNoSuchEntityException(objectKey);
      }
    }
  }
 else {
    db.rollback();
    if (getData) {
      throw new NoSuchBucketException(bucketName);
    }
 else {
      throw new HeadNoSuchBucketException(bucketName);
    }
  }
}
