{
  ListVersionsResponseType reply=(ListVersionsResponseType)request.getReply();
  EntityWrapper<BucketInfo> db=EntityWrapper.get(BucketInfo.class);
  try {
    String bucketName=request.getBucket();
    BucketInfo bucketInfo=new BucketInfo(bucketName);
    bucketInfo.setHidden(false);
    List<BucketInfo> bucketList=db.queryEscape(bucketInfo);
    Context ctx=Contexts.lookup();
    Account account=ctx.getAccount();
    int maxKeys=-1;
    String maxKeysString=request.getMaxKeys();
    if (maxKeysString != null) {
      maxKeys=Integer.parseInt(maxKeysString);
      if (maxKeys < 0) {
        throw new InvalidArgumentException("max-keys","Argument max-keys must be an integer between 0 and " + Integer.MAX_VALUE);
      }
    }
 else {
      maxKeys=WalrusProperties.MAX_KEYS;
    }
    if (bucketList.size() > 0) {
      BucketInfo bucket=bucketList.get(0);
      BucketLogData logData=bucket.getLoggingEnabled() ? request.getLogData() : null;
      if (logData != null) {
        updateLogData(bucket,logData);
        reply.setLogData(logData);
      }
      String prefix=request.getPrefix();
      String keyMarker=request.getKeyMarker();
      String versionMarker=request.getVersionIdMarker();
      String delimiter=request.getDelimiter();
      reply.setName(bucketName);
      reply.setIsTruncated(false);
      reply.setPrefix(prefix);
      reply.setMaxKeys(maxKeys);
      reply.setDelimiter(delimiter);
      reply.setKeyMarker(keyMarker);
      reply.setVersionIdMarker(versionMarker);
      if (bucket.isVersioningDisabled()) {
        db.commit();
        return reply;
      }
      if (maxKeys == 0) {
        reply.setKeyEntries(new ArrayList<KeyEntry>());
        reply.setCommonPrefixesList(new ArrayList<CommonPrefixesEntry>());
        db.commit();
        return reply;
      }
      final int queryStrideSize=maxKeys + 1;
      EntityWrapper<ObjectInfo> dbObject=db.recast(ObjectInfo.class);
      ObjectInfo searchObj=new ObjectInfo();
      searchObj.setBucketName(bucketName);
      Criteria objCriteria=dbObject.createCriteria(ObjectInfo.class);
      objCriteria.add(Example.create(searchObj));
      objCriteria.addOrder(Order.asc("objectKey"));
      objCriteria.addOrder(Order.desc("lastModified"));
      objCriteria.setMaxResults(queryStrideSize);
      keyMarker=(Strings.isNullOrEmpty(keyMarker) ? "" : keyMarker);
      prefix=(Strings.isNullOrEmpty(prefix) ? "" : prefix);
      versionMarker=(Strings.isNullOrEmpty(versionMarker) ? "" : versionMarker);
      if (!Strings.isNullOrEmpty(keyMarker)) {
        if (!Strings.isNullOrEmpty(versionMarker)) {
          Date resumeDate=null;
          try {
            ObjectInfo markerObj=new ObjectInfo();
            markerObj.setBucketName(bucketName);
            markerObj.setVersionId(versionMarker);
            markerObj.setObjectKey(keyMarker);
            ObjectInfo lastFromPrevObj=dbObject.uniqueResultEscape(markerObj);
            if (lastFromPrevObj != null && lastFromPrevObj.getLastModified() != null) {
              resumeDate=lastFromPrevObj.getLastModified();
            }
 else {
              dbObject.rollback();
              throw new NoSuchEntityException("VersionIDMarker " + versionMarker + " does not match an existing object version");
            }
          }
 catch (          TransactionException e) {
            LOG.error(e);
            dbObject.rollback();
            throw new InternalErrorException("Next-Key-Marker or Next-Version-Id marker invalid");
          }
          objCriteria.add(Restrictions.or(Restrictions.and(Restrictions.eq("objectKey",keyMarker),Restrictions.lt("lastModified",resumeDate)),Restrictions.gt("objectKey",keyMarker)));
        }
 else {
          objCriteria.add(Restrictions.gt("objectKey",keyMarker));
        }
      }
      if (!Strings.isNullOrEmpty(prefix)) {
        objCriteria.add(Restrictions.like("objectKey",prefix,MatchMode.START));
      }
 else {
        prefix="";
      }
      List<ObjectInfo> objectInfos=null;
      int resultKeyCount=0;
      ArrayList<KeyEntry> keyEntries=new ArrayList<KeyEntry>();
      String nextKeyMarker=null;
      String nextVersionIdMarker=null;
      TreeSet<String> commonPrefixes=new TreeSet<String>();
      int firstResult=-1;
      do {
        objCriteria.setFirstResult(queryStrideSize * (++firstResult));
        objectInfos=(List<ObjectInfo>)objCriteria.list();
        if (objectInfos.size() > 0) {
          for (          ObjectInfo objectInfo : objectInfos) {
            String objectKey=objectInfo.getObjectKey();
            if (!Strings.isNullOrEmpty(delimiter)) {
              String[] parts=objectKey.substring(prefix.length()).split(delimiter);
              if (parts.length > 1) {
                String prefixString=prefix + parts[0] + delimiter;
                if (!StringUtils.equals(prefixString,keyMarker) && !commonPrefixes.contains(prefixString)) {
                  if (resultKeyCount == maxKeys) {
                    reply.setNextKeyMarker(nextKeyMarker);
                    reply.setNextVersionIdMarker(nextVersionIdMarker);
                    reply.setIsTruncated(true);
                    resultKeyCount++;
                    break;
                  }
                  commonPrefixes.add(prefixString);
                  resultKeyCount++;
                  if (resultKeyCount == maxKeys) {
                    nextKeyMarker=prefixString;
                    nextVersionIdMarker=null;
                  }
                }
                continue;
              }
            }
            if (resultKeyCount == maxKeys) {
              reply.setNextKeyMarker(nextKeyMarker);
              reply.setNextVersionIdMarker(nextVersionIdMarker);
              reply.setIsTruncated(true);
              resultKeyCount++;
              break;
            }
            KeyEntry keyEntry=null;
            if (!objectInfo.getDeleted()) {
              keyEntry=new VersionEntry();
              ((VersionEntry)keyEntry).setEtag(objectInfo.getEtag());
              ((VersionEntry)keyEntry).setSize(objectInfo.getSize());
              ((VersionEntry)keyEntry).setStorageClass(objectInfo.getStorageClass());
            }
 else {
              keyEntry=new DeleteMarkerEntry();
            }
            keyEntry.setKey(objectKey);
            keyEntry.setVersionId(objectInfo.getVersionId());
            keyEntry.setIsLatest(objectInfo.getLast());
            keyEntry.setLastModified(DateFormatter.dateToListingFormattedString(objectInfo.getLastModified()));
            try {
              Account ownerAccount=Accounts.lookupAccountById(objectInfo.getOwnerId());
              keyEntry.setOwner(new CanonicalUser(ownerAccount.getCanonicalId(),ownerAccount.getName()));
            }
 catch (            AuthException e) {
              db.rollback();
              throw new AccessDeniedException("Bucket",bucketName,logData);
            }
            keyEntries.add(keyEntry);
            resultKeyCount++;
            if (resultKeyCount == maxKeys) {
              nextKeyMarker=objectKey;
              nextVersionIdMarker=objectInfo.getVersionId();
            }
          }
        }
        if (resultKeyCount <= maxKeys && objectInfos.size() <= maxKeys) {
          break;
        }
      }
 while (resultKeyCount <= maxKeys);
      reply.setKeyEntries(keyEntries);
      if (!commonPrefixes.isEmpty()) {
        ArrayList<CommonPrefixesEntry> commonPrefixesList=new ArrayList<CommonPrefixesEntry>();
        for (        String prefixEntry : commonPrefixes) {
          commonPrefixesList.add(new CommonPrefixesEntry(prefixEntry));
        }
        reply.setCommonPrefixesList(commonPrefixesList);
      }
    }
 else {
      db.rollback();
      throw new NoSuchBucketException(bucketName);
    }
    db.commit();
    return reply;
  }
  finally {
    if (db.isActive()) {
      db.rollback();
    }
  }
}
