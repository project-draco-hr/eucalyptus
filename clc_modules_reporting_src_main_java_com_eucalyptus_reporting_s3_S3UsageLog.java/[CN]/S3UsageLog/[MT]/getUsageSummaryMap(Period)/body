{
  log.info("GetUsageSummaryMap period:" + period);
  final Map<S3SnapshotKey,S3UsageSummary> usageMap=new HashMap<S3SnapshotKey,S3UsageSummary>();
  EntityWrapper<S3UsageSummary> entityWrapper=EntityWrapper.get(S3UsageSummary.class);
  try {
    long foundTimestampMs=0l;
    final long oneHourMs=60 * 60 * 1000;
    for (int i=2; (period.getBeginningMs() - oneHourMs * (long)i) > 0; i=(int)Math.pow(i,2)) {
      long startingMs=period.getBeginningMs() - (oneHourMs * i);
      @SuppressWarnings("rawtypes") Iterator iter=entityWrapper.createQuery("from S3UsageSnapshot as sus" + " WHERE sus.key.timestampMs > ?" + " AND sus.key.timestampMs < ?"+ " AND sus.key.allSnapshot = true").setLong(0,new Long(startingMs)).setLong(1,new Long(period.getBeginningMs())).iterate();
      while (iter.hasNext()) {
        S3UsageSnapshot snapshot=(S3UsageSnapshot)iter.next();
        foundTimestampMs=snapshot.getSnapshotKey().getTimestampMs();
        log.info("Found latest timestamp before beginning:" + foundTimestampMs);
      }
      if (foundTimestampMs != 0l)       break;
    }
    Map<S3SnapshotKey,S3DataAccumulator> dataAccumulatorMap=new HashMap<S3SnapshotKey,S3DataAccumulator>();
    @SuppressWarnings("rawtypes") Iterator iter=entityWrapper.createQuery("from S3UsageSnapshot as sus" + " WHERE sus.key.timestampMs > ?" + " AND sus.key.timestampMs < ?").setLong(0,new Long(foundTimestampMs)).setLong(1,new Long(period.getEndingMs())).iterate();
    while (iter.hasNext()) {
      S3UsageSnapshot snapshot=(S3UsageSnapshot)iter.next();
      S3SnapshotKey key=snapshot.getSnapshotKey();
      key=new S3SnapshotKey(key);
      key.setAllSnapshot(false);
      if (key.getTimestampMs() < period.getBeginningMs() || !dataAccumulatorMap.containsKey(key)) {
        S3DataAccumulator accumulator=new S3DataAccumulator(key.getTimestampMs(),snapshot.getUsageData(),new S3UsageSummary());
        dataAccumulatorMap.put(key,accumulator);
      }
 else {
        S3DataAccumulator accumulator=dataAccumulatorMap.get(key);
        long beginningMs=Math.max(period.getBeginningMs(),accumulator.getLastTimestamp());
        long endingMs=key.getTimestampMs() - 1;
        long durationSecs=(endingMs - beginningMs) / 1000;
        accumulator.accumulateUsage(durationSecs);
        accumulator.setLastTimestamp(key.getTimestampMs());
        accumulator.setLastUsageData(snapshot.getUsageData());
        log.info("Accumulate usage, begin:" + beginningMs + " end:"+ endingMs);
      }
    }
    for (    S3SnapshotKey key : dataAccumulatorMap.keySet()) {
      S3DataAccumulator accumulator=dataAccumulatorMap.get(key);
      long beginningMs=Math.max(period.getBeginningMs(),accumulator.getLastTimestamp());
      long endingMs=period.getEndingMs() - 1;
      long durationSecs=(endingMs - beginningMs) / 1000;
      accumulator.accumulateUsage(durationSecs);
      log.info("Accumulate end usage, begin:" + beginningMs + " end:"+ endingMs);
      usageMap.put(key,accumulator.getCurrentSummary());
    }
    entityWrapper.commit();
  }
 catch (  Exception ex) {
    log.error(ex);
    entityWrapper.rollback();
    throw new RuntimeException(ex);
  }
  return usageMap;
}
