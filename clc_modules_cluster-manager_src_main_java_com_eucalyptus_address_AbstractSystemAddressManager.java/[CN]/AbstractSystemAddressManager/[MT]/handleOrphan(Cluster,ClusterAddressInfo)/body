{
  Integer orphanCount=1;
  orphanCount=orphans.putIfAbsent(address,orphanCount);
  orphanCount=(orphanCount == null) ? 1 : orphanCount;
  orphans.put(address,orphanCount + 1);
  EventRecord.caller(ClusterState.class,EventType.ADDRESS_STATE,"Updated orphaned public ip address: " + LogUtil.dumpObject(address) + " count="+ orphanCount).debug();
  if (orphanCount > AddressingConfiguration.getInstance().getMaxKillOrphans()) {
    EventRecord.caller(ClusterState.class,EventType.ADDRESS_STATE,"Unassigning orphaned public ip address: " + LogUtil.dumpObject(address) + " count="+ orphanCount).warn();
    try {
      final Address addr=Addresses.getInstance().lookup(address.getAddress());
      if (addr.isPending()) {
        try {
          addr.clearPending();
        }
 catch (        Exception ex) {
        }
      }
      try {
        if (addr.isAssigned() && "0.0.0.0".equals(address.getInstanceIp())) {
          addr.unassign().clearPending();
          if (addr.isSystemOwned()) {
            addr.release();
          }
        }
 else         if (addr.isAssigned() && !"0.0.0.0".equals(address.getInstanceIp())) {
          AddressingDispatcher.sendSync(AsyncRequests.newRequest(new UnassignAddressCallback(address)),cluster.getConfiguration());
          if (addr.isSystemOwned()) {
            addr.release();
          }
        }
 else         if (!addr.isAssigned() && addr.isAllocated() && addr.isSystemOwned()) {
          addr.release();
        }
      }
 catch (      ExecutionException ex) {
        if (!addr.isAssigned() && addr.isAllocated() && addr.isSystemOwned()) {
          addr.release();
        }
      }
    }
 catch (    InterruptedException ex) {
      Exceptions.maybeInterrupted(ex);
    }
catch (    NoSuchElementException ex) {
    }
 finally {
      orphans.remove(address);
    }
  }
}
