{
  if (serverShutdown != null) {
    serverShutdown.run();
    serverShutdown=null;
  }
  final Executor workerPool=workerPool();
  final ChannelFactory serverChannelFactory=channelFactory(workerPool);
  final ChannelPipelineFactory serverPipelineFactory=Handlers.serverPipelineFactory();
  final ChannelGroup serverChannelGroup=channelGroup();
  final ChannelHandler channelGroupHandler=new ChannelGroupChannelHandler(serverChannelGroup);
  final ChannelPipelineFactory pipelineFactory=new ChannelPipelineFactory(){
    @Override public ChannelPipeline getPipeline() throws Exception {
      ChannelPipeline pipeline=serverPipelineFactory.getPipeline();
      pipeline.addLast("channel-group-handler",channelGroupHandler);
      return pipeline;
    }
  }
;
  final ServerBootstrap bootstrap=serverBootstrap(serverChannelFactory,pipelineFactory);
  if (!StackConfiguration.INTERNAL_PORT.equals(StackConfiguration.PORT)) {
    try {
      final Channel serverChannel=bootstrap.bind(new InetSocketAddress(StackConfiguration.PORT));
      serverChannelGroup.add(serverChannel);
    }
 catch (    ChannelException ex) {
      LOG.error("Unable to bind to auxiliary port " + StackConfiguration.PORT + " in the web services stack, port may be already in use.  "+ "Port "+ StackConfiguration.INTERNAL_PORT+ " will still be available as the internal web services port, however.");
    }
  }
  try {
    final Channel serverChannel=bootstrap.bind(new InetSocketAddress(StackConfiguration.INTERNAL_PORT));
    serverChannelGroup.add(serverChannel);
    serverShutdown=new Runnable(){
      AtomicBoolean ranned=new AtomicBoolean(false);
      @Override public void run(){
        if (this.ranned.compareAndSet(false,true)) {
          serverChannelGroup.close().awaitUninterruptibly();
          serverChannelFactory.releaseExternalResources();
        }
      }
    }
;
    OrderedShutdown.registerPreShutdownHook(serverShutdown);
  }
 catch (  Exception ex) {
    LOG.error(ex,ex);
  }
}
